{
  "files": [
    {
      "name": "provider.tf",
      "content": "terraform {\n  required_version = \">= 1.3.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 4.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy resources in.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Name prefix for all resources.\"\n  type        = string\n  default     = \"playwright-lambda\"\n}\n\nvariable \"lambda_timeout\" {\n  description = \"Timeout for the Lambda function in seconds.\"\n  type        = number\n  default     = 60\n}\n\nvariable \"lambda_memory_size\" {\n  description = \"Memory size for the Lambda function in MB.\"\n  type        = number\n  default     = 1024\n}\n\nvariable \"lambda_image_uri\" {\n  description = \"ECR image URI for the Lambda function (must be set after pushing image).\"\n  type        = string\n}\n"
    },
    {
      "name": "main.tf",
      "content": "resource \"aws_ecr_repository\" \"lambda_repo\" {\n  name = \"${var.project_name}-repo\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  force_delete = true\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"${var.project_name}-lambda-exec\"\n  assume_role_policy = data.aws_iam_policy_document.lambda_assume_role.json\n}\n\ndata \"aws_iam_policy_document\" \"lambda_assume_role\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n    principals {\n      type        = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_policy\" \"lambda_ecr_policy\" {\n  name        = \"${var.project_name}-lambda-ecr-policy\"\n  description = \"Allow Lambda to pull from ECR and write logs to CloudWatch.\"\n  policy      = data.aws_iam_policy_document.lambda_ecr_policy.json\n}\n\ndata \"aws_iam_policy_document\" \"lambda_ecr_policy\" {\n  statement {\n    actions = [\n      \"ecr:GetAuthorizationToken\",\n      \"ecr:BatchCheckLayerAvailability\",\n      \"ecr:GetDownloadUrlForLayer\",\n      \"ecr:BatchGetImage\"\n    ]\n    resources = [\"*\"]\n  }\n  statement {\n    actions = [\n      \"logs:CreateLogGroup\",\n      \"logs:CreateLogStream\",\n      \"logs:PutLogEvents\"\n    ]\n    resources = [\"arn:aws:logs:*:*:*\"]\n  }\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_ecr_attach\" {\n  role       = aws_iam_role.lambda_exec.name\n  policy_arn = aws_iam_policy.lambda_ecr_policy.arn\n}\n\nresource \"aws_cloudwatch_log_group\" \"lambda_log_group\" {\n  name              = \"/aws/lambda/${var.project_name}\"\n  retention_in_days = 14\n}\n\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\nresource \"aws_subnet\" \"private_a\" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.1.0/24\"\n  availability_zone       = data.aws_availability_zones.available.names[0]\n  map_public_ip_on_launch = false\n  tags = {\n    Name = \"${var.project_name}-subnet-a\"\n  }\n}\n\nresource \"aws_subnet\" \"private_b\" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.2.0/24\"\n  availability_zone       = data.aws_availability_zones.available.names[1]\n  map_public_ip_on_launch = false\n  tags = {\n    Name = \"${var.project_name}-subnet-b\"\n  }\n}\n\ndata \"aws_availability_zones\" \"available\" {}\n\nresource \"aws_security_group\" \"lambda_sg\" {\n  name        = \"${var.project_name}-lambda-sg\"\n  description = \"Security group for Lambda function\"\n  vpc_id      = aws_vpc.main.id\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  ingress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  tags = {\n    Name = \"${var.project_name}-lambda-sg\"\n  }\n}\n\nresource \"aws_lambda_function\" \"playwright_lambda\" {\n  function_name = var.project_name\n  package_type  = \"Image\"\n  image_uri     = var.lambda_image_uri\n  role          = aws_iam_role.lambda_exec.arn\n  timeout       = var.lambda_timeout\n  memory_size   = var.lambda_memory_size\n  vpc_config {\n    subnet_ids         = [aws_subnet.private_a.id, aws_subnet.private_b.id]\n    security_group_ids = [aws_security_group.lambda_sg.id]\n  }\n  environment {\n    variables = {\n      NODE_ENV = \"production\"\n    }\n  }\n  depends_on = [aws_iam_role_policy_attachment.lambda_ecr_attach]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"ecr_repository_url\" {\n  description = \"URL of the ECR repository for Lambda image.\"\n  value       = aws_ecr_repository.lambda_repo.repository_url\n}\n\noutput \"lambda_function_name\" {\n  description = \"Name of the deployed Lambda function.\"\n  value       = aws_lambda_function.playwright_lambda.function_name\n}\n\noutput \"lambda_log_group_name\" {\n  description = \"CloudWatch Log Group for Lambda.\"\n  value       = aws_cloudwatch_log_group.lambda_log_group.name\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region    = \"us-east-1\"\nproject_name  = \"playwright-lambda\"\nlambda_timeout = 60\nlambda_memory_size = 1024\n# lambda_image_uri must be set to the ECR image URI after pushing the Docker image\nlambda_image_uri = \"<ECR_IMAGE_URI>\"\n"
    },
    {
      "name": "README.md",
      "content": "# Playwright Lambda Terraform Deployment\n\nThis Terraform configuration provisions the AWS infrastructure for running Playwright-based JavaScript code in AWS Lambda using a Docker image stored in Amazon ECR.\n\n## Resources Created\n- Amazon ECR repository for Docker image storage\n- IAM role and policy for Lambda execution and ECR access\n- VPC with two private subnets\n- Security group for Lambda\n- CloudWatch Log Group for Lambda logs\n- Lambda function (container image)\n\n## Usage\n1. **Build and Push Docker Image**\n   - Build your Docker image locally using the provided Dockerfile.\n   - Tag and push the image to the ECR repository output by Terraform.\n2. **Update `terraform.tfvars`**\n   - Set `lambda_image_uri` to the full ECR image URI (including tag).\n3. **Apply Terraform**\n   - Run `terraform init`, `terraform plan`, and `terraform apply`.\n\n## Notes\n- The Lambda function will not deploy successfully until `lambda_image_uri` is set to a valid ECR image URI.\n- Adjust VPC/subnet CIDRs and Lambda memory/timeout as needed.\n"
    },
    {
      "name": ".gitignore",
      "content": "# Local .terraform directories\n.terraform/\n\n# .tfstate files\n*.tfstate\n*.tfstate.*\n\n# Crash log files\ncrash.log\n\n# Exclude tfvars with secrets\n*.auto.tfvars\n*.tfvars\n"
    }
  ]
}