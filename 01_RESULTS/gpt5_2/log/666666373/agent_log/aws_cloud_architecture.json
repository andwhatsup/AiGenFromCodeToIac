{
  "aws_architecture_description": "## Proposed high-level AWS architecture (Java WAR on Tomcat container, deployed to Kubernetes)\n\n### 1) Core runtime: Amazon EKS (managed Kubernetes)\n- Deploy the existing containerized Tomcat 8 + WAR application onto **Amazon EKS**.\n- Use **EKS Managed Node Groups** (EC2 worker nodes) across **at least 2 Availability Zones** for high availability.\n- Keep the existing Kubernetes objects (Deployment with `replicas=2`) but modernize exposure:\n  - Replace the current **NodePort** pattern with an **AWS Load Balancer Controller**-backed **Ingress**.\n  - Traffic flow becomes: **Internet → ALB (HTTPS) → Kubernetes Ingress → Service (ClusterIP) → Pods (Tomcat)**.\n- Configure **Horizontal Pod Autoscaler (HPA)** (optional but recommended) to scale replicas based on CPU/memory.\n\n### 2) Container image registry: Amazon ECR (instead of Docker Hub)\n- Store built images in **Amazon ECR** to keep artifacts inside AWS, simplify IAM-based auth, and reduce external dependency.\n- Jenkins (or a managed CI service) pushes images to ECR; EKS pulls images from ECR.\n\n### 3) CI/CD: Jenkins on AWS (lean option) or AWS-native (recommended)\n**Lean / minimal change (keep Jenkins):**\n- Run Jenkins on **EC2** (or on EKS) in private subnets.\n- Use an **IAM role** for the Jenkins instance/agent to:\n  - Push to ECR\n  - Deploy to EKS (via `kubectl`/`helm`)\n- Store pipeline secrets (ECR creds not needed if using IAM; other secrets) in **AWS Secrets Manager**.\n\n**Recommended AWS-native evolution (optional):**\n- Use **CodePipeline + CodeBuild** to build/test/package, build the Docker image, push to ECR, and deploy to EKS.\n- This reduces ops overhead of managing Jenkins.\n\n### 4) Networking and edge\n- Create a dedicated **VPC** with:\n  - **Public subnets** (ALB, NAT Gateways)\n  - **Private subnets** (EKS nodes, Jenkins/CI, internal services)\n- Use **Route 53** for DNS (e.g., `app.example.com`) pointing to the ALB.\n- Use **ACM** to issue/attach TLS certificates to the ALB for HTTPS.\n- Use **NAT Gateways** so private subnets can reach ECR/S3/OS package repos without being publicly reachable.\n- Add **VPC Endpoints** (Interface/Gateway) where it reduces NAT cost and improves security (notably ECR API/DKR, S3, CloudWatch Logs).\n\n### 5) Observability and logging\n- Send container stdout/stderr and node logs to **CloudWatch Logs** (via Fluent Bit / Container Insights).\n- Use **CloudWatch metrics/alarms** for:\n  - ALB 4xx/5xx, latency\n  - EKS node health / CPU / memory\n  - Pod restarts\n- Use **AWS X-Ray** only if you later add tracing instrumentation (optional).\n\n### 6) Security baseline\n- Use **IAM Roles for Service Accounts (IRSA)** so Kubernetes controllers (AWS Load Balancer Controller, external-dns if used, etc.) get least-privilege AWS access.\n- Use **Security Groups**:\n  - ALB SG: allow 443 from Internet\n  - Node SG: allow only from ALB to NodePorts/target group ports (via controller-managed rules)\n  - Jenkins SG: restrict inbound to corporate IP/VPN/bastion only\n- Use **KMS** to encrypt:\n  - EKS secrets encryption (envelope encryption)\n  - ECR at rest (default encryption; optionally CMK)\n  - Secrets Manager\n- Store application secrets (DB creds, API keys) in **Secrets Manager** and mount/inject into pods.\n\n### 7) Data layer (only if the app needs persistence)\n- Your analysis doesn’t show a database dependency. If the app later needs persistence:\n  - Use **Amazon RDS** (e.g., MySQL/PostgreSQL) in private subnets\n  - Use **RDS security group** allowing inbound only from EKS node/pod security group\n\n---\n\n## End-to-end request flow\n1. User requests `https://app.example.com`.\n2. Route 53 resolves to the **ALB**.\n3. ALB terminates TLS (ACM cert) and forwards to **EKS Ingress** target group.\n4. Ingress routes to Kubernetes Service → Pods (Tomcat) across multiple AZs.\n5. Logs/metrics go to CloudWatch; images are pulled from ECR.\n\n---\n\n## Deployment strategy\n- **Blue/green or rolling updates** via Kubernetes Deployment strategy.\n- Tag images immutably (e.g., Git SHA) rather than `:latest`.\n- Use separate namespaces/environments (dev/stage/prod) and separate EKS node groups if needed.\n",
  "aws_resources": [
    "VPC",
    "VPC Subnets (Public)",
    "VPC Subnets (Private)",
    "Internet Gateway",
    "NAT Gateway(s)",
    "Route Tables (Public/Private)",
    "Security Groups (ALB, EKS nodes, Jenkins/CI)",
    "Network ACLs (optional)",
    "VPC Endpoints: S3 (Gateway)",
    "VPC Endpoints: ECR API (Interface)",
    "VPC Endpoints: ECR DKR (Interface)",
    "VPC Endpoints: CloudWatch Logs (Interface)",
    "VPC Endpoints: STS (Interface, optional)",
    "Amazon EKS Cluster",
    "EKS Managed Node Group(s) (EC2)",
    "EKS Add-on: CoreDNS",
    "EKS Add-on: kube-proxy",
    "EKS Add-on: VPC CNI",
    "IAM OIDC Provider for EKS (for IRSA)",
    "IAM Roles: EKS Cluster Role",
    "IAM Roles: EKS Node Instance Role",
    "IAM Roles for Service Accounts (IRSA) for controllers",
    "AWS Load Balancer Controller (deployed into EKS)",
    "Application Load Balancer (created/managed by controller)",
    "Target Groups (created/managed by controller)",
    "ACM Certificate (for HTTPS)",
    "Route 53 Hosted Zone + Record (A/AAAA alias to ALB)",
    "Amazon ECR Repository",
    "IAM Policy/Role for CI to push to ECR and deploy to EKS",
    "Secrets Manager (application secrets, CI secrets)",
    "KMS Key (for Secrets Manager and optional EKS secrets encryption)",
    "CloudWatch Log Groups (EKS/containers)",
    "CloudWatch Container Insights (optional)",
    "CloudWatch Alarms (ALB, node/pod health)",
    "CloudTrail (account audit logging)",
    "S3 Bucket (optional: store build artifacts, logs, or backups)",
    "EC2 Instance(s) for Jenkins (if keeping Jenkins)",
    "EBS Volumes (for Jenkins home, if on EC2)",
    "SSM (Systems Manager) Managed Instance configuration for EC2 (Jenkins/bastion)",
    "Bastion Host or AWS Client VPN (optional, for private admin access)"
  ]
}