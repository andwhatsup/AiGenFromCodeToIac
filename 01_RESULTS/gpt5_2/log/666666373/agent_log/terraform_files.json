{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \"~> 2.25\"\n    }\n    helm = {\n      source  = \"hashicorp/helm\"\n      version = \"~> 2.12\"\n    }\n    tls = {\n      source  = \"hashicorp/tls\"\n      version = \"~> 4.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n\n# These providers are configured after the EKS cluster exists.\n# They use the AWS CLI exec plugin to fetch a token.\nprovider \"kubernetes\" {\n  host                   = module.eks.cluster_endpoint\n  cluster_ca_certificate = base64decode(module.eks.cluster_certificate_authority_data)\n\n  exec {\n    api_version = \"client.authentication.k8s.io/v1beta1\"\n    command     = \"aws\"\n    args        = [\"eks\", \"get-token\", \"--cluster-name\", module.eks.cluster_name, \"--region\", var.aws_region]\n  }\n}\n\nprovider \"helm\" {\n  kubernetes {\n    host                   = module.eks.cluster_endpoint\n    cluster_ca_certificate = base64decode(module.eks.cluster_certificate_authority_data)\n\n    exec {\n      api_version = \"client.authentication.k8s.io/v1beta1\"\n      command     = \"aws\"\n      args        = [\"eks\", \"get-token\", \"--cluster-name\", module.eks.cluster_name, \"--region\", var.aws_region]\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Project/name prefix used for resources.\"\n  type        = string\n  default     = \"mvn-hello-world\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, stage, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"Public subnet CIDRs (one per AZ).\"\n  type        = list(string)\n  default     = [\"10.0.0.0/20\", \"10.0.16.0/20\"]\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"Private subnet CIDRs (one per AZ).\"\n  type        = list(string)\n  default     = [\"10.0.128.0/20\", \"10.0.144.0/20\"]\n}\n\nvariable \"eks_cluster_version\" {\n  description = \"EKS Kubernetes version.\"\n  type        = string\n  default     = \"1.29\"\n}\n\nvariable \"node_instance_types\" {\n  description = \"EKS managed node group instance types.\"\n  type        = list(string)\n  default     = [\"t3.medium\"]\n}\n\nvariable \"node_desired_size\" {\n  description = \"Desired number of worker nodes.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_min_size\" {\n  description = \"Minimum number of worker nodes.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_max_size\" {\n  description = \"Maximum number of worker nodes.\"\n  type        = number\n  default     = 4\n}\n\nvariable \"app_namespace\" {\n  description = \"Kubernetes namespace for the application.\"\n  type        = string\n  default     = \"app\"\n}\n\nvariable \"app_name\" {\n  description = \"Kubernetes app name.\"\n  type        = string\n  default     = \"tomcat-war\"\n}\n\nvariable \"app_image\" {\n  description = \"Container image to deploy (recommend ECR image URI with immutable tag).\"\n  type        = string\n  default     = \"public.ecr.aws/docker/library/tomcat:8.0\"\n}\n\nvariable \"app_replicas\" {\n  description = \"Number of pod replicas.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"app_container_port\" {\n  description = \"Container port exposed by Tomcat.\"\n  type        = number\n  default     = 8080\n}\n\nvariable \"domain_name\" {\n  description = \"Optional Route53/ACM domain name for HTTPS (e.g., app.example.com). Leave empty to skip ACM+Route53.\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"hosted_zone_id\" {\n  description = \"Optional Route53 hosted zone ID for domain_name. Required if domain_name is set.\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"enable_jenkins\" {\n  description = \"If true, provision a small Jenkins EC2 instance in private subnet (minimal/lean option).\"\n  type        = bool\n  default     = false\n}\n\nvariable \"jenkins_admin_cidr\" {\n  description = \"CIDR allowed to access Jenkins (if enabled). Typically your office/VPN public IP.\"\n  type        = string\n  default     = \"0.0.0.0/0\"\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  name = \"${var.project_name}-${var.environment}\"\n  azs  = slice(data.aws_availability_zones.available.names, 0, 2)\n}\n\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = local.name\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  public_subnets  = var.public_subnet_cidrs\n  private_subnets = var.private_subnet_cidrs\n\n  enable_nat_gateway = true\n  single_nat_gateway = true\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = \"1\"\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = \"1\"\n  }\n}\n\nresource \"aws_kms_key\" \"eks\" {\n  description             = \"KMS key for EKS secrets encryption\"\n  deletion_window_in_days = 7\n  enable_key_rotation     = true\n}\n\nresource \"aws_kms_alias\" \"eks\" {\n  name          = \"alias/${local.name}-eks\"\n  target_key_id = aws_kms_key.eks.key_id\n}\n\nmodule \"eks\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 20.0\"\n\n  cluster_name    = local.name\n  cluster_version = var.eks_cluster_version\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  cluster_endpoint_public_access  = true\n  cluster_endpoint_private_access = true\n\n  enable_cluster_creator_admin_permissions = true\n\n  cluster_encryption_config = {\n    resources        = [\"secrets\"]\n    provider_key_arn = aws_kms_key.eks.arn\n  }\n\n  eks_managed_node_groups = {\n    default = {\n      name            = \"default\"\n      instance_types  = var.node_instance_types\n      desired_size    = var.node_desired_size\n      min_size        = var.node_min_size\n      max_size        = var.node_max_size\n      subnet_ids      = module.vpc.private_subnets\n      capacity_type   = \"ON_DEMAND\"\n      ami_type        = \"AL2_x86_64\"\n      disk_size       = 20\n    }\n  }\n\n  cluster_addons = {\n    coredns    = {}\n    kube-proxy = {}\n    vpc-cni    = {}\n  }\n}\n\n# ECR repository for the application image (CI pushes here; EKS pulls from here)\nresource \"aws_ecr_repository\" \"app\" {\n  name                 = \"${local.name}/${var.app_name}\"\n  image_tag_mutability = \"IMMUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"app\" {\n  repository = aws_ecr_repository.app.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last 30 images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = 30\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "alb_controller.tf",
      "content": "# IAM role for AWS Load Balancer Controller (IRSA)\nmodule \"lb_controller_irsa\" {\n  source  = \"terraform-aws-modules/iam/aws//modules/iam-role-for-service-accounts-eks\"\n  version = \"~> 5.0\"\n\n  role_name                              = \"${local.name}-aws-load-balancer-controller\"\n  attach_load_balancer_controller_policy = true\n\n  oidc_providers = {\n    main = {\n      provider_arn               = module.eks.oidc_provider_arn\n      namespace_service_accounts = [\"kube-system:aws-load-balancer-controller\"]\n    }\n  }\n}\n\nresource \"kubernetes_service_account\" \"aws_load_balancer_controller\" {\n  metadata {\n    name      = \"aws-load-balancer-controller\"\n    namespace = \"kube-system\"\n    annotations = {\n      \"eks.amazonaws.com/role-arn\" = module.lb_controller_irsa.iam_role_arn\n    }\n    labels = {\n      \"app.kubernetes.io/name\" = \"aws-load-balancer-controller\"\n    }\n  }\n\n  automount_service_account_token = true\n}\n\nresource \"helm_release\" \"aws_load_balancer_controller\" {\n  name       = \"aws-load-balancer-controller\"\n  repository = \"https://aws.github.io/eks-charts\"\n  chart      = \"aws-load-balancer-controller\"\n  namespace  = \"kube-system\"\n\n  depends_on = [kubernetes_service_account.aws_load_balancer_controller]\n\n  set {\n    name  = \"clusterName\"\n    value = module.eks.cluster_name\n  }\n\n  set {\n    name  = \"serviceAccount.create\"\n    value = \"false\"\n  }\n\n  set {\n    name  = \"serviceAccount.name\"\n    value = kubernetes_service_account.aws_load_balancer_controller.metadata[0].name\n  }\n\n  set {\n    name  = \"region\"\n    value = var.aws_region\n  }\n\n  set {\n    name  = \"vpcId\"\n    value = module.vpc.vpc_id\n  }\n}\n"
    },
    {
      "name": "k8s_app.tf",
      "content": "resource \"kubernetes_namespace\" \"app\" {\n  metadata {\n    name = var.app_namespace\n    labels = {\n      \"app.kubernetes.io/part-of\" = var.project_name\n      \"environment\"              = var.environment\n    }\n  }\n}\n\nresource \"kubernetes_deployment\" \"app\" {\n  metadata {\n    name      = var.app_name\n    namespace = kubernetes_namespace.app.metadata[0].name\n    labels = {\n      app = var.app_name\n    }\n  }\n\n  spec {\n    replicas = var.app_replicas\n\n    selector {\n      match_labels = {\n        app = var.app_name\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = var.app_name\n        }\n      }\n\n      spec {\n        container {\n          name  = var.app_name\n          image = var.app_image\n\n          port {\n            name           = \"http\"\n            container_port = var.app_container_port\n          }\n\n          resources {\n            requests = {\n              cpu    = \"100m\"\n              memory = \"256Mi\"\n            }\n            limits = {\n              cpu    = \"500m\"\n              memory = \"512Mi\"\n            }\n          }\n\n          liveness_probe {\n            http_get {\n              path = \"/\"\n              port = var.app_container_port\n            }\n            initial_delay_seconds = 30\n            period_seconds        = 10\n          }\n\n          readiness_probe {\n            http_get {\n              path = \"/\"\n              port = var.app_container_port\n            }\n            initial_delay_seconds = 10\n            period_seconds        = 10\n          }\n        }\n      }\n    }\n  }\n}\n\nresource \"kubernetes_service\" \"app\" {\n  metadata {\n    name      = var.app_name\n    namespace = kubernetes_namespace.app.metadata[0].name\n    labels = {\n      app = var.app_name\n    }\n  }\n\n  spec {\n    selector = {\n      app = var.app_name\n    }\n\n    port {\n      name        = \"http\"\n      port        = 80\n      target_port = var.app_container_port\n      protocol    = \"TCP\"\n    }\n\n    type = \"ClusterIP\"\n  }\n}\n\n# Ingress backed by AWS Load Balancer Controller (ALB)\nresource \"kubernetes_ingress_v1\" \"app\" {\n  metadata {\n    name      = \"${var.app_name}-ingress\"\n    namespace = kubernetes_namespace.app.metadata[0].name\n\n    annotations = merge(\n      {\n        \"kubernetes.io/ingress.class\"                = \"alb\"\n        \"alb.ingress.kubernetes.io/scheme\"           = \"internet-facing\"\n        \"alb.ingress.kubernetes.io/target-type\"      = \"ip\"\n        \"alb.ingress.kubernetes.io/listen-ports\"     = jsonencode([{ HTTP = 80 }])\n        \"alb.ingress.kubernetes.io/healthcheck-path\" = \"/\"\n      },\n      var.domain_name != \"\" ? {\n        \"alb.ingress.kubernetes.io/listen-ports\" = jsonencode([{ HTTPS = 443 }])\n        \"alb.ingress.kubernetes.io/ssl-redirect\" = \"443\"\n        \"alb.ingress.kubernetes.io/certificate-arn\" = aws_acm_certificate_validation.this[0].certificate_arn\n      } : {}\n    )\n  }\n\n  spec {\n    rule {\n      http {\n        path {\n          path      = \"/\"\n          path_type = \"Prefix\"\n\n          backend {\n            service {\n              name = kubernetes_service.app.metadata[0].name\n              port {\n                number = 80\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  depends_on = [helm_release.aws_load_balancer_controller]\n}\n"
    },
    {
      "name": "acm_route53.tf",
      "content": "# Optional: ACM + Route53 for HTTPS.\n# If var.domain_name is empty, these resources are not created.\n\nresource \"aws_acm_certificate\" \"this\" {\n  count = var.domain_name != \"\" ? 1 : 0\n\n  domain_name       = var.domain_name\n  validation_method = \"DNS\"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_route53_record\" \"acm_validation\" {\n  count = var.domain_name != \"\" ? 1 : 0\n\n  zone_id = var.hosted_zone_id\n  name    = tolist(aws_acm_certificate.this[0].domain_validation_options)[0].resource_record_name\n  type    = tolist(aws_acm_certificate.this[0].domain_validation_options)[0].resource_record_type\n  records = [tolist(aws_acm_certificate.this[0].domain_validation_options)[0].resource_record_value]\n  ttl     = 60\n}\n\nresource \"aws_acm_certificate_validation\" \"this\" {\n  count = var.domain_name != \"\" ? 1 : 0\n\n  certificate_arn         = aws_acm_certificate.this[0].arn\n  validation_record_fqdns = [aws_route53_record.acm_validation[0].fqdn]\n}\n"
    },
    {
      "name": "jenkins.tf",
      "content": "# Optional Jenkins on EC2 (lean option). Disabled by default.\n\ndata \"aws_ami\" \"al2023\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n\n  filter {\n    name   = \"name\"\n    values = [\"al2023-ami-*-x86_64\"]\n  }\n}\n\nresource \"aws_security_group\" \"jenkins\" {\n  count       = var.enable_jenkins ? 1 : 0\n  name_prefix = \"${local.name}-jenkins-\"\n  description = \"Jenkins security group\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description = \"Jenkins UI\"\n    from_port   = 8080\n    to_port     = 8080\n    protocol    = \"tcp\"\n    cidr_blocks = [var.jenkins_admin_cidr]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_iam_role\" \"jenkins\" {\n  count = var.enable_jenkins ? 1 : 0\n  name  = \"${local.name}-jenkins\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"jenkins\" {\n  count = var.enable_jenkins ? 1 : 0\n  name  = \"${local.name}-jenkins-inline\"\n  role  = aws_iam_role.jenkins[0].id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"ECRPushPull\"\n        Effect = \"Allow\"\n        Action = [\n          \"ecr:GetAuthorizationToken\",\n          \"ecr:BatchCheckLayerAvailability\",\n          \"ecr:CompleteLayerUpload\",\n          \"ecr:InitiateLayerUpload\",\n          \"ecr:PutImage\",\n          \"ecr:UploadLayerPart\",\n          \"ecr:BatchGetImage\",\n          \"ecr:GetDownloadUrlForLayer\"\n        ]\n        Resource = \"*\"\n      },\n      {\n        Sid    = \"EKSDescribe\"\n        Effect = \"Allow\"\n        Action = [\n          \"eks:DescribeCluster\"\n        ]\n        Resource = module.eks.cluster_arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_instance_profile\" \"jenkins\" {\n  count = var.enable_jenkins ? 1 : 0\n  name  = \"${local.name}-jenkins\"\n  role  = aws_iam_role.jenkins[0].name\n}\n\nresource \"aws_instance\" \"jenkins\" {\n  count = var.enable_jenkins ? 1 : 0\n\n  ami                    = data.aws_ami.al2023.id\n  instance_type          = \"t3.small\"\n  subnet_id              = module.vpc.private_subnets[0]\n  vpc_security_group_ids  = [aws_security_group.jenkins[0].id]\n  iam_instance_profile    = aws_iam_instance_profile.jenkins[0].name\n  associate_public_ip_address = false\n\n  user_data = <<-EOF\n              #!/bin/bash\n              set -euxo pipefail\n              dnf update -y\n              dnf install -y java-17-amazon-corretto-headless git docker\n              systemctl enable --now docker\n              # Jenkins install (simple repo-based install)\n              curl -fsSL https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key | tee /etc/pki/rpm-gpg/jenkins.io.key\n              curl -fsSL https://pkg.jenkins.io/redhat-stable/jenkins.repo | tee /etc/yum.repos.d/jenkins.repo\n              dnf install -y jenkins\n              systemctl enable --now jenkins\n              EOF\n\n  tags = {\n    Name = \"${local.name}-jenkins\"\n  }\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value = module.vpc.vpc_id\n}\n\noutput \"eks_cluster_name\" {\n  value = module.eks.cluster_name\n}\n\noutput \"eks_cluster_endpoint\" {\n  value = module.eks.cluster_endpoint\n}\n\noutput \"ecr_repository_url\" {\n  description = \"ECR repository URL to push your application image to.\"\n  value       = aws_ecr_repository.app.repository_url\n}\n\noutput \"app_ingress_hostname\" {\n  description = \"ALB DNS name created by the AWS Load Balancer Controller (available after apply).\"\n  value       = try(kubernetes_ingress_v1.app.status[0].load_balancer[0].ingress[0].hostname, null)\n}\n\noutput \"jenkins_private_ip\" {\n  value       = try(aws_instance.jenkins[0].private_ip, null)\n  description = \"Private IP of Jenkins instance (if enabled).\"\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "project_name = \"mvn-hello-world\"\nenvironment  = \"dev\"\naws_region   = \"us-east-1\"\n\n# Set to your built image (prefer immutable tag) after pushing to ECR.\n# Example:\n# app_image = \"123456789012.dkr.ecr.us-east-1.amazonaws.com/mvn-hello-world-dev/tomcat-war:sha-<gitsha>\"\n\napp_name  = \"tomcat-war\"\napp_image = \"public.ecr.aws/docker/library/tomcat:8.0\"\n\n# Optional HTTPS (requires a public hosted zone in Route53)\n# domain_name    = \"app.example.com\"\n# hosted_zone_id = \"Z123456ABCDEFG\"\n\nenable_jenkins = false\n# jenkins_admin_cidr = \"203.0.113.10/32\"\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform: EKS + ALB Ingress + ECR (Java WAR on Tomcat)\n\nThis Terraform creates:\n- VPC (2 AZs, public+private subnets, 1 NAT)\n- EKS cluster + managed node group\n- ECR repository for the app image\n- AWS Load Balancer Controller (IRSA) and an example app Deployment/Service/Ingress\n- Optional ACM certificate (DNS validation) for HTTPS\n- Optional Jenkins EC2 instance (disabled by default)\n\n## Deploy\n```bash\ncd ai_tf\nterraform init\nterraform validate\nterraform plan\nterraform apply\n```\n\nAfter apply, push your image to the output `ecr_repository_url` and set `app_image` accordingly.\n"
    }
  ]
}