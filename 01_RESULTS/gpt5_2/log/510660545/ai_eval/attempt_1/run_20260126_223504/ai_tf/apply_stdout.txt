data.aws_caller_identity.current: Reading...
data.aws_caller_identity.current: Read complete after 0s [id=000000000000]

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create
 <= read (data resources)

Terraform will perform the following actions:

  # data.aws_iam_policy_document.cloudtrail_bucket will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "cloudtrail_bucket" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions   = [
              + "s3:GetBucketAcl",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "AWSCloudTrailAclCheck"

          + principals {
              + identifiers = [
                  + "cloudtrail.amazonaws.com",
                ]
              + type        = "Service"
            }
        }
      + statement {
          + actions   = [
              + "s3:PutObject",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "AWSCloudTrailWrite"

          + condition {
              + test     = "StringEquals"
              + values   = [
                  + "bucket-owner-full-control",
                ]
              + variable = "s3:x-amz-acl"
            }

          + principals {
              + identifiers = [
                  + "cloudtrail.amazonaws.com",
                ]
              + type        = "Service"
            }
        }
      + statement {
          + actions   = [
              + "s3:*",
            ]
          + effect    = "Deny"
          + resources = [
              + (known after apply),
              + (known after apply),
            ]
          + sid       = "DenyInsecureTransport"

          + condition {
              + test     = "Bool"
              + values   = [
                  + "false",
                ]
              + variable = "aws:SecureTransport"
            }

          + principals {
              + identifiers = [
                  + "*",
                ]
              + type        = "*"
            }
        }
    }

  # data.aws_iam_policy_document.github_assume_apply will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "github_assume_apply" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions = [
              + "sts:AssumeRoleWithWebIdentity",
            ]
          + effect  = "Allow"

          + condition {
              + test     = "StringEquals"
              + values   = [
                  + "sts.amazonaws.com",
                ]
              + variable = "token.actions.githubusercontent.com:aud"
            }
          + condition {
              + test     = "StringLike"
              + values   = [
                  + "repo:ai-tf/ai-tf:ref:refs/heads/main",
                ]
              + variable = "token.actions.githubusercontent.com:sub"
            }

          + principals {
              + identifiers = [
                  + (known after apply),
                ]
              + type        = "Federated"
            }
        }
    }

  # data.aws_iam_policy_document.github_assume_plan will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "github_assume_plan" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions = [
              + "sts:AssumeRoleWithWebIdentity",
            ]
          + effect  = "Allow"

          + condition {
              + test     = "StringEquals"
              + values   = [
                  + "sts.amazonaws.com",
                ]
              + variable = "token.actions.githubusercontent.com:aud"
            }
          + condition {
              + test     = "StringLike"
              + values   = [
                  + "repo:ai-tf/ai-tf:*",
                ]
              + variable = "token.actions.githubusercontent.com:sub"
            }

          + principals {
              + identifiers = [
                  + (known after apply),
                ]
              + type        = "Federated"
            }
        }
    }

  # data.aws_iam_policy_document.kms_tfstate will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "kms_tfstate" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions   = [
              + "kms:*",
            ]
          + effect    = "Allow"
          + resources = [
              + "*",
            ]
          + sid       = "EnableRootPermissions"

          + principals {
              + identifiers = [
                  + "arn:aws:iam::000000000000:root",
                ]
              + type        = "AWS"
            }
        }
      + statement {
          + actions   = [
              + "kms:Decrypt",
              + "kms:DescribeKey",
              + "kms:Encrypt",
              + "kms:GenerateDataKey*",
              + "kms:ReEncrypt*",
            ]
          + effect    = "Allow"
          + resources = [
              + "*",
            ]
          + sid       = "AllowGitHubRolesUseKey"

          + principals {
              + identifiers = [
                  + (known after apply),
                  + (known after apply),
                ]
              + type        = "AWS"
            }
        }
    }

  # data.aws_iam_policy_document.terraform_state_access will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "terraform_state_access" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions   = [
              + "s3:GetBucketLocation",
              + "s3:ListBucket",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "ListStateBucket"
        }
      + statement {
          + actions   = [
              + "s3:AbortMultipartUpload",
              + "s3:DeleteObject",
              + "s3:GetObject",
              + "s3:GetObjectVersion",
              + "s3:ListBucketMultipartUploads",
              + "s3:ListMultipartUploadParts",
              + "s3:PutObject",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "StateObjectRW"
        }
      + statement {
          + actions   = [
              + "dynamodb:DeleteItem",
              + "dynamodb:DescribeTable",
              + "dynamodb:GetItem",
              + "dynamodb:PutItem",
              + "dynamodb:UpdateItem",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "DynamoDBLocking"
        }
      + statement {
          + actions   = [
              + "kms:Decrypt",
              + "kms:DescribeKey",
              + "kms:Encrypt",
              + "kms:GenerateDataKey*",
              + "kms:ReEncrypt*",
            ]
          + effect    = "Allow"
          + resources = [
              + (known after apply),
            ]
          + sid       = "KMSForState"
        }
    }

  # data.aws_iam_policy_document.tfstate_bucket will be read during apply
  # (config refers to values not yet known)
 <= data "aws_iam_policy_document" "tfstate_bucket" {
      + id            = (known after apply)
      + json          = (known after apply)
      + minified_json = (known after apply)

      + statement {
          + actions   = [
              + "s3:*",
            ]
          + effect    = "Deny"
          + resources = [
              + (known after apply),
              + (known after apply),
            ]
          + sid       = "DenyInsecureTransport"

          + condition {
              + test     = "Bool"
              + values   = [
                  + "false",
                ]
              + variable = "aws:SecureTransport"
            }

          + principals {
              + identifiers = [
                  + "*",
                ]
              + type        = "*"
            }
        }
    }

  # aws_cloudtrail.main will be created
  + resource "aws_cloudtrail" "main" {
      + arn                           = (known after apply)
      + enable_log_file_validation    = false
      + enable_logging                = true
      + home_region                   = (known after apply)
      + id                            = (known after apply)
      + include_global_service_events = true
      + is_multi_region_trail         = true
      + is_organization_trail         = false
      + name                          = "iac-platform-dev-cloudtrail"
      + s3_bucket_name                = (known after apply)
      + sns_topic_arn                 = (known after apply)
      + tags_all                      = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }

      + event_selector {
          + include_management_events = true
          + read_write_type           = "All"
        }
    }

  # aws_dynamodb_table.terraform_locks will be created
  + resource "aws_dynamodb_table" "terraform_locks" {
      + arn              = (known after apply)
      + billing_mode     = "PAY_PER_REQUEST"
      + hash_key         = "LockID"
      + id               = (known after apply)
      + name             = "terraform-locks"
      + read_capacity    = (known after apply)
      + stream_arn       = (known after apply)
      + stream_label     = (known after apply)
      + stream_view_type = (known after apply)
      + tags_all         = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + write_capacity   = (known after apply)

      + attribute {
          + name = "LockID"
          + type = "S"
        }

      + point_in_time_recovery {
          + enabled                 = true
          + recovery_period_in_days = (known after apply)
        }

      + server_side_encryption (known after apply)

      + ttl (known after apply)
    }

  # aws_iam_openid_connect_provider.github will be created
  + resource "aws_iam_openid_connect_provider" "github" {
      + arn             = (known after apply)
      + client_id_list  = [
          + "sts.amazonaws.com",
        ]
      + id              = (known after apply)
      + tags_all        = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + thumbprint_list = [
          + "6938fd4d98bab03faadb97b34396831e3780aea1",
        ]
      + url             = "https://token.actions.githubusercontent.com"
    }

  # aws_iam_policy.terraform_state_access will be created
  + resource "aws_iam_policy" "terraform_state_access" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + id               = (known after apply)
      + name             = "iac-platform-dev-terraform-state-access"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = (known after apply)
      + policy_id        = (known after apply)
      + tags_all         = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
    }

  # aws_iam_role.terraform_apply will be created
  + resource "aws_iam_role" "terraform_apply" {
      + arn                   = (known after apply)
      + assume_role_policy    = (known after apply)
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "terraform-apply-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role.terraform_plan will be created
  + resource "aws_iam_role" "terraform_plan" {
      + arn                   = (known after apply)
      + assume_role_policy    = (known after apply)
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "terraform-plan-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # aws_iam_role_policy_attachment.apply_state will be created
  + resource "aws_iam_role_policy_attachment" "apply_state" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = "terraform-apply-role"
    }

  # aws_iam_role_policy_attachment.plan_state will be created
  + resource "aws_iam_role_policy_attachment" "plan_state" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = "terraform-plan-role"
    }

  # aws_kms_alias.tfstate will be created
  + resource "aws_kms_alias" "tfstate" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + name           = "alias/iac-platform-dev-tfstate"
      + name_prefix    = (known after apply)
      + target_key_arn = (known after apply)
      + target_key_id  = (known after apply)
    }

  # aws_kms_key.tfstate will be created
  + resource "aws_kms_key" "tfstate" {
      + arn                                = (known after apply)
      + bypass_policy_lockout_safety_check = false
      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"
      + deletion_window_in_days            = 30
      + description                        = "KMS key for Terraform remote state encryption (S3 SSE-KMS)"
      + enable_key_rotation                = true
      + id                                 = (known after apply)
      + is_enabled                         = true
      + key_id                             = (known after apply)
      + key_usage                          = "ENCRYPT_DECRYPT"
      + multi_region                       = (known after apply)
      + policy                             = (known after apply)
      + rotation_period_in_days            = (known after apply)
      + tags_all                           = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
    }

  # aws_s3_bucket.cloudtrail_logs will be created
  + resource "aws_s3_bucket" "cloudtrail_logs" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "iac-platform-dev-cloudtrail-logs-000000000000"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket.tfstate will be created
  + resource "aws_s3_bucket" "tfstate" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "ai-tf"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = {
          + "Env"       = "dev"
          + "ManagedBy" = "Terraform"
          + "Project"   = "iac-platform"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # aws_s3_bucket_ownership_controls.cloudtrail_logs will be created
  + resource "aws_s3_bucket_ownership_controls" "cloudtrail_logs" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + object_ownership = "BucketOwnerEnforced"
        }
    }

  # aws_s3_bucket_ownership_controls.tfstate will be created
  + resource "aws_s3_bucket_ownership_controls" "tfstate" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + object_ownership = "BucketOwnerEnforced"
        }
    }

  # aws_s3_bucket_policy.cloudtrail_logs will be created
  + resource "aws_s3_bucket_policy" "cloudtrail_logs" {
      + bucket = (known after apply)
      + id     = (known after apply)
      + policy = (known after apply)
    }

  # aws_s3_bucket_policy.tfstate will be created
  + resource "aws_s3_bucket_policy" "tfstate" {
      + bucket = (known after apply)
      + id     = (known after apply)
      + policy = (known after apply)
    }

  # aws_s3_bucket_public_access_block.cloudtrail_logs will be created
  + resource "aws_s3_bucket_public_access_block" "cloudtrail_logs" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # aws_s3_bucket_public_access_block.tfstate will be created
  + resource "aws_s3_bucket_public_access_block" "tfstate" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # aws_s3_bucket_server_side_encryption_configuration.cloudtrail_logs will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "cloudtrail_logs" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + sse_algorithm     = "AES256"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # aws_s3_bucket_server_side_encryption_configuration.tfstate will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "tfstate" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + kms_master_key_id = (known after apply)
              + sse_algorithm     = "aws:kms"
            }
        }
    }

  # aws_s3_bucket_versioning.cloudtrail_logs will be created
  + resource "aws_s3_bucket_versioning" "cloudtrail_logs" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

  # aws_s3_bucket_versioning.tfstate will be created
  + resource "aws_s3_bucket_versioning" "tfstate" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

Plan: 22 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + cloudtrail_s3_bucket_name = (known after apply)
  + github_oidc_provider_arn  = (known after apply)
  + terraform_apply_role_arn  = (known after apply)
  + terraform_lock_table_name = "terraform-locks"
  + terraform_plan_role_arn   = (known after apply)
  + tfstate_bucket_arn        = (known after apply)
  + tfstate_bucket_name       = (known after apply)
  + tfstate_kms_key_arn       = (known after apply)
aws_iam_openid_connect_provider.github: Creating...
aws_dynamodb_table.terraform_locks: Creating...
aws_s3_bucket.tfstate: Creating...
aws_s3_bucket.cloudtrail_logs: Creating...
aws_iam_openid_connect_provider.github: Creation complete after 0s [id=arn:aws:iam::000000000000:oidc-provider/token.actions.githubusercontent.com]
data.aws_iam_policy_document.github_assume_apply: Reading...
data.aws_iam_policy_document.github_assume_plan: Reading...
data.aws_iam_policy_document.github_assume_apply: Read complete after 0s [id=83662662]
data.aws_iam_policy_document.github_assume_plan: Read complete after 0s [id=2204798064]
aws_iam_role.terraform_plan: Creating...
aws_iam_role.terraform_apply: Creating...
aws_iam_role.terraform_apply: Creation complete after 0s [id=terraform-apply-role]
aws_iam_role.terraform_plan: Creation complete after 0s [id=terraform-plan-role]
data.aws_iam_policy_document.kms_tfstate: Reading...
data.aws_iam_policy_document.kms_tfstate: Read complete after 0s [id=673946018]
aws_kms_key.tfstate: Creating...
aws_dynamodb_table.terraform_locks: Creation complete after 1s [id=terraform-locks]
aws_s3_bucket.tfstate: Still creating... [00m10s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [00m10s elapsed]
aws_kms_key.tfstate: Still creating... [00m10s elapsed]
aws_kms_key.tfstate: Creation complete after 12s [id=931c7f01-1ef4-4965-8a37-cbc134569955]
aws_kms_alias.tfstate: Creating...
aws_kms_alias.tfstate: Creation complete after 0s [id=alias/iac-platform-dev-tfstate]
aws_s3_bucket.cloudtrail_logs: Still creating... [00m20s elapsed]
aws_s3_bucket.tfstate: Still creating... [00m20s elapsed]
aws_s3_bucket.tfstate: Still creating... [00m30s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [00m30s elapsed]
aws_s3_bucket.tfstate: Still creating... [00m40s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [00m40s elapsed]
aws_s3_bucket.tfstate: Still creating... [00m50s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [00m50s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m00s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m00s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m10s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m10s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m20s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m20s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m30s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m30s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m40s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m40s elapsed]
aws_s3_bucket.tfstate: Still creating... [01m50s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [01m50s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m00s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m00s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m10s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m10s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m20s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m20s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m30s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m30s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m40s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m40s elapsed]
aws_s3_bucket.tfstate: Still creating... [02m50s elapsed]
aws_s3_bucket.cloudtrail_logs: Still creating... [02m50s elapsed]
