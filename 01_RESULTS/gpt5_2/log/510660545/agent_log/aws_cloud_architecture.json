{
  "aws_architecture_description": "## Proposed high-level AWS architecture (for this multi-cloud IaC delivery system)\n\nThis repository is primarily an **IaC delivery platform** (Terraform/Terragrunt executed from GitHub Actions). On AWS, the “system” you need to deploy is mainly:\n1) a **secure Terraform remote state backend**,\n2) **AWS IAM + security controls** that allow GitHub Actions (and optionally developers) to run Terraform safely,\n3) **audit/monitoring** around those actions.\n\n### 1) Identity & access: GitHub Actions → AWS (recommended: OIDC, no long‑lived keys)\n- Configure an **IAM OIDC identity provider** for `token.actions.githubusercontent.com`.\n- Create one or more **IAM roles** that GitHub Actions can assume via OIDC:\n  - A **read-only “plan” role** (used on PRs) with permissions to read state and describe AWS resources.\n  - A **write “apply” role** (used on protected branches/environments) with permissions to create/update AWS resources defined by Terraform.\n- Use **least privilege**:\n  - Scope S3 access to the specific state bucket/prefix.\n  - Scope DynamoDB access to the specific lock table.\n  - Scope AWS service permissions to only what your Terraform modules actually manage (start broad initially, then tighten).\n- Add **permission boundaries** (optional but strong best practice) to prevent privilege escalation by Terraform.\n\n### 2) Terraform remote state backend on AWS\n- Provision a dedicated **S3 bucket** (e.g., `<aws_profile>-terraform-state`) to store Terraform state.\n- Enable:\n  - **S3 versioning** (protects against accidental overwrites/deletes).\n  - **SSE-KMS encryption** using a customer-managed **KMS key**.\n  - **Block Public Access** and a bucket policy that denies non-TLS (`aws:SecureTransport=false`).\n  - (Optional) **Object Lock** for WORM-style protection if you have compliance needs.\n- Provision a **DynamoDB table** (e.g., `terraform-locks`) for state locking.\n  - Use on-demand capacity unless you have predictable high throughput.\n\n### 3) Environment separation & governance\n- Use separate AWS accounts (or at least separate state prefixes and roles) for **dev/stage/prod**.\n- Use **AWS Organizations** (if available) with:\n  - Centralized guardrails via **SCPs**.\n  - Centralized logging account (CloudTrail, Config) if you operate multiple accounts.\n- Use **tagging standards** enforced via Terraform/Terragrunt (cost allocation, ownership, environment).\n\n### 4) Audit, detection, and operational visibility\n- Enable **AWS CloudTrail** (management events at minimum) to record all API activity performed by Terraform.\n  - Deliver logs to a dedicated **S3 log bucket**.\n  - (Optional) Send to **CloudWatch Logs** for alerting.\n- Enable **AWS Config** (optional but recommended for governance) to track configuration drift and compliance.\n- Use **CloudWatch Alarms** (or EventBridge rules) for high-signal events:\n  - IAM policy/role changes\n  - KMS key policy changes\n  - S3 bucket policy/public access changes\n  - CloudTrail disabled events\n\n### 5) Container image for tooling (where it lives)\nYour repo builds a `cloud-tools` Docker image in GitHub Actions. On AWS you have two lean options:\n- **Option A (leanest): keep using GitHub Container Registry (GHCR)** and do not add AWS container registry.\n- **Option B (AWS-native): store the image in Amazon ECR**\n  - GitHub Actions authenticates to ECR (again via OIDC) and pushes the image.\n  - This is useful if later you run the same tooling in AWS (CodeBuild, ECS tasks, etc.).\n\nGiven your current architecture diagram, **Option A is sufficient** unless you have a requirement to keep artifacts in AWS.\n\n### 6) (Optional) Run Terraform from AWS instead of GitHub-hosted runners\nIf you later want to avoid GitHub-hosted runners and run everything inside AWS:\n- Use **AWS CodeBuild** (or ECS Fargate) to run the `cloud-tools` container.\n- Trigger via GitHub webhooks/CodePipeline.\n\nThis is optional; your current design works well with GitHub Actions + OIDC.\n\n---\n\n## Deployment strategy (AWS side)\n1. Bootstrap AWS “platform” resources once (state bucket, lock table, KMS key, IAM OIDC provider, IAM roles).\n2. Update GitHub Actions workflows to assume the correct role per environment (plan/apply separation).\n3. Enforce protected environments/branches in GitHub so only approved workflows can assume the apply role.\n4. Iterate on least-privilege IAM as Terraform modules become clearer.\n",
  "aws_resources": [
    "AWS Organizations (optional, if multi-account governance is desired)",
    "AWS IAM OIDC Identity Provider (token.actions.githubusercontent.com)",
    "AWS IAM Roles for GitHub Actions (e.g., terraform-plan-role, terraform-apply-role)",
    "AWS IAM Policies (least-privilege for S3 state, DynamoDB locks, and managed AWS services)",
    "IAM Permission Boundary Policy (optional but recommended)",
    "Amazon S3 Bucket for Terraform remote state (<profile>-terraform-state)",
    "S3 Bucket Versioning configuration",
    "S3 Bucket Public Access Block configuration",
    "S3 Bucket Policy (deny non-TLS, restrict principals, restrict prefixes)",
    "AWS KMS Key for S3 state encryption (SSE-KMS)",
    "AWS KMS Alias for the state key",
    "Amazon DynamoDB Table for Terraform state locking (terraform-locks)",
    "AWS CloudTrail Trail",
    "CloudTrail S3 Log Bucket (separate from tfstate bucket)",
    "CloudWatch Logs Log Group for CloudTrail (optional)",
    "Amazon EventBridge Rules for security-relevant events (optional)",
    "Amazon SNS Topic for alerts/notifications (optional)",
    "AWS Config Recorder + Delivery Channel (optional)",
    "Amazon ECR Repository for cloud-tools image (optional; only if you want AWS-native image storage)"
  ]
}