{
  "files": [
    {
      "name": "provider.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = var.tags\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"name\" {\n  description = \"Base name/prefix for resources.\"\n  type        = string\n  default     = \"playwright-runner\"\n}\n\nvariable \"tags\" {\n  description = \"Tags applied to all supported resources.\"\n  type        = map(string)\n  default = {\n    Project = \"playwright-lambda\"\n    Managed = \"terraform\"\n  }\n}\n\nvariable \"ecr_image_tag\" {\n  description = \"Container image tag in ECR to deploy (e.g., git SHA).\"\n  type        = string\n  default     = \"latest\"\n}\n\nvariable \"lambda_timeout\" {\n  description = \"Lambda timeout in seconds. Playwright/Chromium often needs higher timeouts.\"\n  type        = number\n  default     = 60\n}\n\nvariable \"lambda_memory_size\" {\n  description = \"Lambda memory in MB. Higher memory gives more CPU which helps Chromium startup.\"\n  type        = number\n  default     = 2048\n}\n\nvariable \"lambda_ephemeral_storage\" {\n  description = \"Ephemeral storage (/tmp) in MB. Increase if you store traces/screenshots.\"\n  type        = number\n  default     = 1024\n}\n\nvariable \"lambda_reserved_concurrency\" {\n  description = \"Optional reserved concurrency limit. Set null for unreserved.\"\n  type        = number\n  default     = null\n}\n\nvariable \"create_http_api\" {\n  description = \"Whether to create an API Gateway HTTP API endpoint to invoke the Lambda.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"http_api_stage_name\" {\n  description = \"Stage name for the HTTP API.\"\n  type        = string\n  default     = \"$default\"\n}\n\nvariable \"log_retention_days\" {\n  description = \"CloudWatch log retention in days.\"\n  type        = number\n  default     = 14\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\nlocals {\n  ecr_repo_name = var.name\n  lambda_name   = var.name\n}\n\nresource \"aws_ecr_repository\" \"this\" {\n  name                 = local.ecr_repo_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"this\" {\n  repository = aws_ecr_repository.this.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last 30 images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = 30\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"${var.name}-lambda-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_basic\" {\n  role       = aws_iam_role.lambda_exec.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_cloudwatch_log_group\" \"lambda\" {\n  name              = \"/aws/lambda/${local.lambda_name}\"\n  retention_in_days = var.log_retention_days\n}\n\nresource \"aws_lambda_function\" \"this\" {\n  function_name = local.lambda_name\n  role          = aws_iam_role.lambda_exec.arn\n  package_type  = \"Image\"\n\n  image_uri = \"${aws_ecr_repository.this.repository_url}:${var.ecr_image_tag}\"\n\n  timeout     = var.lambda_timeout\n  memory_size = var.lambda_memory_size\n\n  ephemeral_storage {\n    size = var.lambda_ephemeral_storage\n  }\n\n  reserved_concurrent_executions = var.lambda_reserved_concurrency\n\n  environment {\n    variables = {\n      NODE_OPTIONS = \"--enable-source-maps\"\n    }\n  }\n\n  depends_on = [\n    aws_cloudwatch_log_group.lambda\n  ]\n}\n\n# Optional: API Gateway HTTP API to invoke the Lambda\nresource \"aws_apigatewayv2_api\" \"http\" {\n  count         = var.create_http_api ? 1 : 0\n  name          = \"${var.name}-http-api\"\n  protocol_type = \"HTTP\"\n}\n\nresource \"aws_apigatewayv2_integration\" \"lambda\" {\n  count                  = var.create_http_api ? 1 : 0\n  api_id                 = aws_apigatewayv2_api.http[0].id\n  integration_type       = \"AWS_PROXY\"\n  integration_uri        = aws_lambda_function.this.arn\n  payload_format_version = \"2.0\"\n}\n\nresource \"aws_apigatewayv2_route\" \"invoke\" {\n  count     = var.create_http_api ? 1 : 0\n  api_id    = aws_apigatewayv2_api.http[0].id\n  route_key = \"POST /invoke\"\n  target    = \"integrations/${aws_apigatewayv2_integration.lambda[0].id}\"\n}\n\nresource \"aws_apigatewayv2_stage\" \"default\" {\n  count       = var.create_http_api ? 1 : 0\n  api_id      = aws_apigatewayv2_api.http[0].id\n  name        = var.http_api_stage_name\n  auto_deploy = true\n}\n\nresource \"aws_lambda_permission\" \"apigw\" {\n  count         = var.create_http_api ? 1 : 0\n  statement_id  = \"AllowExecutionFromAPIGateway\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.this.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_apigatewayv2_api.http[0].execution_arn}/*/*\"\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"ecr_repository_url\" {\n  description = \"ECR repository URL (use this to docker tag/push).\"\n  value       = aws_ecr_repository.this.repository_url\n}\n\noutput \"lambda_function_name\" {\n  description = \"Lambda function name.\"\n  value       = aws_lambda_function.this.function_name\n}\n\noutput \"lambda_function_arn\" {\n  description = \"Lambda function ARN.\"\n  value       = aws_lambda_function.this.arn\n}\n\noutput \"http_api_endpoint\" {\n  description = \"HTTP API endpoint (if created).\"\n  value       = var.create_http_api ? aws_apigatewayv2_api.http[0].api_endpoint : null\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region = \"us-east-1\"\n\n# Set to the image tag you pushed to ECR (e.g., git SHA). Default is \"latest\".\necr_image_tag = \"latest\"\n\n# create_http_api = true\n# http_api_stage_name = \"$default\"\n"
    },
    {
      "name": "README.md",
      "content": "## Terraform - Serverless Playwright Runner (Lambda container)\n\n### What this provisions\n- ECR repository (scan on push + lifecycle policy)\n- Lambda function using an ECR image (`package_type = Image`)\n- IAM execution role with basic CloudWatch Logs permissions\n- CloudWatch Log Group with retention\n- (Optional) API Gateway HTTP API `POST /invoke` -> Lambda\n\n### Deploy flow\n1. `terraform init`\n2. `terraform apply`\n3. Build & push your container image to the created ECR repo URL (see output `ecr_repository_url`).\n4. Update `ecr_image_tag` (or keep `latest`) and re-apply to point Lambda at the new image.\n\n### Notes\n- This configuration intentionally does **not** attach the Lambda to a VPC (simplest way to allow outbound internet access without NAT).\n- If you need static egress IPs or VPC-only access, add VPC + private subnets + NAT and attach the Lambda.\n"
    }
  ]
}