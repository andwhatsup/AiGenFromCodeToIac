{
  "aws_architecture_description": "## Proposed high-level AWS architecture (Serverless Playwright Runner on Lambda Container)\n\n### 1) Container build + artifact storage\n- **Amazon ECR** hosts the Lambda container image built from your `Dockerfile` (Node.js + Playwright + bundled Chromium).\n- A CI/CD pipeline (or your Makefile from a build host) builds the image and pushes it to ECR.\n- Enable **ECR image scanning** and lifecycle policies to keep the repo lean.\n\n### 2) Serverless execution\n- **AWS Lambda (container image)** runs a single function (`index.handler`).\n- The function receives an invocation payload containing `event.url`, launches headless Chromium via Playwright, navigates to the URL, and returns results.\n- Configure Lambda for browser automation realities:\n  - **Memory/CPU**: allocate higher memory (which also increases CPU) to reduce Chromium startup time.\n  - **Timeout**: set to a value that matches worst-case page loads.\n  - **Ephemeral storage**: increase `/tmp` if you write downloads, traces, screenshots, or browser profiles.\n  - **Reserved concurrency** (optional): cap concurrency to protect target sites and control cost.\n\n### 3) Networking (outbound HTTPS)\nYou have two viable patterns; choose based on whether you need a fixed egress IP and/or access to private resources:\n\n**Option A (simplest, recommended if you only need public internet access):**\n- Run Lambda **without VPC attachment**.\n- Lambda uses AWS-managed networking to reach the public internet; no NAT required.\n\n**Option B (use if you need static egress IPs, VPC-only dependencies, or tighter egress controls):**\n- Attach Lambda to a **VPC** with **private subnets**.\n- Provide outbound internet via **NAT Gateway** in **public subnets** (with an Internet Gateway).\n- Use **security groups** and **NACLs** to restrict egress as needed.\n\n### 4) Invocation / API surface\n- If the “Caller” is an external system, expose a managed endpoint:\n  - **Amazon API Gateway (HTTP API)** → **Lambda**.\n- Add **AWS WAF** (optional) in front of API Gateway if you need basic protection/rate limiting at the edge.\n- If the caller is internal (another AWS service), you can invoke Lambda directly (IAM-authenticated) and skip API Gateway.\n\n### 5) Secrets, configuration, and allow-listing\n- Store configuration (timeouts, user agent, allowed domains, etc.) in **Lambda environment variables**.\n- Store sensitive values (if any) in **AWS Secrets Manager** (or SSM Parameter Store) and grant Lambda read access.\n- Because `event.url` is user-controlled, implement:\n  - **Domain allow-list / deny-list**\n  - **SSRF protections** (block link-local, RFC1918, metadata IPs, etc.)\n  - Optional: route all requests through a controlled proxy if you need centralized egress policy.\n\n### 6) Observability and operations\n- **CloudWatch Logs** for stdout/stderr and structured logs.\n- **CloudWatch Metrics/Alarms** for errors, duration, throttles, concurrent executions.\n- **AWS X-Ray** (optional) for tracing (note: it won’t trace inside Chromium, but helps around invocation and downstream calls).\n- **Dead-letter / failure handling** (optional): if invoked asynchronously, configure **SQS DLQ** or **SNS** for failed events.\n\n### 7) IAM and security posture\n- Use a dedicated **Lambda execution role** with least privilege:\n  - Write logs to CloudWatch\n  - Read secrets (if used)\n  - (If VPC) manage ENIs implicitly via Lambda service\n- ECR access is handled by Lambda when you reference the image; keep ECR repo policy tight.\n\n### 8) Deployment strategy\n- Use **Terraform** to provision: ECR, Lambda, IAM, (optional) API Gateway, (optional) VPC/NAT, logging/alarms.\n- Use **versioned image tags** (e.g., git SHA) and update the Lambda function to the new image digest/tag per release.\n\n---\n\n## Notes specific to Playwright-on-Lambda\n- Prefer **container image** (you already do) to control OS libraries and Chromium dependencies.\n- Consider writing artifacts (screenshots/traces) to **S3** if you need persistence beyond the invocation.\n- If you need to run many URLs reliably, consider an async pattern: **API Gateway → SQS → Lambda** to smooth spikes and control concurrency.\n",
  "aws_resources": [
    "Amazon ECR repository (with lifecycle policy and image scanning)",
    "AWS Lambda function (container image)",
    "AWS Lambda execution IAM role",
    "IAM policy attachments (CloudWatch Logs, Secrets access if needed)",
    "Amazon CloudWatch Log Group (for Lambda)",
    "Amazon CloudWatch Alarms (Errors, Duration, Throttles, ConcurrentExecutions)",
    "Amazon API Gateway HTTP API (optional, if you need an HTTPS endpoint)",
    "API Gateway stage + routes + integration to Lambda (optional)",
    "AWS WAF Web ACL (optional, if exposing API publicly)",
    "AWS Secrets Manager secret(s) (optional, if any sensitive config is required)",
    "Amazon S3 bucket (optional, for storing screenshots/traces/results)",
    "VPC (optional; only if you need static egress IPs or private connectivity)",
    "VPC public subnets (optional; for NAT/IGW)",
    "VPC private subnets (optional; for Lambda ENIs)",
    "Internet Gateway (optional; if using VPC)",
    "NAT Gateway + Elastic IP (optional; if using VPC for outbound internet)",
    "Route tables + routes (optional; if using VPC)",
    "Security group for Lambda (optional; if using VPC)",
    "Network ACLs (optional; if using VPC and you want explicit subnet-level controls)",
    "AWS X-Ray tracing configuration (optional)",
    "SQS queue (optional; for async job buffering)",
    "SQS dead-letter queue (optional; for async failure handling)"
  ]
}