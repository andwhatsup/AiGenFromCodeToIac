{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \"~> 1.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 6.28\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = var.tags\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"name_prefix\" {\n  description = \"Prefix used to name resources.\"\n  type        = string\n  default     = \"freeipa\"\n}\n\nvariable \"tags\" {\n  description = \"Tags to apply to all resources.\"\n  type        = map(string)\n  default     = {}\n}\n\n# Networking\nvariable \"vpc_id\" {\n  description = \"VPC ID where FreeIPA instances will be deployed.\"\n  type        = string\n}\n\nvariable \"private_subnet_ids\" {\n  description = \"Private subnet IDs (at least 3 recommended) for the FreeIPA instances.\"\n  type        = list(string)\n}\n\nvariable \"trusted_cidr_blocks\" {\n  description = \"CIDR blocks outside the VPC that are allowed to access the IPA servers.\"\n  type        = list(string)\n  default     = []\n}\n\n# DNS\nvariable \"cool_domain\" {\n  description = \"The domain where the COOL resources reside (e.g. cool.cyber.dhs.gov).\"\n  type        = string\n  default     = \"cool.cyber.dhs.gov\"\n}\n\nvariable \"hosted_zone_id\" {\n  description = \"Route53 hosted zone ID for cool_domain.\"\n  type        = string\n}\n\nvariable \"ttl\" {\n  description = \"TTL for Route53 records.\"\n  type        = number\n  default     = 60\n}\n\n# EC2\nvariable \"ami_id\" {\n  description = \"AMI ID for FreeIPA instances.\"\n  type        = string\n}\n\nvariable \"instance_type\" {\n  description = \"EC2 instance type for FreeIPA servers.\"\n  type        = string\n  default     = \"t3.medium\"\n}\n\nvariable \"root_disk_size\" {\n  description = \"Root EBS volume size (GiB).\"\n  type        = number\n  default     = 8\n}\n\nvariable \"key_name\" {\n  description = \"Optional EC2 key pair name for SSH access. Prefer SSM Session Manager instead.\"\n  type        = string\n  default     = null\n}\n\n# SSM parameter keys (inputs)\nvariable \"crowdstrike_falcon_sensor_customer_id_key\" {\n  description = \"SSM Parameter Store key containing CrowdStrike customer ID.\"\n  type        = string\n  default     = \"/cdm/falcon/customer_id\"\n}\n\nvariable \"crowdstrike_falcon_sensor_tags_key\" {\n  description = \"SSM Parameter Store key containing CrowdStrike tags.\"\n  type        = string\n  default     = \"/cdm/falcon/tags\"\n}\n\nvariable \"nessus_hostname_key\" {\n  description = \"SSM Parameter Store key containing Nessus hostname.\"\n  type        = string\n  default     = \"/cdm/nessus_hostname\"\n}\n\nvariable \"nessus_key_key\" {\n  description = \"SSM Parameter Store key containing Nessus linking key.\"\n  type        = string\n  default     = \"/cdm/nessus_key\"\n}\n\nvariable \"nessus_port_key\" {\n  description = \"SSM Parameter Store key containing Nessus port.\"\n  type        = string\n  default     = \"/cdm/nessus_port\"\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\ndata \"aws_ssm_parameter\" \"crowdstrike_customer_id\" {\n  name = var.crowdstrike_falcon_sensor_customer_id_key\n}\n\ndata \"aws_ssm_parameter\" \"crowdstrike_tags\" {\n  name = var.crowdstrike_falcon_sensor_tags_key\n}\n\ndata \"aws_ssm_parameter\" \"nessus_hostname\" {\n  name = var.nessus_hostname_key\n}\n\ndata \"aws_ssm_parameter\" \"nessus_key\" {\n  name            = var.nessus_key_key\n  with_decryption = true\n}\n\ndata \"aws_ssm_parameter\" \"nessus_port\" {\n  name = var.nessus_port_key\n}\n\nlocals {\n  instance_names = [\"ipa0\", \"ipa1\", \"ipa2\"]\n\n  # Basic user_data stub. Real FreeIPA bootstrap is typically handled by a dedicated\n  # provisioning module; this keeps the stack self-contained and valid.\n  user_data = <<-EOT\n    #!/bin/bash\n    set -euo pipefail\n    echo \"FreeIPA placeholder bootstrap\" > /var/log/freeipa-bootstrap.log\n    echo \"CrowdStrike CID: ${data.aws_ssm_parameter.crowdstrike_customer_id.value}\" >> /var/log/freeipa-bootstrap.log\n    echo \"CrowdStrike tags: ${data.aws_ssm_parameter.crowdstrike_tags.value}\" >> /var/log/freeipa-bootstrap.log\n    echo \"Nessus host: ${data.aws_ssm_parameter.nessus_hostname.value}\" >> /var/log/freeipa-bootstrap.log\n    echo \"Nessus port: ${data.aws_ssm_parameter.nessus_port.value}\" >> /var/log/freeipa-bootstrap.log\n  EOT\n}\n\nmodule \"security_groups\" {\n  source = \"./modules/security_groups\"\n\n  vpc_id              = var.vpc_id\n  trusted_cidr_blocks = var.trusted_cidr_blocks\n  name_prefix         = var.name_prefix\n  tags                = var.tags\n}\n\nresource \"aws_iam_role\" \"instance\" {\n  name_prefix = \"${var.name_prefix}-ec2-\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n\n  tags = var.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ssm_core\" {\n  role       = aws_iam_role.instance.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\"\n}\n\nresource \"aws_iam_role_policy\" \"ssm_parameter_read\" {\n  name_prefix = \"${var.name_prefix}-ssm-read-\"\n  role        = aws_iam_role.instance.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"ReadParameters\"\n        Effect = \"Allow\"\n        Action = [\n          \"ssm:GetParameter\",\n          \"ssm:GetParameters\",\n          \"ssm:GetParametersByPath\"\n        ]\n        Resource = [\n          \"arn:aws:ssm:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:parameter${var.crowdstrike_falcon_sensor_customer_id_key}\",\n          \"arn:aws:ssm:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:parameter${var.crowdstrike_falcon_sensor_tags_key}\",\n          \"arn:aws:ssm:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:parameter${var.nessus_hostname_key}\",\n          \"arn:aws:ssm:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:parameter${var.nessus_key_key}\",\n          \"arn:aws:ssm:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:parameter${var.nessus_port_key}\"\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_instance_profile\" \"instance\" {\n  name_prefix = \"${var.name_prefix}-ec2-\"\n  role        = aws_iam_role.instance.name\n}\n\nresource \"aws_instance\" \"ipa\" {\n  count = length(local.instance_names)\n\n  ami                    = var.ami_id\n  instance_type          = var.instance_type\n  subnet_id              = var.private_subnet_ids[count.index % length(var.private_subnet_ids)]\n  vpc_security_group_ids = [module.security_groups.server_security_group_id]\n  iam_instance_profile   = aws_iam_instance_profile.instance.name\n\n  key_name = var.key_name\n\n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_tokens                 = \"required\"\n    http_put_response_hop_limit = 2\n  }\n\n  root_block_device {\n    volume_size = var.root_disk_size\n    volume_type = \"gp3\"\n    encrypted   = true\n  }\n\n  user_data = local.user_data\n\n  tags = merge(var.tags, {\n    Name = \"${var.name_prefix}-${local.instance_names[count.index]}\"\n    Role = \"freeipa\"\n  })\n}\n\n# Route53 records (A + basic service discovery placeholders)\nresource \"aws_route53_record\" \"ipa_a\" {\n  count   = length(local.instance_names)\n  zone_id = var.hosted_zone_id\n  name    = \"${local.instance_names[count.index]}.${var.cool_domain}\"\n  type    = \"A\"\n  ttl     = var.ttl\n  records = [aws_instance.ipa[count.index].private_ip]\n}\n\nresource \"aws_route53_record\" \"server_a\" {\n  zone_id = var.hosted_zone_id\n  name    = \"ipa.${var.cool_domain}\"\n  type    = \"A\"\n  ttl     = var.ttl\n  records = aws_instance.ipa[*].private_ip\n}\n\nresource \"aws_route53_record\" \"kerberos_txt\" {\n  zone_id = var.hosted_zone_id\n  name    = \"_kerberos.${var.cool_domain}\"\n  type    = \"TXT\"\n  ttl     = var.ttl\n  records = [\"\\\"${upper(var.cool_domain)}\\\"\"]\n}\n\n# Minimal SRV records for LDAP/Kerberos discovery (weights/priorities are placeholders)\nresource \"aws_route53_record\" \"ldap_srv\" {\n  zone_id = var.hosted_zone_id\n  name    = \"_ldap._tcp.${var.cool_domain}\"\n  type    = \"SRV\"\n  ttl     = var.ttl\n\n  records = [\n    for idx, n in local.instance_names : \"0 100 389 ${n}.${var.cool_domain}\"\n  ]\n}\n\nresource \"aws_route53_record\" \"ldaps_srv\" {\n  zone_id = var.hosted_zone_id\n  name    = \"_ldaps._tcp.${var.cool_domain}\"\n  type    = \"SRV\"\n  ttl     = var.ttl\n\n  records = [\n    for idx, n in local.instance_names : \"0 100 636 ${n}.${var.cool_domain}\"\n  ]\n}\n\n# Route53 health checks (TCP 443 to each instance private IP is not supported by Route53 health checks).\n# For private instances, health checks should be implemented via CloudWatch alarms or Route53 private health checks via CloudWatch.\n# To keep this configuration valid and aligned with the repo docs, we create CloudWatch-based health checks.\nresource \"aws_cloudwatch_metric_alarm\" \"instance_status\" {\n  count = length(local.instance_names)\n\n  alarm_name          = \"${var.name_prefix}-${local.instance_names[count.index]}-status-check-failed\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"StatusCheckFailed\"\n  namespace           = \"AWS/EC2\"\n  period              = 60\n  statistic           = \"Maximum\"\n  threshold           = 0\n\n  dimensions = {\n    InstanceId = aws_instance.ipa[count.index].id\n  }\n}\n\nresource \"aws_route53_health_check\" \"instance_status_check\" {\n  count = length(local.instance_names)\n\n  type = \"CLOUDWATCH_METRIC\"\n\n  cloudwatch_alarm_name   = aws_cloudwatch_metric_alarm.instance_status[count.index].alarm_name\n  cloudwatch_alarm_region = var.aws_region\n\n  insufficient_data_health_status = \"Unhealthy\"\n\n  tags = merge(var.tags, {\n    Name = \"${var.name_prefix}-${local.instance_names[count.index]}-hc\"\n  })\n}\n\nresource \"aws_route53_health_check\" \"overall\" {\n  type = \"CALCULATED\"\n\n  child_healthchecks      = aws_route53_health_check.instance_status_check[*].id\n  child_health_threshold  = 2\n\n  tags = merge(var.tags, {\n    Name = \"${var.name_prefix}-overall-hc\"\n  })\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"server0\" {\n  description = \"The first IPA server EC2 instance.\"\n  value       = aws_instance.ipa[0]\n}\n\noutput \"server1\" {\n  description = \"The second IPA server EC2 instance.\"\n  value       = aws_instance.ipa[1]\n}\n\noutput \"server2\" {\n  description = \"The third IPA server EC2 instance.\"\n  value       = aws_instance.ipa[2]\n}\n\noutput \"server_security_group\" {\n  description = \"The IPA server security group.\"\n  value       = module.security_groups.server_security_group_id\n}\n\noutput \"client_security_group\" {\n  description = \"The IPA client security group.\"\n  value       = module.security_groups.client_security_group_id\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "aws_region = \"us-east-1\"\nname_prefix = \"freeipa\"\n\n# Required\nvpc_id             = \"vpc-xxxxxxxx\"\nprivate_subnet_ids = [\"subnet-aaaaaaa\", \"subnet-bbbbbbb\", \"subnet-ccccccc\"]\nhosted_zone_id     = \"Z1234567890ABC\"\nami_id             = \"ami-0123456789abcdef0\"\n\ntrusted_cidr_blocks = [\"10.99.49.0/24\", \"10.99.52.0/24\"]\n\ntags = {\n  Project = \"freeipa\"\n}\n"
    },
    {
      "name": "modules/security_groups/versions.tf",
      "content": "terraform {\n  required_version = \"~> 1.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 6.28\"\n    }\n  }\n}\n"
    },
    {
      "name": "modules/security_groups/variables.tf",
      "content": "variable \"vpc_id\" {\n  description = \"The ID of the VPC where the IPA cluster is to be instantiated.\"\n  type        = string\n}\n\nvariable \"trusted_cidr_blocks\" {\n  description = \"CIDR blocks outside the VPC that are allowed to access the IPA servers.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"name_prefix\" {\n  description = \"Prefix used to name resources.\"\n  type        = string\n  default     = \"freeipa\"\n}\n\nvariable \"tags\" {\n  description = \"Tags to apply to resources.\"\n  type        = map(string)\n  default     = {}\n}\n"
    },
    {
      "name": "modules/security_groups/main.tf",
      "content": "resource \"aws_security_group\" \"server\" {\n  name_prefix = \"${var.name_prefix}-server-\"\n  description = \"FreeIPA server security group\"\n  vpc_id      = var.vpc_id\n\n  tags = merge(var.tags, {\n    Name = \"${var.name_prefix}-server\"\n  })\n}\n\nresource \"aws_security_group\" \"client\" {\n  name_prefix = \"${var.name_prefix}-client-\"\n  description = \"FreeIPA client security group\"\n  vpc_id      = var.vpc_id\n\n  tags = merge(var.tags, {\n    Name = \"${var.name_prefix}-client\"\n  })\n}\n\n# Client egress: allow clients to reach servers on required ports.\nresource \"aws_security_group_rule\" \"client_egress\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.client.id\n\n  from_port                = 0\n  to_port                  = 0\n  protocol                 = \"-1\"\n  source_security_group_id = aws_security_group.server.id\n\n  description = \"Allow FreeIPA clients to reach FreeIPA servers\"\n}\n\n# Server ingress from clients (common FreeIPA ports; keep minimal and adjust as needed)\nresource \"aws_security_group_rule\" \"server_ingress_clients\" {\n  type              = \"ingress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port                = 0\n  to_port                  = 0\n  protocol                 = \"-1\"\n  source_security_group_id = aws_security_group.client.id\n\n  description = \"Allow FreeIPA client traffic\"\n}\n\n# Server ingress from trusted CIDRs (admin access / bootstrap). Keep narrow in real deployments.\nresource \"aws_security_group_rule\" \"server_ingress_trusted\" {\n  count             = length(var.trusted_cidr_blocks) > 0 ? 1 : 0\n  type              = \"ingress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port   = 443\n  to_port     = 443\n  protocol    = \"tcp\"\n  cidr_blocks = var.trusted_cidr_blocks\n\n  description = \"Allow HTTPS from trusted CIDRs\"\n}\n\n# Server self-replication / intra-cluster\nresource \"aws_security_group_rule\" \"server_ingress_self\" {\n  type              = \"ingress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port = 0\n  to_port   = 0\n  protocol  = \"-1\"\n  self      = true\n\n  description = \"Allow all traffic within server SG (replication/cluster)\"\n}\n\nresource \"aws_security_group_rule\" \"server_egress_self\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port = 0\n  to_port   = 0\n  protocol  = \"-1\"\n  self      = true\n\n  description = \"Allow all egress within server SG\"\n}\n\n# Server egress to the internet (via NAT) for package repos, etc.\nresource \"aws_security_group_rule\" \"server_http_egress\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port   = 80\n  to_port     = 80\n  protocol    = \"tcp\"\n  cidr_blocks = [\"0.0.0.0/0\"]\n\n  description = \"Allow HTTP egress\"\n}\n\nresource \"aws_security_group_rule\" \"server_https_egress\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.server.id\n\n  from_port   = 443\n  to_port     = 443\n  protocol    = \"tcp\"\n  cidr_blocks = [\"0.0.0.0/0\"]\n\n  description = \"Allow HTTPS egress\"\n}\n"
    },
    {
      "name": "modules/security_groups/outputs.tf",
      "content": "output \"server_security_group_id\" {\n  description = \"The IPA server security group ID.\"\n  value       = aws_security_group.server.id\n}\n\noutput \"client_security_group_id\" {\n  description = \"The IPA client security group ID.\"\n  value       = aws_security_group.client.id\n}\n"
    }
  ]
}