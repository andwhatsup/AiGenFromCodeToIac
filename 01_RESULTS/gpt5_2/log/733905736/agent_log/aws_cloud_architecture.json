{
  "aws_architecture_description": "## Proposed high-level AWS architecture (SonarQube Docker + external PostgreSQL + GitHub Actions + Terraform)\n\n### 1) Networking / security baseline\n- Deploy into a dedicated **VPC** spanning **2 Availability Zones** for resilience.\n- Create **public subnets** (for load balancer / NAT) and **private subnets** (for compute and database).\n- Use **VPC endpoints** where practical (S3, CloudWatch Logs, ECR) to reduce public egress.\n\n### 2) SonarQube runtime (container)\n- Run SonarQube as a container on **Amazon ECS (Fargate)**.\n  - This matches your current “single container” model but removes the need for a long-lived “remote deploy host”.\n  - The SonarQube service runs in **private subnets**.\n- Expose SonarQube via an **Application Load Balancer (ALB)** in public subnets:\n  - **HTTPS (443)** termination at the ALB using **ACM** certificate.\n  - Forward to the ECS service on **container port 9000**.\n  - Optionally restrict access to corporate IPs via ALB security group rules or AWS WAF.\n\n### 3) Persistence (required for SonarQube)\n- **Amazon RDS for PostgreSQL** in private subnets (Multi-AZ recommended).\n  - SonarQube connects over JDBC to the RDS endpoint.\n- **Amazon EFS** for SonarQube persistent directories:\n  - Mount EFS into the Fargate task for SonarQube’s persistent paths (data/logs/extensions). SonarSource explicitly recommends persistent volumes for these directories when running via Docker. ([docs.sonarsource.com](https://docs.sonarsource.com/sonarqube-server/2025.2/setup-and-upgrade/install-the-server/installing-sonarqube-from-docker/?utm_source=openai))\n\n### 4) Custom CA certificates / TLS trust\nYou currently inject custom CA certs into the JVM truststore via an overlay script.\n- Store the custom CA bundle in **AWS Secrets Manager** (or SSM Parameter Store if not sensitive).\n- At task startup, use an **ECS task init/entrypoint step** (or sidecar) to:\n  - fetch the CA bundle,\n  - import into the JVM truststore (similar to your current `keytool` approach),\n  - then start SonarQube.\n\n### 5) CI/CD + Terraform (replace SSH-to-host)\n- Keep **GitHub Actions**, but switch from SSHing into a host to using **OIDC federation** into AWS:\n  - GitHub Actions assumes an **IAM role** (no long-lived AWS keys).\n  - Terraform runs in the GitHub runner and provisions AWS resources directly.\n- Terraform remote state:\n  - Use an **S3 bucket** for state with **versioning + encryption**.\n  - Enable **native S3 state locking** (`use_lockfile = true`) rather than DynamoDB locking (now deprecated in Terraform docs and AWS guidance). ([docs.aws.amazon.com](https://docs.aws.amazon.com/prescriptive-guidance/latest/terraform-aws-provider-best-practices/backend.html?utm_source=openai))\n\n### 6) Observability / operations\n- Send ECS container logs to **CloudWatch Logs**.\n- Enable **ALB access logs** to S3.\n- Use **CloudWatch alarms** (CPU/memory, ALB 5xx, target health, RDS metrics, EFS burst credits if relevant).\n- Use **AWS Backup** for RDS snapshots and (optionally) EFS backups.\n\n---\n\n## Notes on “lean” sizing\n- SonarQube Community is typically a single-instance service; ECS service desired count can be **1** initially.\n- Multi-AZ for RDS is the main availability lever; scaling SonarQube horizontally is not always straightforward due to its architecture and shared state.\n",
  "aws_resources": [
    "VPC",
    "Internet Gateway",
    "NAT Gateway (1 per AZ or 1 total for cost-lean)",
    "Public Subnets (2)",
    "Private Subnets (2)",
    "Route Tables (public/private)",
    "Security Groups (ALB, ECS tasks, RDS, EFS)",
    "VPC Endpoints (Gateway: S3; Interface: ECR API, ECR DKR, CloudWatch Logs, Secrets Manager as needed)",
    "AWS Certificate Manager (ACM) certificate",
    "Application Load Balancer (ALB)",
    "ALB Target Group",
    "ALB Listener (HTTPS 443)",
    "Route 53 Hosted Zone record (optional, if using a custom domain)",
    "AWS WAF Web ACL (optional, if internet-exposed hardening is needed)",
    "Amazon ECS Cluster",
    "ECS Service (SonarQube)",
    "ECS Task Definition",
    "ECS Task Execution Role (IAM)",
    "ECS Task Role (IAM)",
    "Amazon ECR Repository (if you build a custom SonarQube image with CA overlay; optional if using public image directly)",
    "Amazon EFS File System",
    "EFS Mount Targets (per private subnet/AZ)",
    "EFS Access Point (recommended)",
    "Amazon RDS for PostgreSQL (DB instance or Aurora PostgreSQL if desired)",
    "RDS Subnet Group",
    "RDS Parameter Group (optional)",
    "AWS Secrets Manager secrets (DB credentials, custom CA bundle)",
    "AWS KMS keys (for S3/EFS/Secrets/RDS encryption; can use AWS-managed keys or CMKs)",
    "S3 Bucket for Terraform state (versioning, encryption, public access block)",
    "S3 Bucket for ALB access logs (optional)",
    "IAM OIDC Provider for GitHub Actions",
    "IAM Role for GitHub Actions (assume-role via OIDC)",
    "CloudWatch Log Group(s)",
    "CloudWatch Alarms (ALB, ECS, RDS, EFS)",
    "AWS Backup Vault",
    "AWS Backup Plan + Selections (RDS, optionally EFS)"
  ]
}