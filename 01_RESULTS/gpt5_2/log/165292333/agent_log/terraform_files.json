{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n    archive = {\n      source  = \"hashicorp/archive\"\n      version = \">= 2.4\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  type        = string\n  description = \"Project name used for naming/tagging.\"\n  default     = \"url-shortener\"\n}\n\nvariable \"environment\" {\n  type        = string\n  description = \"Environment name (e.g., dev, stage, prod).\"\n  default     = \"dev\"\n}\n\nvariable \"aws_region\" {\n  type        = string\n  description = \"AWS region to deploy into. NOTE: lambda.py hardcodes us-east-1 for DynamoDB client.\"\n  default     = \"us-east-1\"\n}\n\nvariable \"table_name\" {\n  type        = string\n  description = \"DynamoDB table name. Must match lambda.py (URLDB) unless you change code.\"\n  default     = \"URLDB\"\n}\n\nvariable \"ttl_attribute\" {\n  type        = string\n  description = \"DynamoDB TTL attribute name.\"\n  default     = \"ttl\"\n}\n\nvariable \"lambda_runtime\" {\n  type        = string\n  description = \"Lambda runtime.\"\n  default     = \"python3.12\"\n}\n\nvariable \"lambda_timeout\" {\n  type        = number\n  description = \"Lambda timeout in seconds.\"\n  default     = 10\n}\n\nvariable \"lambda_memory_size\" {\n  type        = number\n  description = \"Lambda memory size in MB.\"\n  default     = 256\n}\n\nvariable \"log_retention_days\" {\n  type        = number\n  description = \"CloudWatch log retention in days.\"\n  default     = 14\n}\n\nvariable \"cors_allowed_origins\" {\n  type        = list(string)\n  description = \"Allowed origins for API CORS. Use your CloudFront domain/custom domain in production.\"\n  default     = [\"*\"]\n}\n\nvariable \"static_site_bucket_name\" {\n  type        = string\n  description = \"Optional fixed name for the S3 bucket hosting the static site. Leave null to auto-generate.\"\n  default     = null\n}\n\nvariable \"api_stage_name\" {\n  type        = string\n  description = \"API Gateway stage name.\"\n  default     = \"prod\"\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "locals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n}\n"
    },
    {
      "name": "dynamodb.tf",
      "content": "resource \"aws_dynamodb_table\" \"urldb\" {\n  name         = var.table_name\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"short_url_id\"\n\n  attribute {\n    name = \"short_url_id\"\n    type = \"S\"\n  }\n\n  ttl {\n    attribute_name = var.ttl_attribute\n    enabled        = true\n  }\n\n  point_in_time_recovery {\n    enabled = true\n  }\n}\n"
    },
    {
      "name": "lambda.tf",
      "content": "data \"archive_file\" \"lambda_zip\" {\n  type        = \"zip\"\n  source_file = \"${path.module}/../lambda.py\"\n  output_path = \"${path.module}/build/lambda.zip\"\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"${local.name_prefix}-lambda-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"lambda_logs\" {\n  name = \"${local.name_prefix}-lambda-logs\"\n  role = aws_iam_role.lambda_exec.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"logs:CreateLogGroup\",\n          \"logs:CreateLogStream\",\n          \"logs:PutLogEvents\"\n        ]\n        Resource = \"*\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"lambda_dynamodb\" {\n  name = \"${local.name_prefix}-lambda-ddb\"\n  role = aws_iam_role.lambda_exec.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"dynamodb:GetItem\",\n          \"dynamodb:PutItem\"\n        ]\n        Resource = aws_dynamodb_table.urldb.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_cloudwatch_log_group\" \"lambda\" {\n  name              = \"/aws/lambda/${local.name_prefix}\"\n  retention_in_days = var.log_retention_days\n}\n\nresource \"aws_lambda_function\" \"api\" {\n  function_name = local.name_prefix\n  role          = aws_iam_role.lambda_exec.arn\n  handler       = \"lambda.handler\"\n  runtime       = var.lambda_runtime\n\n  filename         = data.archive_file.lambda_zip.output_path\n  source_code_hash = data.archive_file.lambda_zip.output_base64sha256\n\n  timeout     = var.lambda_timeout\n  memory_size = var.lambda_memory_size\n\n  environment {\n    variables = {\n      TABLE_NAME = var.table_name\n    }\n  }\n\n  depends_on = [aws_cloudwatch_log_group.lambda]\n}\n"
    },
    {
      "name": "apigateway.tf",
      "content": "resource \"aws_api_gateway_rest_api\" \"this\" {\n  name = \"${local.name_prefix}-api\"\n\n  endpoint_configuration {\n    types = [\"REGIONAL\"]\n  }\n}\n\nresource \"aws_api_gateway_resource\" \"proxy\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  parent_id   = aws_api_gateway_rest_api.this.root_resource_id\n  path_part   = \"{proxy+}\"\n}\n\nresource \"aws_api_gateway_method\" \"any_root\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  resource_id   = aws_api_gateway_rest_api.this.root_resource_id\n  http_method   = \"ANY\"\n  authorization = \"NONE\"\n}\n\nresource \"aws_api_gateway_integration\" \"any_root\" {\n  rest_api_id             = aws_api_gateway_rest_api.this.id\n  resource_id             = aws_api_gateway_rest_api.this.root_resource_id\n  http_method             = aws_api_gateway_method.any_root.http_method\n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = aws_lambda_function.api.invoke_arn\n}\n\nresource \"aws_api_gateway_method\" \"any_proxy\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  resource_id   = aws_api_gateway_resource.proxy.id\n  http_method   = \"ANY\"\n  authorization = \"NONE\"\n}\n\nresource \"aws_api_gateway_integration\" \"any_proxy\" {\n  rest_api_id             = aws_api_gateway_rest_api.this.id\n  resource_id             = aws_api_gateway_resource.proxy.id\n  http_method             = aws_api_gateway_method.any_proxy.http_method\n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = aws_lambda_function.api.invoke_arn\n}\n\nresource \"aws_lambda_permission\" \"apigw\" {\n  statement_id  = \"AllowExecutionFromAPIGateway\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.api.function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = \"${aws_api_gateway_rest_api.this.execution_arn}/*/*\"\n}\n\nresource \"aws_cloudwatch_log_group\" \"apigw_access\" {\n  name              = \"/aws/apigateway/${local.name_prefix}-access\"\n  retention_in_days = var.log_retention_days\n}\n\nresource \"aws_api_gateway_deployment\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n\n  triggers = {\n    redeploy = sha1(jsonencode({\n      any_root  = aws_api_gateway_integration.any_root.id\n      any_proxy = aws_api_gateway_integration.any_proxy.id\n    }))\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_api_gateway_stage\" \"this\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  deployment_id = aws_api_gateway_deployment.this.id\n  stage_name    = var.api_stage_name\n\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.apigw_access.arn\n    format = jsonencode({\n      requestId      = \"$context.requestId\"\n      ip             = \"$context.identity.sourceIp\"\n      requestTime    = \"$context.requestTime\"\n      httpMethod     = \"$context.httpMethod\"\n      routeKey       = \"$context.routeKey\"\n      path           = \"$context.path\"\n      status         = \"$context.status\"\n      protocol       = \"$context.protocol\"\n      responseLength = \"$context.responseLength\"\n      userAgent      = \"$context.identity.userAgent\"\n    })\n  }\n\n  xray_tracing_enabled = false\n}\n\n# CORS for /{proxy+}\nresource \"aws_api_gateway_method\" \"options_proxy\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  resource_id   = aws_api_gateway_resource.proxy.id\n  http_method   = \"OPTIONS\"\n  authorization = \"NONE\"\n}\n\nresource \"aws_api_gateway_integration\" \"options_proxy\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  resource_id = aws_api_gateway_resource.proxy.id\n  http_method = aws_api_gateway_method.options_proxy.http_method\n  type        = \"MOCK\"\n\n  request_templates = {\n    \"application/json\" = \"{\\\"statusCode\\\": 200}\"\n  }\n}\n\nresource \"aws_api_gateway_method_response\" \"options_proxy\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  resource_id = aws_api_gateway_resource.proxy.id\n  http_method = aws_api_gateway_method.options_proxy.http_method\n  status_code = \"200\"\n\n  response_parameters = {\n    \"method.response.header.Access-Control-Allow-Headers\" = true\n    \"method.response.header.Access-Control-Allow-Methods\" = true\n    \"method.response.header.Access-Control-Allow-Origin\"  = true\n  }\n}\n\nresource \"aws_api_gateway_integration_response\" \"options_proxy\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  resource_id = aws_api_gateway_resource.proxy.id\n  http_method = aws_api_gateway_method.options_proxy.http_method\n  status_code = aws_api_gateway_method_response.options_proxy.status_code\n\n  response_parameters = {\n    \"method.response.header.Access-Control-Allow-Headers\" = \"'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'\"\n    \"method.response.header.Access-Control-Allow-Methods\" = \"'GET,POST,OPTIONS'\"\n    \"method.response.header.Access-Control-Allow-Origin\"  = \"'${join(\",\", var.cors_allowed_origins)}'\"\n  }\n\n  depends_on = [aws_api_gateway_integration.options_proxy]\n}\n"
    },
    {
      "name": "s3_cloudfront.tf",
      "content": "resource \"aws_s3_bucket\" \"static\" {\n  bucket        = coalesce(var.static_site_bucket_name, \"${local.name_prefix}-static-${data.aws_caller_identity.current.account_id}\")\n  force_destroy = true\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\nresource \"aws_s3_bucket_public_access_block\" \"static\" {\n  bucket = aws_s3_bucket.static.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_versioning\" \"static\" {\n  bucket = aws_s3_bucket.static.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"static\" {\n  bucket = aws_s3_bucket.static.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n\nresource \"aws_s3_bucket_ownership_controls\" \"static\" {\n  bucket = aws_s3_bucket.static.id\n\n  rule {\n    object_ownership = \"BucketOwnerPreferred\"\n  }\n}\n\nresource \"aws_s3_object\" \"index\" {\n  bucket       = aws_s3_bucket.static.id\n  key          = \"index.html\"\n  source       = \"${path.module}/../static/index.html\"\n  content_type = \"text/html; charset=utf-8\"\n  etag         = filemd5(\"${path.module}/../static/index.html\")\n}\n\nresource \"aws_cloudfront_origin_access_control\" \"oac\" {\n  name                              = \"${local.name_prefix}-oac\"\n  description                       = \"OAC for static site bucket\"\n  origin_access_control_origin_type = \"s3\"\n  signing_behavior                  = \"always\"\n  signing_protocol                  = \"sigv4\"\n}\n\nresource \"aws_cloudfront_distribution\" \"static\" {\n  enabled             = true\n  is_ipv6_enabled     = true\n  default_root_object = \"index.html\"\n  comment             = \"${local.name_prefix} static site\"\n\n  origin {\n    domain_name              = aws_s3_bucket.static.bucket_regional_domain_name\n    origin_id                = \"s3-static\"\n    origin_access_control_id = aws_cloudfront_origin_access_control.oac.id\n  }\n\n  default_cache_behavior {\n    target_origin_id       = \"s3-static\"\n    viewer_protocol_policy = \"redirect-to-https\"\n\n    allowed_methods = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n\n    compress = true\n\n    forwarded_values {\n      query_string = false\n\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    min_ttl     = 0\n    default_ttl = 3600\n    max_ttl     = 86400\n  }\n\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n  }\n\n  viewer_certificate {\n    cloudfront_default_certificate = true\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"static\" {\n  bucket = aws_s3_bucket.static.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"AllowCloudFrontServicePrincipalReadOnly\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"cloudfront.amazonaws.com\"\n        }\n        Action   = [\"s3:GetObject\"]\n        Resource = \"${aws_s3_bucket.static.arn}/*\"\n        Condition = {\n          StringEquals = {\n            \"AWS:SourceArn\" = aws_cloudfront_distribution.static.arn\n          }\n        }\n      }\n    ]\n  })\n\n  depends_on = [aws_s3_bucket_public_access_block.static]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"api_invoke_url\" {\n  description = \"Base invoke URL for the deployed API stage.\"\n  value       = aws_api_gateway_stage.this.invoke_url\n}\n\noutput \"cloudfront_domain_name\" {\n  description = \"CloudFront distribution domain name for the static site.\"\n  value       = aws_cloudfront_distribution.static.domain_name\n}\n\noutput \"static_bucket_name\" {\n  description = \"S3 bucket name hosting the static site content.\"\n  value       = aws_s3_bucket.static.bucket\n}\n\noutput \"dynamodb_table_name\" {\n  value = aws_dynamodb_table.urldb.name\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "# Example values. Adjust as needed.\nproject_name = \"url-shortener\"\nenvironment  = \"dev\"\naws_region   = \"us-east-1\"\n\n# In production, set this to your CloudFront custom domain (or distribution domain)\n# e.g., [\"https://s.example.com\"]\ncors_allowed_origins = [\"*\"]\n"
    }
  ]
}