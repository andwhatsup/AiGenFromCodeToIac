{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.3.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.region\n\n  default_tags {\n    tags = var.tags\n  }\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"region\" {\n  description = \"AWS region\"\n  type        = string\n  default     = \"eu-west-1\"\n}\n\nvariable \"prefix\" {\n  description = \"Optional prefix to namespace resource names\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"tags\" {\n  description = \"Tags applied to all resources\"\n  type        = map(string)\n  default = {\n    App         = \"cann\"\n    Environment = \"production\"\n    CreatedBy   = \"terraform\"\n  }\n}\n\nvariable \"base_url\" {\n  description = \"The base url where announcements are published\"\n  type        = string\n  default     = \"http://www.gobcan.es/educacion/Nombramientos/Documentos\"\n}\n\nvariable \"date_format\" {\n  description = \"Date format used in announcements filenames\"\n  type        = string\n  default     = \"02-01-06\"\n}\n\nvariable \"schedule_expression\" {\n  description = \"Scheduling expression to check a new announcement\"\n  type        = string\n}\n\nvariable \"announcements\" {\n  description = \"Target announcements checks\"\n  type = map(object({\n    telegram_chat_id      = string\n    telegram_channel_name = string\n  }))\n}\n\nvariable \"telegram_auth_token\" {\n  description = \"Telegram Auth Token to publish new announcements\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"lambda_artifacts_dir\" {\n  description = \"Directory containing pre-built lambda zip artifacts (check_announcement.zip, send_notification.zip, send_telegram_notification.zip)\"\n  type        = string\n  default     = \"../dist\"\n}\n\nvariable \"log_retention_in_days\" {\n  description = \"CloudWatch log retention in days\"\n  type        = number\n  default     = 14\n}\n\nvariable \"telegram_lambda_reserved_concurrency\" {\n  description = \"Reserved concurrency for send_telegram_notification to avoid Telegram rate limits\"\n  type        = number\n  default     = 2\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "locals {\n  name_prefix = var.prefix != \"\" ? \"${var.prefix}-\" : \"\"\n\n  dynamodb_table_name = \"${local.name_prefix}cann-announcements\"\n  sns_topic_name      = \"${local.name_prefix}cann-notifications\"\n\n  lambda_check_name = \"${local.name_prefix}check_announcement\"\n  lambda_sns_name   = \"${local.name_prefix}send_notification\"\n  lambda_tg_name    = \"${local.name_prefix}send_telegram_notification\"\n\n  ssm_base_path = \"${local.name_prefix}announcements\"\n\n  # Parameter names expected by the Go code\n  ssm_telegram_auth_token_name = \"/${local.ssm_base_path}/telegram/auth_token\"\n  ssm_telegram_chat_id_tpl     = \"/${local.ssm_base_path}/telegram/{{.AnnouncementID}}/chat_id\"\n  ssm_telegram_channel_tpl     = \"/${local.ssm_base_path}/telegram/{{.AnnouncementID}}/channel_name\"\n}\n"
    },
    {
      "name": "dynamodb.tf",
      "content": "resource \"aws_dynamodb_table\" \"announcements\" {\n  name         = local.dynamodb_table_name\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"URL\"\n\n  attribute {\n    name = \"URL\"\n    type = \"S\"\n  }\n\n  ttl {\n    attribute_name = \"TTL\"\n    enabled        = true\n  }\n\n  stream_enabled   = true\n  stream_view_type = \"NEW_IMAGE\"\n\n  point_in_time_recovery {\n    enabled = true\n  }\n}\n"
    },
    {
      "name": "kms_ssm.tf",
      "content": "resource \"aws_kms_key\" \"ssm\" {\n  description             = \"KMS key for SSM Parameter Store SecureString (cann)\"\n  deletion_window_in_days = 7\n  enable_key_rotation     = true\n}\n\nresource \"aws_kms_alias\" \"ssm\" {\n  name          = \"alias/${local.name_prefix}cann-ssm\"\n  target_key_id = aws_kms_key.ssm.key_id\n}\n"
    },
    {
      "name": "ssm.tf",
      "content": "resource \"aws_ssm_parameter\" \"telegram_auth_token\" {\n  name   = local.ssm_telegram_auth_token_name\n  type   = \"SecureString\"\n  key_id = aws_kms_key.ssm.arn\n  value  = var.telegram_auth_token\n}\n\n# Per-announcement routing config\nresource \"aws_ssm_parameter\" \"telegram_chat_id\" {\n  for_each = var.announcements\n\n  name  = \"/${local.ssm_base_path}/telegram/${upper(each.key)}/chat_id\"\n  type  = \"String\"\n  value = each.value.telegram_chat_id\n}\n\nresource \"aws_ssm_parameter\" \"telegram_channel_name\" {\n  for_each = var.announcements\n\n  name  = \"/${local.ssm_base_path}/telegram/${upper(each.key)}/channel_name\"\n  type  = \"String\"\n  value = each.value.telegram_channel_name\n}\n"
    },
    {
      "name": "sns.tf",
      "content": "resource \"aws_sns_topic\" \"notifications\" {\n  name = local.sns_topic_name\n}\n"
    },
    {
      "name": "logs.tf",
      "content": "resource \"aws_cloudwatch_log_group\" \"check\" {\n  name              = \"/aws/lambda/${local.lambda_check_name}\"\n  retention_in_days = var.log_retention_in_days\n}\n\nresource \"aws_cloudwatch_log_group\" \"send_notification\" {\n  name              = \"/aws/lambda/${local.lambda_sns_name}\"\n  retention_in_days = var.log_retention_in_days\n}\n\nresource \"aws_cloudwatch_log_group\" \"send_telegram\" {\n  name              = \"/aws/lambda/${local.lambda_tg_name}\"\n  retention_in_days = var.log_retention_in_days\n}\n"
    },
    {
      "name": "iam.tf",
      "content": "data \"aws_iam_policy_document\" \"lambda_assume\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"sts:AssumeRole\",\n    ]\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n  }\n}\n\n# --- check_announcement role/policy ---\nresource \"aws_iam_role\" \"check\" {\n  name               = \"${local.lambda_check_name}-role\"\n  assume_role_policy = data.aws_iam_policy_document.lambda_assume.json\n}\n\ndata \"aws_iam_policy_document\" \"check\" {\n  statement {\n    sid     = \"DynamoDBReadWrite\"\n    effect  = \"Allow\"\n    actions = [\"dynamodb:GetItem\", \"dynamodb:PutItem\"]\n    resources = [\n      aws_dynamodb_table.announcements.arn,\n    ]\n  }\n\n  statement {\n    sid     = \"Logs\"\n    effect  = \"Allow\"\n    actions = [\"logs:CreateLogStream\", \"logs:PutLogEvents\"]\n    resources = [\n      \"${aws_cloudwatch_log_group.check.arn}:*\",\n    ]\n  }\n}\n\nresource \"aws_iam_policy\" \"check\" {\n  name   = \"${local.lambda_check_name}-policy\"\n  policy = data.aws_iam_policy_document.check.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"check\" {\n  role       = aws_iam_role.check.name\n  policy_arn = aws_iam_policy.check.arn\n}\n\n# --- send_notification role/policy ---\nresource \"aws_iam_role\" \"send_notification\" {\n  name               = \"${local.lambda_sns_name}-role\"\n  assume_role_policy = data.aws_iam_policy_document.lambda_assume.json\n}\n\ndata \"aws_iam_policy_document\" \"send_notification\" {\n  statement {\n    sid    = \"ReadDynamoDBStream\"\n    effect = \"Allow\"\n    actions = [\n      \"dynamodb:DescribeStream\",\n      \"dynamodb:GetRecords\",\n      \"dynamodb:GetShardIterator\",\n      \"dynamodb:ListStreams\",\n    ]\n    resources = [aws_dynamodb_table.announcements.stream_arn]\n  }\n\n  statement {\n    sid     = \"PublishSNS\"\n    effect  = \"Allow\"\n    actions = [\"sns:Publish\"]\n    resources = [\n      aws_sns_topic.notifications.arn,\n    ]\n  }\n\n  statement {\n    sid     = \"Logs\"\n    effect  = \"Allow\"\n    actions = [\"logs:CreateLogStream\", \"logs:PutLogEvents\"]\n    resources = [\n      \"${aws_cloudwatch_log_group.send_notification.arn}:*\",\n    ]\n  }\n}\n\nresource \"aws_iam_policy\" \"send_notification\" {\n  name   = \"${local.lambda_sns_name}-policy\"\n  policy = data.aws_iam_policy_document.send_notification.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"send_notification\" {\n  role       = aws_iam_role.send_notification.name\n  policy_arn = aws_iam_policy.send_notification.arn\n}\n\n# --- send_telegram_notification role/policy ---\nresource \"aws_iam_role\" \"send_telegram\" {\n  name               = \"${local.lambda_tg_name}-role\"\n  assume_role_policy = data.aws_iam_policy_document.lambda_assume.json\n}\n\ndata \"aws_iam_policy_document\" \"send_telegram\" {\n  statement {\n    sid     = \"SSMRead\"\n    effect  = \"Allow\"\n    actions = [\n      \"ssm:GetParameter\",\n      \"ssm:GetParametersByPath\",\n    ]\n    resources = [\n      aws_ssm_parameter.telegram_auth_token.arn,\n      \"arn:aws:ssm:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:parameter/${local.ssm_base_path}/telegram/*\",\n    ]\n  }\n\n  statement {\n    sid     = \"KMSDecryptForSSM\"\n    effect  = \"Allow\"\n    actions = [\"kms:Decrypt\"]\n    resources = [\n      aws_kms_key.ssm.arn,\n    ]\n  }\n\n  statement {\n    sid     = \"Logs\"\n    effect  = \"Allow\"\n    actions = [\"logs:CreateLogStream\", \"logs:PutLogEvents\"]\n    resources = [\n      \"${aws_cloudwatch_log_group.send_telegram.arn}:*\",\n    ]\n  }\n}\n\nresource \"aws_iam_policy\" \"send_telegram\" {\n  name   = \"${local.lambda_tg_name}-policy\"\n  policy = data.aws_iam_policy_document.send_telegram.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"send_telegram\" {\n  role       = aws_iam_role.send_telegram.name\n  policy_arn = aws_iam_policy.send_telegram.arn\n}\n"
    },
    {
      "name": "lambda.tf",
      "content": "resource \"aws_lambda_function\" \"check\" {\n  function_name = local.lambda_check_name\n  description   = \"Check if there is a new announcement and store state in DynamoDB\"\n  role          = aws_iam_role.check.arn\n  runtime       = \"go1.x\"\n  handler       = \"main\"\n\n  filename         = \"${var.lambda_artifacts_dir}/check_announcement.zip\"\n  source_code_hash = filebase64sha256(\"${var.lambda_artifacts_dir}/check_announcement.zip\")\n\n  timeout     = 10\n  memory_size = 128\n\n  environment {\n    variables = {\n      DYNAMODB_TABLE = aws_dynamodb_table.announcements.name\n      BASE_URL       = var.base_url\n      DATE_FORMAT    = var.date_format\n    }\n  }\n\n  depends_on = [aws_cloudwatch_log_group.check]\n}\n\nresource \"aws_lambda_function\" \"send_notification\" {\n  function_name = local.lambda_sns_name\n  description   = \"Publish DynamoDB stream inserts to SNS\"\n  role          = aws_iam_role.send_notification.arn\n  runtime       = \"go1.x\"\n  handler       = \"main\"\n\n  filename         = \"${var.lambda_artifacts_dir}/send_notification.zip\"\n  source_code_hash = filebase64sha256(\"${var.lambda_artifacts_dir}/send_notification.zip\")\n\n  timeout     = 10\n  memory_size = 128\n\n  environment {\n    variables = {\n      TOPIC_ARN = aws_sns_topic.notifications.arn\n    }\n  }\n\n  depends_on = [aws_cloudwatch_log_group.send_notification]\n}\n\nresource \"aws_lambda_function\" \"send_telegram\" {\n  function_name = local.lambda_tg_name\n  description   = \"Send SNS notifications to Telegram\"\n  role          = aws_iam_role.send_telegram.arn\n  runtime       = \"go1.x\"\n  handler       = \"main\"\n\n  filename         = \"${var.lambda_artifacts_dir}/send_telegram_notification.zip\"\n  source_code_hash = filebase64sha256(\"${var.lambda_artifacts_dir}/send_telegram_notification.zip\")\n\n  timeout     = 30\n  memory_size = 256\n\n  reserved_concurrent_executions = var.telegram_lambda_reserved_concurrency\n\n  environment {\n    variables = {\n      SSM_TELEGRAM_AUTH_TOKEN   = aws_ssm_parameter.telegram_auth_token.name\n      SSM_TELEGRAM_CHAT_ID      = local.ssm_telegram_chat_id_tpl\n      SSM_TELEGRAM_CHANNEL_NAME = local.ssm_telegram_channel_tpl\n    }\n  }\n\n  depends_on = [aws_cloudwatch_log_group.send_telegram]\n}\n"
    },
    {
      "name": "eventbridge.tf",
      "content": "resource \"aws_cloudwatch_event_rule\" \"check_schedule\" {\n  name                = \"${local.name_prefix}cann-check-announcement\"\n  description         = \"Scheduled trigger for check_announcement\"\n  schedule_expression = var.schedule_expression\n}\n\nresource \"aws_cloudwatch_event_target\" \"check_schedule\" {\n  rule      = aws_cloudwatch_event_rule.check_schedule.name\n  target_id = \"check_announcement\"\n  arn       = aws_lambda_function.check.arn\n\n  input = jsonencode({\n    AnnouncementID = \"ndptf\"\n  })\n}\n\nresource \"aws_lambda_permission\" \"allow_eventbridge\" {\n  statement_id  = \"AllowExecutionFromEventBridge\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.check.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.check_schedule.arn\n}\n"
    },
    {
      "name": "triggers.tf",
      "content": "resource \"aws_lambda_event_source_mapping\" \"ddb_stream_to_send_notification\" {\n  event_source_arn  = aws_dynamodb_table.announcements.stream_arn\n  function_name     = aws_lambda_function.send_notification.arn\n  starting_position = \"LATEST\"\n\n  # Only INSERT events are used by the code; filtering reduces invocations.\n  filter_criteria {\n    filter {\n      pattern = jsonencode({\n        eventName = [\"INSERT\"]\n      })\n    }\n  }\n}\n\nresource \"aws_sns_topic_subscription\" \"telegram\" {\n  topic_arn = aws_sns_topic.notifications.arn\n  protocol  = \"lambda\"\n  endpoint  = aws_lambda_function.send_telegram.arn\n}\n\nresource \"aws_lambda_permission\" \"allow_sns\" {\n  statement_id  = \"AllowExecutionFromSNS\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.send_telegram.function_name\n  principal     = \"sns.amazonaws.com\"\n  source_arn    = aws_sns_topic.notifications.arn\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"dynamodb_table_name\" {\n  value = aws_dynamodb_table.announcements.name\n}\n\noutput \"sns_topic_arn\" {\n  value = aws_sns_topic.notifications.arn\n}\n\noutput \"ssm_telegram_auth_token_name\" {\n  value = aws_ssm_parameter.telegram_auth_token.name\n}\n\noutput \"lambda_check_arn\" {\n  value = aws_lambda_function.check.arn\n}\n\noutput \"lambda_send_notification_arn\" {\n  value = aws_lambda_function.send_notification.arn\n}\n\noutput \"lambda_send_telegram_arn\" {\n  value = aws_lambda_function.send_telegram.arn\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "announcements = {\n  ndptf = {\n    telegram_chat_id      = \"123456789\"\n    telegram_channel_name = \"@nombramientos_maestros_tfe\"\n  }\n}\n\nbase_url            = \"http://www.gobcan.es/educacion/Nombramientos/Documentos\"\ndate_format         = \"02-01-06\"\nschedule_expression = \"cron(*/1 6-20 ? * 2-6 *)\"\ntelegram_auth_token = \"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\"\n"
    },
    {
      "name": "README.md",
      "content": "# cann - Terraform (ai_tf)\n\nThis Terraform config provisions the serverless announcement notifier:\n\n- EventBridge scheduled rule -> `check_announcement` Lambda\n- DynamoDB table (with TTL + Streams)\n- DynamoDB Streams -> `send_notification` Lambda -> SNS topic\n- SNS topic -> `send_telegram_notification` Lambda\n- SSM Parameter Store for Telegram token + per-announcement routing\n- KMS CMK for SSM SecureString\n\n## Build artifacts\nThis configuration expects pre-built zip files:\n\n- `../dist/check_announcement.zip`\n- `../dist/send_notification.zip`\n- `../dist/send_telegram_notification.zip`\n\nAdjust `lambda_artifacts_dir` if needed.\n\n## Usage\n\n```bash\ncd ai_tf\nterraform init\nterraform validate\nterraform plan -var-file=terraform.tfvars\n```\n"
    }
  ]
}