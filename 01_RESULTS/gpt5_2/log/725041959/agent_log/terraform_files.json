{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.6\"\n    }\n    tls = {\n      source  = \"hashicorp/tls\"\n      version = \"~> 4.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Project/name prefix used for resource naming.\"\n  type        = string\n  default     = \"nextcloud-backup\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region.\"\n  type        = string\n  default     = \"eu-central-1\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"eks_cluster_version\" {\n  description = \"EKS Kubernetes version.\"\n  type        = string\n  default     = \"1.29\"\n}\n\nvariable \"node_instance_types\" {\n  description = \"EKS managed node group instance types.\"\n  type        = list(string)\n  default     = [\"t3.medium\"]\n}\n\nvariable \"node_desired_size\" {\n  type        = number\n  default     = 2\n  description = \"Desired node count.\"\n}\n\nvariable \"node_min_size\" {\n  type        = number\n  default     = 1\n  description = \"Minimum node count.\"\n}\n\nvariable \"node_max_size\" {\n  type        = number\n  default     = 3\n  description = \"Maximum node count.\"\n}\n\nvariable \"backup_bucket_name\" {\n  description = \"S3 bucket name for backups. Must be globally unique.\"\n  type        = string\n}\n\nvariable \"backup_bucket_force_destroy\" {\n  description = \"If true, allow Terraform to delete the bucket even if it contains objects (NOT recommended for prod).\"\n  type        = bool\n  default     = false\n}\n\nvariable \"db_name\" {\n  description = \"RDS initial database name.\"\n  type        = string\n  default     = \"nextcloud\"\n}\n\nvariable \"db_username\" {\n  description = \"RDS master username.\"\n  type        = string\n  default     = \"nextcloud\"\n}\n\nvariable \"db_instance_class\" {\n  description = \"RDS instance class.\"\n  type        = string\n  default     = \"db.t3.micro\"\n}\n\nvariable \"db_allocated_storage\" {\n  description = \"RDS allocated storage (GiB).\"\n  type        = number\n  default     = 20\n}\n\nvariable \"db_engine\" {\n  description = \"Database engine. Use 'mysql' or 'mariadb'.\"\n  type        = string\n  default     = \"mariadb\"\n  validation {\n    condition     = contains([\"mysql\", \"mariadb\"], var.db_engine)\n    error_message = \"db_engine must be 'mysql' or 'mariadb'.\"\n  }\n}\n\nvariable \"db_engine_version\" {\n  description = \"DB engine version. Leave default unless you need a specific version.\"\n  type        = string\n  default     = \"10.11\"\n}\n\nvariable \"db_multi_az\" {\n  description = \"Enable Multi-AZ for RDS.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"db_backup_retention_period\" {\n  description = \"RDS backup retention in days.\"\n  type        = number\n  default     = 7\n}\n\nvariable \"db_deletion_protection\" {\n  description = \"Enable deletion protection for RDS.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"efs_performance_mode\" {\n  description = \"EFS performance mode.\"\n  type        = string\n  default     = \"generalPurpose\"\n}\n\nvariable \"efs_throughput_mode\" {\n  description = \"EFS throughput mode.\"\n  type        = string\n  default     = \"bursting\"\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name for the backup image.\"\n  type        = string\n  default     = \"nextcloud-backup\"\n}\n\nvariable \"cronjob_namespace\" {\n  description = \"Kubernetes namespace for the backup CronJob.\"\n  type        = string\n  default     = \"nextcloud-backup\"\n}\n\nvariable \"cron_schedule\" {\n  description = \"Cron schedule for the backup job.\"\n  type        = string\n  default     = \"0 2 * * *\"\n}\n\nvariable \"backup_image\" {\n  description = \"Container image to run. Typically the ECR image URL with tag.\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"nextcloud_efs_access_point_path\" {\n  description = \"Path used by the EFS access point for Nextcloud data (mounted into the backup job).\"\n  type        = string\n  default     = \"/nextcloud\"\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "locals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  public_subnet_cidrs  = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i)]\n  private_subnet_cidrs = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i + 10)]\n}\n"
    },
    {
      "name": "data.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n"
    },
    {
      "name": "network.tf",
      "content": "resource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpc\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-igw\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : az => {\n    cidr = local.public_subnet_cidrs[idx]\n    az   = az\n  } }\n\n  vpc_id                  = aws_vpc.this.id\n  cidr_block              = each.value.cidr\n  availability_zone       = each.value.az\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${local.name_prefix}-public-${each.value.az}\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : az => {\n    cidr = local.private_subnet_cidrs[idx]\n    az   = az\n  } }\n\n  vpc_id            = aws_vpc.this.id\n  cidr_block        = each.value.cidr\n  availability_zone = each.value.az\n\n  tags = {\n    Name = \"${local.name_prefix}-private-${each.value.az}\"\n  }\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-public-rt\"\n  }\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\n# NAT for private subnets (EKS nodes typically need egress for pulling images unless you add all required VPC endpoints)\nresource \"aws_eip\" \"nat\" {\n  domain = \"vpc\"\n\n  tags = {\n    Name = \"${local.name_prefix}-nat-eip\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = values(aws_subnet.public)[0].id\n\n  tags = {\n    Name = \"${local.name_prefix}-nat\"\n  }\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-private-rt\"\n  }\n}\n\nresource \"aws_route\" \"private_nat\" {\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private.id\n}\n\n# S3 gateway endpoint for private subnets\nresource \"aws_vpc_endpoint\" \"s3\" {\n  vpc_id            = aws_vpc.this.id\n  service_name      = \"com.amazonaws.${var.aws_region}.s3\"\n  vpc_endpoint_type = \"Gateway\"\n\n  route_table_ids = [aws_route_table.private.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-s3-endpoint\"\n  }\n}\n"
    },
    {
      "name": "vpc_endpoints.tf",
      "content": "resource \"aws_security_group\" \"vpce\" {\n  name        = \"${local.name_prefix}-vpce\"\n  description = \"Security group for interface VPC endpoints\"\n  vpc_id      = aws_vpc.this.id\n\n  ingress {\n    description = \"HTTPS from VPC\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [aws_vpc.this.cidr_block]\n  }\n\n  egress {\n    description = \"All egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"ecr_api\" {\n  vpc_id              = aws_vpc.this.id\n  service_name        = \"com.amazonaws.${var.aws_region}.ecr.api\"\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-ecr-api\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"ecr_dkr\" {\n  vpc_id              = aws_vpc.this.id\n  service_name        = \"com.amazonaws.${var.aws_region}.ecr.dkr\"\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-ecr-dkr\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"logs\" {\n  vpc_id              = aws_vpc.this.id\n  service_name        = \"com.amazonaws.${var.aws_region}.logs\"\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-logs\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"secretsmanager\" {\n  vpc_id              = aws_vpc.this.id\n  service_name        = \"com.amazonaws.${var.aws_region}.secretsmanager\"\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-secretsmanager\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"sts\" {\n  vpc_id              = aws_vpc.this.id\n  service_name        = \"com.amazonaws.${var.aws_region}.sts\"\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-sts\"\n  }\n}\n"
    },
    {
      "name": "security.tf",
      "content": "resource \"aws_security_group\" \"eks_nodes\" {\n  name        = \"${local.name_prefix}-eks-nodes\"\n  description = \"Security group for EKS worker nodes\"\n  vpc_id      = aws_vpc.this.id\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-eks-nodes\"\n  }\n}\n\nresource \"aws_security_group\" \"rds\" {\n  name        = \"${local.name_prefix}-rds\"\n  description = \"RDS security group\"\n  vpc_id      = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-rds\"\n  }\n}\n\nresource \"aws_security_group_rule\" \"rds_from_eks\" {\n  type                     = \"ingress\"\n  security_group_id        = aws_security_group.rds.id\n  from_port                = 3306\n  to_port                  = 3306\n  protocol                 = \"tcp\"\n  source_security_group_id = aws_security_group.eks_nodes.id\n  description              = \"MySQL from EKS nodes\"\n}\n\nresource \"aws_security_group_rule\" \"rds_egress\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.rds.id\n  from_port         = 0\n  to_port           = 0\n  protocol          = \"-1\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  description       = \"Allow all egress\"\n}\n\nresource \"aws_security_group\" \"efs\" {\n  name        = \"${local.name_prefix}-efs\"\n  description = \"EFS security group\"\n  vpc_id      = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-efs\"\n  }\n}\n\nresource \"aws_security_group_rule\" \"efs_from_eks\" {\n  type                     = \"ingress\"\n  security_group_id        = aws_security_group.efs.id\n  from_port                = 2049\n  to_port                  = 2049\n  protocol                 = \"tcp\"\n  source_security_group_id = aws_security_group.eks_nodes.id\n  description              = \"NFS from EKS nodes\"\n}\n\nresource \"aws_security_group_rule\" \"efs_egress\" {\n  type              = \"egress\"\n  security_group_id = aws_security_group.efs.id\n  from_port         = 0\n  to_port           = 0\n  protocol          = \"-1\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  description       = \"Allow all egress\"\n}\n"
    },
    {
      "name": "kms.tf",
      "content": "resource \"aws_kms_key\" \"main\" {\n  description             = \"${local.name_prefix} encryption key (S3 backups, Secrets Manager)\"\n  deletion_window_in_days = 30\n  enable_key_rotation     = true\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid      = \"EnableRootPermissions\"\n        Effect   = \"Allow\"\n        Principal = {\n          AWS = \"arn:${data.aws_partition.current.partition}:iam::${data.aws_caller_identity.current.account_id}:root\"\n        }\n        Action   = \"kms:*\"\n        Resource = \"*\"\n      }\n    ]\n  })\n\n  tags = {\n    Name = \"${local.name_prefix}-kms\"\n  }\n}\n\nresource \"aws_kms_alias\" \"main\" {\n  name          = \"alias/${local.name_prefix}\"\n  target_key_id = aws_kms_key.main.key_id\n}\n"
    },
    {
      "name": "s3.tf",
      "content": "resource \"aws_s3_bucket\" \"backups\" {\n  bucket        = var.backup_bucket_name\n  force_destroy = var.backup_bucket_force_destroy\n\n  tags = {\n    Name = \"${local.name_prefix}-backups\"\n  }\n}\n\nresource \"aws_s3_bucket_versioning\" \"backups\" {\n  bucket = aws_s3_bucket.backups.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"backups\" {\n  bucket = aws_s3_bucket.backups.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = \"aws:kms\"\n      kms_master_key_id = aws_kms_key.main.arn\n    }\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"backups\" {\n  bucket = aws_s3_bucket.backups.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_lifecycle_configuration\" \"backups\" {\n  bucket = aws_s3_bucket.backups.id\n\n  rule {\n    id     = \"transition-and-expire\"\n    status = \"Enabled\"\n\n    filter {}\n\n    transition {\n      days          = 30\n      storage_class = \"GLACIER\"\n    }\n\n    expiration {\n      days = 365\n    }\n\n    noncurrent_version_expiration {\n      noncurrent_days = 90\n    }\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"backups\" {\n  bucket = aws_s3_bucket.backups.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid       = \"DenyInsecureTransport\"\n        Effect    = \"Deny\"\n        Principal = \"*\"\n        Action    = \"s3:*\"\n        Resource = [\n          aws_s3_bucket.backups.arn,\n          \"${aws_s3_bucket.backups.arn}/*\"\n        ]\n        Condition = {\n          Bool = { \"aws:SecureTransport\" = \"false\" }\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "ecr.tf",
      "content": "resource \"aws_ecr_repository\" \"backup\" {\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"KMS\"\n    kms_key         = aws_kms_key.main.arn\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-ecr\"\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"backup\" {\n  repository = aws_ecr_repository.backup.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Expire untagged images older than 14 days\"\n        selection = {\n          tagStatus   = \"untagged\"\n          countType   = \"sinceImagePushed\"\n          countUnit   = \"days\"\n          countNumber = 14\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "rds.tf",
      "content": "resource \"aws_db_subnet_group\" \"this\" {\n  name       = \"${local.name_prefix}-db-subnets\"\n  subnet_ids = [for s in aws_subnet.private : s.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-db-subnets\"\n  }\n}\n\nresource \"aws_db_parameter_group\" \"this\" {\n  name   = \"${local.name_prefix}-${var.db_engine}-params\"\n  family = var.db_engine == \"mysql\" ? \"mysql8.0\" : \"mariadb10.11\"\n\n  parameter {\n    name  = \"character_set_server\"\n    value = \"utf8mb4\"\n  }\n\n  parameter {\n    name  = \"collation_server\"\n    value = \"utf8mb4_unicode_ci\"\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-db-params\"\n  }\n}\n\nresource \"aws_db_instance\" \"this\" {\n  identifier = \"${local.name_prefix}-db\"\n\n  engine         = var.db_engine\n  engine_version = var.db_engine_version\n\n  instance_class    = var.db_instance_class\n  allocated_storage = var.db_allocated_storage\n\n  db_name  = var.db_name\n  username = var.db_username\n  password = random_password.db.result\n\n  db_subnet_group_name   = aws_db_subnet_group.this.name\n  vpc_security_group_ids = [aws_security_group.rds.id]\n  parameter_group_name   = aws_db_parameter_group.this.name\n\n  storage_encrypted = true\n  kms_key_id        = aws_kms_key.main.arn\n\n  backup_retention_period = var.db_backup_retention_period\n  multi_az                = var.db_multi_az\n\n  deletion_protection      = var.db_deletion_protection\n  skip_final_snapshot      = false\n  final_snapshot_identifier = \"${local.name_prefix}-final\"\n\n  publicly_accessible = false\n\n  apply_immediately          = true\n  auto_minor_version_upgrade = true\n\n  tags = {\n    Name = \"${local.name_prefix}-db\"\n  }\n}\n"
    },
    {
      "name": "secrets.tf",
      "content": "resource \"random_password\" \"db\" {\n  length  = 24\n  special = true\n}\n\nresource \"aws_secretsmanager_secret\" \"db\" {\n  name                    = \"${local.name_prefix}/rds\"\n  kms_key_id              = aws_kms_key.main.arn\n  recovery_window_in_days = 7\n}\n\nresource \"aws_secretsmanager_secret_version\" \"db\" {\n  secret_id = aws_secretsmanager_secret.db.id\n\n  secret_string = jsonencode({\n    username = var.db_username\n    password = random_password.db.result\n    host     = aws_db_instance.this.address\n    port     = aws_db_instance.this.port\n    dbname   = var.db_name\n  })\n}\n"
    },
    {
      "name": "efs.tf",
      "content": "resource \"aws_efs_file_system\" \"this\" {\n  encrypted        = true\n  kms_key_id       = aws_kms_key.main.arn\n  performance_mode = var.efs_performance_mode\n  throughput_mode  = var.efs_throughput_mode\n\n  tags = {\n    Name = \"${local.name_prefix}-efs\"\n  }\n}\n\nresource \"aws_efs_mount_target\" \"this\" {\n  for_each = aws_subnet.private\n\n  file_system_id  = aws_efs_file_system.this.id\n  subnet_id       = each.value.id\n  security_groups = [aws_security_group.efs.id]\n}\n\nresource \"aws_efs_access_point\" \"nextcloud\" {\n  file_system_id = aws_efs_file_system.this.id\n\n  root_directory {\n    path = var.nextcloud_efs_access_point_path\n\n    creation_info {\n      owner_gid   = 33\n      owner_uid   = 33\n      permissions = \"0750\"\n    }\n  }\n\n  posix_user {\n    gid = 33\n    uid = 33\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-efs-ap-nextcloud\"\n  }\n}\n"
    },
    {
      "name": "eks.tf",
      "content": "resource \"aws_iam_role\" \"eks_cluster\" {\n  name = \"${local.name_prefix}-eks-cluster-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"eks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_cluster_AmazonEKSClusterPolicy\" {\n  role       = aws_iam_role.eks_cluster.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/AmazonEKSClusterPolicy\"\n}\n\nresource \"aws_iam_role\" \"eks_node\" {\n  name = \"${local.name_prefix}-eks-node-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEKSWorkerNodePolicy\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/AmazonEKSWorkerNodePolicy\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEKS_CNI_Policy\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/AmazonEKS_CNI_Policy\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEC2ContainerRegistryReadOnly\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\"\n}\n\nresource \"aws_iam_instance_profile\" \"eks_node\" {\n  name = \"${local.name_prefix}-eks-node-profile\"\n  role = aws_iam_role.eks_node.name\n}\n\nresource \"aws_eks_cluster\" \"this\" {\n  name     = \"${local.name_prefix}-eks\"\n  role_arn = aws_iam_role.eks_cluster.arn\n  version  = var.eks_cluster_version\n\n  vpc_config {\n    subnet_ids              = concat([for s in aws_subnet.public : s.id], [for s in aws_subnet.private : s.id])\n    endpoint_public_access  = true\n    endpoint_private_access = true\n    security_group_ids      = [aws_security_group.eks_nodes.id]\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_cluster_AmazonEKSClusterPolicy\n  ]\n\n  tags = {\n    Name = \"${local.name_prefix}-eks\"\n  }\n}\n\nresource \"aws_eks_node_group\" \"default\" {\n  cluster_name    = aws_eks_cluster.this.name\n  node_group_name = \"${local.name_prefix}-ng\"\n  node_role_arn   = aws_iam_role.eks_node.arn\n  subnet_ids      = [for s in aws_subnet.private : s.id]\n\n  instance_types = var.node_instance_types\n\n  scaling_config {\n    desired_size = var.node_desired_size\n    min_size     = var.node_min_size\n    max_size     = var.node_max_size\n  }\n\n  update_config {\n    max_unavailable = 1\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-ng\"\n  }\n\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_node_AmazonEKSWorkerNodePolicy,\n    aws_iam_role_policy_attachment.eks_node_AmazonEKS_CNI_Policy,\n    aws_iam_role_policy_attachment.eks_node_AmazonEC2ContainerRegistryReadOnly\n  ]\n}\n\nresource \"aws_eks_addon\" \"vpc_cni\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"vpc-cni\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n\nresource \"aws_eks_addon\" \"coredns\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"coredns\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n\nresource \"aws_eks_addon\" \"kube_proxy\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"kube-proxy\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n"
    },
    {
      "name": "irsa.tf",
      "content": "data \"tls_certificate\" \"oidc\" {\n  url = aws_eks_cluster.this.identity[0].oidc[0].issuer\n}\n\nresource \"aws_iam_openid_connect_provider\" \"eks\" {\n  url             = aws_eks_cluster.this.identity[0].oidc[0].issuer\n  client_id_list  = [\"sts.amazonaws.com\"]\n  thumbprint_list = [data.tls_certificate.oidc.certificates[0].sha1_fingerprint]\n\n  tags = {\n    Name = \"${local.name_prefix}-eks-oidc\"\n  }\n}\n\nresource \"aws_iam_role\" \"backup_sa\" {\n  name = \"${local.name_prefix}-backup-irsa\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Federated = aws_iam_openid_connect_provider.eks.arn\n        }\n        Action = \"sts:AssumeRoleWithWebIdentity\"\n        Condition = {\n          StringEquals = {\n            \"${replace(aws_eks_cluster.this.identity[0].oidc[0].issuer, \"https://\", \"\")}:sub\" = \"system:serviceaccount:${var.cronjob_namespace}:nextcloud-backup\"\n          }\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"backup\" {\n  name        = \"${local.name_prefix}-backup-policy\"\n  description = \"Allow backup job to write to S3 and read DB secret\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"S3Write\"\n        Effect = \"Allow\"\n        Action = [\n          \"s3:PutObject\",\n          \"s3:AbortMultipartUpload\",\n          \"s3:ListBucket\",\n          \"s3:GetBucketLocation\"\n        ]\n        Resource = [\n          aws_s3_bucket.backups.arn,\n          \"${aws_s3_bucket.backups.arn}/*\"\n        ]\n      },\n      {\n        Sid    = \"ReadDbSecret\"\n        Effect = \"Allow\"\n        Action = [\n          \"secretsmanager:GetSecretValue\"\n        ]\n        Resource = [aws_secretsmanager_secret.db.arn]\n      },\n      {\n        Sid    = \"KmsForS3AndSecrets\"\n        Effect = \"Allow\"\n        Action = [\n          \"kms:Encrypt\",\n          \"kms:Decrypt\",\n          \"kms:GenerateDataKey\",\n          \"kms:DescribeKey\"\n        ]\n        Resource = [aws_kms_key.main.arn]\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"backup\" {\n  role       = aws_iam_role.backup_sa.name\n  policy_arn = aws_iam_policy.backup.arn\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value = aws_vpc.this.id\n}\n\noutput \"eks_cluster_name\" {\n  value = aws_eks_cluster.this.name\n}\n\noutput \"eks_cluster_endpoint\" {\n  value = aws_eks_cluster.this.endpoint\n}\n\noutput \"ecr_repository_url\" {\n  value = aws_ecr_repository.backup.repository_url\n}\n\noutput \"backup_bucket_name\" {\n  value = aws_s3_bucket.backups.bucket\n}\n\noutput \"rds_endpoint\" {\n  value = aws_db_instance.this.address\n}\n\noutput \"db_secret_arn\" {\n  value = aws_secretsmanager_secret.db.arn\n}\n\noutput \"efs_file_system_id\" {\n  value = aws_efs_file_system.this.id\n}\n\noutput \"efs_access_point_id\" {\n  value = aws_efs_access_point.nextcloud.id\n}\n\noutput \"backup_irsa_role_arn\" {\n  value = aws_iam_role.backup_sa.arn\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "aws_region   = \"eu-central-1\"\nenvironment  = \"dev\"\nproject_name = \"nextcloud-backup\"\n\n# Must be globally unique\nbackup_bucket_name = \"my-nextcloud-backups-123456\"\n\n# Optional\nbackup_bucket_force_destroy = false\n\n# DB\ndb_engine         = \"mariadb\"\ndb_engine_version = \"10.11\"\ndb_instance_class = \"db.t3.micro\"\ndb_multi_az       = false\n\n# EKS\neks_cluster_version = \"1.29\"\nnode_instance_types = [\"t3.medium\"]\nnode_desired_size   = 2\nnode_min_size       = 1\nnode_max_size       = 3\n\n# CronJob schedule (Kubernetes manifest not included in this Terraform)\ncron_schedule = \"0 2 * * *\"\n"
    },
    {
      "name": "README_DEPLOY.md",
      "content": "# Terraform: Nextcloud backup platform on AWS (EKS + RDS + EFS + S3)\n\nThis Terraform creates the AWS infrastructure to run the backup container as a Kubernetes CronJob on EKS.\n\n## What it provisions\n- VPC (public/private subnets, IGW, NAT)\n- S3 bucket for backups (versioning + SSE-KMS + lifecycle)\n- KMS key\n- ECR repository for the backup image\n- RDS (MySQL/MariaDB) + Secrets Manager secret for credentials\n- EFS + Access Point (for Nextcloud data)\n- EKS cluster + managed node group\n- IRSA role for a Kubernetes ServiceAccount named `nextcloud-backup` in namespace `nextcloud-backup`\n\n## How to use\n1. Copy `terraform.tfvars.example` to `terraform.tfvars` and set `backup_bucket_name`.\n2. Run:\n   ```bash\n   terraform init\n   terraform validate\n   terraform plan\n   ```\n\n## Notes\n- This repo does **not** include Kubernetes manifests. You still need to deploy a CronJob that:\n  - mounts EFS (via the EFS CSI driver) using the access point output\n  - reads the RDS secret (e.g., via External Secrets Operator or Secrets Store CSI)\n  - uploads to S3 (recommended) instead of FTP\n\n- The original container expects FTP env vars; consider updating the container to use S3 (rclone supports S3) or wrap it with a config.\n"
    },
    {
      "name": "_k8s_cronjob_example.yaml",
      "content": "# Example only (not applied by Terraform in this folder)\n# Requires EKS access + EFS CSI driver + a way to project Secrets Manager secret into env vars.\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: nextcloud-backup\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: nextcloud-backup\n  namespace: nextcloud-backup\n  annotations:\n    eks.amazonaws.com/role-arn: <backup_irsa_role_arn>\n---\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: nextcloud-backup\n  namespace: nextcloud-backup\nspec:\n  schedule: \"0 2 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          serviceAccountName: nextcloud-backup\n          restartPolicy: Never\n          containers:\n            - name: backup\n              image: <ecr_repository_url>:latest\n              env:\n                # You can use External Secrets Operator or Secrets Store CSI to map Secrets Manager values.\n                - name: DB_HOST\n                  value: <rds_endpoint>\n                - name: DB_USER\n                  valueFrom:\n                    secretKeyRef:\n                      name: nextcloud-db\n                      key: username\n                - name: DB_PASS\n                  valueFrom:\n                    secretKeyRef:\n                      name: nextcloud-db\n                      key: password\n              volumeMounts:\n                - name: nextcloud\n                  mountPath: /home/nextcloud\n          volumes:\n            - name: nextcloud\n              persistentVolumeClaim:\n                claimName: nextcloud-efs\n"
    },
    {
      "name": "random.tf",
      "content": "# (intentionally left blank)\n# Providers are declared in versions.tf\n"
    }
  ]
}