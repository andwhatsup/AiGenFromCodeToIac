{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 6.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = merge(\n      {\n        Project     = var.project_name\n        Environment = var.environment\n        ManagedBy   = \"terraform\"\n      },\n      var.tags\n    )\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Project name used for naming/tagging.\"\n  type        = string\n  default     = \"etl-pipeline\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"tags\" {\n  description = \"Additional tags to apply to all resources.\"\n  type        = map(string)\n  default     = {}\n}\n\nvariable \"create_vpc\" {\n  description = \"Whether to create a VPC and private subnets for Batch. If false, you must provide subnet_ids and security_group_ids.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR for the VPC (if create_vpc=true).\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (if create_vpc=true).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"enable_nat_gateway\" {\n  description = \"Whether to create NAT gateway(s) for outbound internet from private subnets. Set true if ETL calls public APIs.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"single_nat_gateway\" {\n  description = \"If enable_nat_gateway=true, create a single NAT gateway (cheaper) instead of one per AZ.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"subnet_ids\" {\n  description = \"Subnet IDs for AWS Batch compute (used when create_vpc=false).\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"security_group_ids\" {\n  description = \"Security group IDs for AWS Batch compute (used when create_vpc=false).\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"s3_bucket_name\" {\n  description = \"Name of the S3 landing bucket. Leave null to have Terraform generate a unique name.\"\n  type        = string\n  default     = null\n}\n\nvariable \"s3_prefix\" {\n  description = \"Optional prefix within the bucket that the ETL is allowed to write to. Empty means whole bucket.\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"s3_lifecycle_days_to_glacier\" {\n  description = \"If set, transition objects to GLACIER after this many days. Set null to disable.\"\n  type        = number\n  default     = null\n}\n\nvariable \"s3_lifecycle_days_to_expire\" {\n  description = \"If set, expire objects after this many days. Set null to disable.\"\n  type        = number\n  default     = null\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name for the ETL container image.\"\n  type        = string\n  default     = null\n}\n\nvariable \"container_image\" {\n  description = \"Full container image URI for the Batch job definition (e.g., <account>.dkr.ecr.<region>.amazonaws.com/repo:tag).\"\n  type        = string\n}\n\nvariable \"job_vcpus\" {\n  description = \"vCPU for the Batch job (Fargate).\"\n  type        = number\n  default     = 1\n}\n\nvariable \"job_memory\" {\n  description = \"Memory (MiB) for the Batch job (Fargate).\"\n  type        = number\n  default     = 2048\n}\n\nvariable \"job_command\" {\n  description = \"Command to run in the container. If null, uses the container image default CMD.\"\n  type        = list(string)\n  default     = null\n}\n\nvariable \"job_environment\" {\n  description = \"Environment variables passed to the container.\"\n  type        = map(string)\n  default     = {}\n}\n\nvariable \"schedule_expression\" {\n  description = \"EventBridge schedule expression (rate(...) or cron(...)).\"\n  type        = string\n  default     = \"rate(1 day)\"\n}\n\nvariable \"sns_email\" {\n  description = \"Optional email address to subscribe to failure notifications. Set null to disable subscription.\"\n  type        = string\n  default     = null\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # Prefix used in IAM/bucket policies. If empty, policies apply to the whole bucket.\n  s3_prefix_for_policy = (\n    var.s3_prefix == \"\" ? \"\" : (endswith(var.s3_prefix, \"/\") ? var.s3_prefix : \"${var.s3_prefix}/\")\n  )\n\n  ecr_repo_name = coalesce(var.ecr_repository_name, \"${local.name_prefix}-etl\")\n}\n"
    },
    {
      "name": "network.tf",
      "content": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"6.6.0\"\n\n  create_vpc = var.create_vpc\n\n  name = local.name_prefix\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  private_subnets = [for i, az in local.azs : cidrsubnet(var.vpc_cidr, 4, i)]\n  public_subnets  = [for i, az in local.azs : cidrsubnet(var.vpc_cidr, 4, i + 10)]\n\n  enable_nat_gateway = var.enable_nat_gateway\n  single_nat_gateway = var.single_nat_gateway\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  # Keep networking minimal; VPC endpoints can be added later if you want to avoid NAT/public egress.\n\n  tags = var.tags\n}\n\nresource \"aws_security_group\" \"batch\" {\n  count = var.create_vpc ? 1 : 0\n\n  name        = \"${local.name_prefix}-batch\"\n  description = \"Security group for AWS Batch Fargate tasks\"\n  vpc_id      = module.vpc.vpc_id\n\n  # No inbound required for typical batch jobs\n  ingress = []\n\n  # Allow all egress; if you want to restrict, do so carefully (S3 gateway endpoint still uses route tables)\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = var.tags\n}\n\nlocals {\n  effective_subnet_ids = var.create_vpc ? module.vpc.private_subnets : var.subnet_ids\n  effective_sg_ids     = var.create_vpc ? [aws_security_group.batch[0].id] : var.security_group_ids\n}\n"
    },
    {
      "name": "s3.tf",
      "content": "resource \"aws_kms_key\" \"s3\" {\n  description             = \"KMS key for S3 bucket encryption (${local.name_prefix})\"\n  deletion_window_in_days = 30\n  enable_key_rotation     = true\n\n  policy = data.aws_iam_policy_document.kms_key.json\n\n  tags = var.tags\n}\n\nresource \"aws_kms_alias\" \"s3\" {\n  name          = \"alias/${local.name_prefix}-s3\"\n  target_key_id = aws_kms_key.s3.key_id\n}\n\ndata \"aws_iam_policy_document\" \"kms_key\" {\n  statement {\n    sid = \"EnableRootPermissions\"\n\n    principals {\n      type        = \"AWS\"\n      identifiers = [\"arn:${data.aws_partition.current.partition}:iam::${data.aws_caller_identity.current.account_id}:root\"]\n    }\n\n    actions   = [\"kms:*\"]\n    resources = [\"*\"]\n  }\n}\n\nresource \"aws_s3_bucket\" \"landing\" {\n  bucket        = var.s3_bucket_name\n  force_destroy = false\n\n  tags = var.tags\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"landing\" {\n  bucket = aws_s3_bucket.landing.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_versioning\" \"landing\" {\n  bucket = aws_s3_bucket.landing.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"landing\" {\n  bucket = aws_s3_bucket.landing.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = \"aws:kms\"\n      kms_master_key_id = aws_kms_key.s3.arn\n    }\n\n    bucket_key_enabled = true\n  }\n}\n\nresource \"aws_s3_bucket_ownership_controls\" \"landing\" {\n  bucket = aws_s3_bucket.landing.id\n\n  rule {\n    object_ownership = \"BucketOwnerEnforced\"\n  }\n}\n\nresource \"aws_s3_bucket_lifecycle_configuration\" \"landing\" {\n  count  = (var.s3_lifecycle_days_to_glacier != null || var.s3_lifecycle_days_to_expire != null) ? 1 : 0\n  bucket = aws_s3_bucket.landing.id\n\n  rule {\n    id     = \"lifecycle\"\n    status = \"Enabled\"\n\n    filter {\n      prefix = var.s3_prefix\n    }\n\n    dynamic \"transition\" {\n      for_each = var.s3_lifecycle_days_to_glacier != null ? [1] : []\n      content {\n        days          = var.s3_lifecycle_days_to_glacier\n        storage_class = \"GLACIER\"\n      }\n    }\n\n    dynamic \"expiration\" {\n      for_each = var.s3_lifecycle_days_to_expire != null ? [1] : []\n      content {\n        days = var.s3_lifecycle_days_to_expire\n      }\n    }\n  }\n}\n"
    },
    {
      "name": "ecr.tf",
      "content": "resource \"aws_ecr_repository\" \"etl\" {\n  name                 = local.ecr_repo_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n\n  tags = var.tags\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"etl\" {\n  repository = aws_ecr_repository.etl.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last 30 images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = 30\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "iam.tf",
      "content": "data \"aws_iam_policy_document\" \"batch_assume\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"batch.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"batch_service\" {\n  name               = \"${local.name_prefix}-batch-service\"\n  assume_role_policy = data.aws_iam_policy_document.batch_assume.json\n\n  tags = var.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"batch_service\" {\n  role       = aws_iam_role.batch_service.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/service-role/AWSBatchServiceRole\"\n}\n\n# Execution role for ECS tasks launched by AWS Batch (pull image, write logs)\n\ndata \"aws_iam_policy_document\" \"ecs_task_assume\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"ecs-tasks.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"ecs_task_execution\" {\n  name               = \"${local.name_prefix}-ecs-task-exec\"\n  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume.json\n\n  tags = var.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecs_task_execution\" {\n  role       = aws_iam_role.ecs_task_execution.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\n# Job role: least-privilege access to S3 (and KMS) for awswrangler\nresource \"aws_iam_role\" \"job\" {\n  name               = \"${local.name_prefix}-etl-job\"\n  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume.json\n\n  tags = var.tags\n}\n\ndata \"aws_iam_policy_document\" \"job\" {\n  statement {\n    sid = \"S3ListBucket\"\n\n    actions = [\n      \"s3:ListBucket\",\n      \"s3:GetBucketLocation\"\n    ]\n\n    resources = [aws_s3_bucket.landing.arn]\n\n    condition {\n      test     = \"StringLike\"\n      variable = \"s3:prefix\"\n      values = [\n        var.s3_prefix == \"\" ? \"*\" : \"${local.s3_prefix_for_policy}*\"\n      ]\n    }\n  }\n\n  statement {\n    sid = \"S3ObjectRW\"\n\n    actions = [\n      \"s3:PutObject\",\n      \"s3:AbortMultipartUpload\",\n      \"s3:ListBucketMultipartUploads\",\n      \"s3:ListMultipartUploadParts\",\n      \"s3:GetObject\",\n      \"s3:DeleteObject\"\n    ]\n\n    resources = [\n      \"${aws_s3_bucket.landing.arn}/${var.s3_prefix == \"\" ? \"*\" : \"${local.s3_prefix_for_policy}*\"}\"\n    ]\n  }\n\n  statement {\n    sid = \"KmsForS3\"\n\n    actions = [\n      \"kms:Encrypt\",\n      \"kms:Decrypt\",\n      \"kms:ReEncrypt*\",\n      \"kms:GenerateDataKey*\",\n      \"kms:DescribeKey\"\n    ]\n\n    resources = [aws_kms_key.s3.arn]\n  }\n}\n\nresource \"aws_iam_policy\" \"job\" {\n  name   = \"${local.name_prefix}-etl-job\"\n  policy = data.aws_iam_policy_document.job.json\n\n  tags = var.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"job\" {\n  role       = aws_iam_role.job.name\n  policy_arn = aws_iam_policy.job.arn\n}\n\n# Restrict bucket access to the job role (and account root). This is optional but recommended.\ndata \"aws_iam_policy_document\" \"bucket_policy\" {\n  statement {\n    sid = \"AllowAccountRoot\"\n\n    principals {\n      type        = \"AWS\"\n      identifiers = [\"arn:${data.aws_partition.current.partition}:iam::${data.aws_caller_identity.current.account_id}:root\"]\n    }\n\n    actions = [\"s3:*\"]\n\n    resources = [\n      aws_s3_bucket.landing.arn,\n      \"${aws_s3_bucket.landing.arn}/*\"\n    ]\n  }\n\n  statement {\n    sid = \"AllowJobRoleAccess\"\n\n    principals {\n      type        = \"AWS\"\n      identifiers = [aws_iam_role.job.arn]\n    }\n\n    actions = [\n      \"s3:ListBucket\",\n      \"s3:GetBucketLocation\",\n      \"s3:GetObject\",\n      \"s3:PutObject\",\n      \"s3:DeleteObject\",\n      \"s3:AbortMultipartUpload\",\n      \"s3:ListBucketMultipartUploads\",\n      \"s3:ListMultipartUploadParts\"\n    ]\n\n    resources = [\n      aws_s3_bucket.landing.arn,\n      \"${aws_s3_bucket.landing.arn}/${var.s3_prefix == \"\" ? \"*\" : \"${local.s3_prefix_for_policy}*\"}\"\n    ]\n  }\n\n  statement {\n    sid = \"DenyInsecureTransport\"\n\n    principals {\n      type        = \"*\"\n      identifiers = [\"*\"]\n    }\n\n    actions = [\"s3:*\"]\n\n    resources = [\n      aws_s3_bucket.landing.arn,\n      \"${aws_s3_bucket.landing.arn}/*\"\n    ]\n\n    condition {\n      test     = \"Bool\"\n      variable = \"aws:SecureTransport\"\n      values   = [\"false\"]\n    }\n\n    effect = \"Deny\"\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"landing\" {\n  bucket = aws_s3_bucket.landing.id\n  policy = data.aws_iam_policy_document.bucket_policy.json\n\n  depends_on = [aws_s3_bucket_public_access_block.landing]\n}\n"
    },
    {
      "name": "logs.tf",
      "content": "resource \"aws_cloudwatch_log_group\" \"etl\" {\n  name              = \"/aws/batch/${local.name_prefix}-etl\"\n  retention_in_days = 30\n\n  tags = var.tags\n}\n"
    },
    {
      "name": "batch.tf",
      "content": "resource \"aws_batch_compute_environment\" \"this\" {\n  name = \"${local.name_prefix}-ce\"\n  type = \"MANAGED\"\n\n  service_role = aws_iam_role.batch_service.arn\n\n  compute_resources {\n    type               = \"FARGATE\"\n    max_vcpus          = 16\n    subnets            = local.effective_subnet_ids\n    security_group_ids = local.effective_sg_ids\n\n    # Fargate requires this to be set for some accounts/regions\n    # allocation_strategy = \"BEST_FIT_PROGRESSIVE\"\n  }\n\n  depends_on = [aws_iam_role_policy_attachment.batch_service]\n\n  tags = var.tags\n}\n\nresource \"aws_batch_job_queue\" \"this\" {\n  name     = \"${local.name_prefix}-queue\"\n  state    = \"ENABLED\"\n  priority = 1\n\n  compute_environment_order {\n    order               = 1\n    compute_environment = aws_batch_compute_environment.this.arn\n  }\n\n  tags = var.tags\n}\n\nresource \"aws_batch_job_definition\" \"etl\" {\n  name = \"${local.name_prefix}-etl\"\n  type = \"container\"\n\n  platform_capabilities = [\"FARGATE\"]\n\n  container_properties = jsonencode({\n    image = var.container_image\n\n    resourceRequirements = [\n      { type = \"VCPU\", value = tostring(var.job_vcpus) },\n      { type = \"MEMORY\", value = tostring(var.job_memory) }\n    ]\n\n    command = var.job_command\n\n    environment = [\n      for k, v in merge(\n        {\n          S3_BUCKET  = aws_s3_bucket.landing.bucket\n          S3_PREFIX  = var.s3_prefix\n          AWS_REGION = var.aws_region\n        },\n        var.job_environment\n      ) : {\n        name  = k\n        value = v\n      }\n    ]\n\n    executionRoleArn = aws_iam_role.ecs_task_execution.arn\n    jobRoleArn       = aws_iam_role.job.arn\n\n    logConfiguration = {\n      logDriver = \"awslogs\"\n      options = {\n        awslogs-group         = aws_cloudwatch_log_group.etl.name\n        awslogs-region        = var.aws_region\n        awslogs-stream-prefix = \"etl\"\n      }\n    }\n\n    networkConfiguration = {\n      assignPublicIp = \"DISABLED\"\n    }\n  })\n\n  tags = var.tags\n}\n"
    },
    {
      "name": "eventbridge.tf",
      "content": "resource \"aws_iam_role\" \"events_invoke_batch\" {\n  name = \"${local.name_prefix}-events-batch\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"events.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n\n  tags = var.tags\n}\n\nresource \"aws_iam_role_policy\" \"events_invoke_batch\" {\n  name = \"${local.name_prefix}-events-batch\"\n  role = aws_iam_role.events_invoke_batch.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"batch:SubmitJob\"\n        ]\n        Resource = [\n          aws_batch_job_definition.etl.arn,\n          aws_batch_job_queue.this.arn\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_cloudwatch_event_rule\" \"schedule\" {\n  name                = \"${local.name_prefix}-etl-schedule\"\n  description         = \"Schedule for ETL Batch job\"\n  schedule_expression = var.schedule_expression\n\n  tags = var.tags\n}\n\nresource \"aws_cloudwatch_event_target\" \"batch\" {\n  rule     = aws_cloudwatch_event_rule.schedule.name\n  arn      = aws_batch_job_queue.this.arn\n  role_arn = aws_iam_role.events_invoke_batch.arn\n\n  batch_target {\n    job_definition = aws_batch_job_definition.etl.arn\n    job_name       = \"${local.name_prefix}-etl\"\n  }\n}\n"
    },
    {
      "name": "monitoring.tf",
      "content": "resource \"aws_sns_topic\" \"alerts\" {\n  name = \"${local.name_prefix}-alerts\"\n  tags = var.tags\n}\n\nresource \"aws_sns_topic_subscription\" \"email\" {\n  count = var.sns_email != null ? 1 : 0\n\n  topic_arn = aws_sns_topic.alerts.arn\n  protocol  = \"email\"\n  endpoint  = var.sns_email\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"batch_failed\" {\n  alarm_name          = \"${local.name_prefix}-batch-failed\"\n  alarm_description   = \"Alarm when the ETL Batch job fails\"\n  comparison_operator = \"GreaterThanOrEqualToThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"FailedJobs\"\n  namespace           = \"AWS/Batch\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 1\n\n  dimensions = {\n    JobQueue = aws_batch_job_queue.this.name\n  }\n\n  alarm_actions = [aws_sns_topic.alerts.arn]\n\n  tags = var.tags\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"s3_bucket_name\" {\n  value       = aws_s3_bucket.landing.bucket\n  description = \"S3 landing bucket name\"\n}\n\noutput \"kms_key_arn\" {\n  value       = aws_kms_key.s3.arn\n  description = \"KMS key ARN used for S3 encryption\"\n}\n\noutput \"ecr_repository_url\" {\n  value       = aws_ecr_repository.etl.repository_url\n  description = \"ECR repository URL\"\n}\n\noutput \"batch_job_queue_name\" {\n  value       = aws_batch_job_queue.this.name\n  description = \"AWS Batch job queue name\"\n}\n\noutput \"batch_job_definition_arn\" {\n  value       = aws_batch_job_definition.etl.arn\n  description = \"AWS Batch job definition ARN\"\n}\n\noutput \"event_rule_name\" {\n  value       = aws_cloudwatch_event_rule.schedule.name\n  description = \"EventBridge schedule rule name\"\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "aws_region    = \"us-east-1\"\nproject_name  = \"etl-pipeline\"\nenvironment   = \"dev\"\n\n# Provide the image you built/pushed to ECR (or elsewhere)\ncontainer_image = \"123456789012.dkr.ecr.us-east-1.amazonaws.com/etl-pipeline-dev-etl:latest\"\n\n# Optional: restrict ETL writes to a prefix\ns3_prefix = \"landing/\"\n\n# If your ETL calls public APIs, enable NAT\nenable_nat_gateway = false\n\n# Run daily\nschedule_expression = \"rate(1 day)\"\n\n# Optional email alerts\n# sns_email = \"you@example.com\"\n"
    },
    {
      "name": ".terraform.lock.hcl",
      "content": "# This file is maintained automatically by \"terraform init\".\n# Manual edits may be lost in future updates.\n\nprovider \"registry.terraform.io/hashicorp/aws\" {\n  version     = \"6.28.0\"\n  constraints = \"~> 6.0, >= 6.28.0\"\n  hashes = [\n    \"h1:RwoFuX1yGMVaKJaUmXDKklEaQ/yUCEdt5k2kz+/g08c=\",\n    \"zh:0ba0d5eb6e0c6a933eb2befe3cdbf22b58fbc0337bf138f95bf0e8bb6e6df93e\",\n    \"zh:23eacdd4e6db32cf0ff2ce189461bdbb62e46513978d33c5de4decc4670870ec\",\n    \"zh:307b06a15fc00a8e6fd243abde2cbe5112e9d40371542665b91bec1018dd6e3c\",\n    \"zh:37a02d5b45a9d050b9642c9e2e268297254192280df72f6e46641daca52e40ec\",\n    \"zh:3da866639f07d92e734557d673092719c33ede80f4276c835bf7f231a669aa33\",\n    \"zh:480060b0ba310d0f6b6a14d60b276698cb103c48fd2f7e2802ae47c963995ec6\",\n    \"zh:57796453455c20db80d9168edbf125bf6180e1aae869de1546a2be58e4e405ec\",\n    \"zh:69139cba772d4df8de87598d8d8a2b1b4b254866db046c061dccc79edb14e6b9\",\n    \"zh:7312763259b859ff911c5452ca8bdf7d0be6231c5ea0de2df8f09d51770900ac\",\n    \"zh:8d2d6f4015d3c155d7eb53e36f019a729aefb46ebfe13f3a637327d3a1402ecc\",\n    \"zh:94ce589275c77308e6253f607de96919b840c2dd36c44aa798f693c9dd81af42\",\n    \"zh:9b12af85486a96aedd8d7984b0ff811a4b42e3d88dad1a3fb4c0b580d04fa425\",\n    \"zh:adaceec6a1bf4f5df1e12bd72cf52b72087c72efed078aef636f8988325b1a8b\",\n    \"zh:d37be1ce187d94fd9df7b13a717c219964cd835c946243f096c6b230cdfd7e92\",\n    \"zh:fe6205b5ca2ff36e68395cb8d3ae10a3728f405cdbcd46b206a515e1ebcf17a1\",\n  ]\n}\n"
    }
  ]
}