{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.6\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "data.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "locals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # /20 per subnet gives room for growth\n  public_subnet_cidrs  = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 4, i)]\n  private_subnet_cidrs = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 4, i + var.az_count)]\n\n  common_tags = {\n    Project     = var.project_name\n    Environment = var.environment\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Project/name prefix used for resource naming.\"\n  type        = string\n  default     = \"clickhouse-challenge\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"eu-north-1\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 or 3).\"\n  type        = number\n  default     = 2\n  validation {\n    condition     = contains([2, 3], var.az_count)\n    error_message = \"az_count must be 2 or 3.\"\n  }\n}\n\nvariable \"enable_nat_gateway\" {\n  description = \"Whether to create NAT Gateway(s) for private subnet egress (needed for calling external APIs from private subnets).\"\n  type        = bool\n  default     = true\n}\n\nvariable \"single_nat_gateway\" {\n  description = \"If true, create a single NAT Gateway (cheaper). If false, create one per AZ (more resilient).\"\n  type        = bool\n  default     = true\n}\n\nvariable \"db_instance_class\" {\n  description = \"RDS instance class for PostgreSQL.\"\n  type        = string\n  default     = \"db.t4g.micro\"\n}\n\nvariable \"db_allocated_storage\" {\n  description = \"RDS allocated storage in GB.\"\n  type        = number\n  default     = 20\n}\n\nvariable \"db_name\" {\n  description = \"Initial database name.\"\n  type        = string\n  default     = \"defaultdb\"\n}\n\nvariable \"db_username\" {\n  description = \"Master username for PostgreSQL.\"\n  type        = string\n  default     = \"appuser\"\n}\n\nvariable \"msk_kafka_version\" {\n  description = \"Kafka version for MSK.\"\n  type        = string\n  default     = \"3.6.0\"\n}\n\nvariable \"msk_broker_instance_type\" {\n  description = \"MSK broker instance type.\"\n  type        = string\n  default     = \"kafka.t3.small\"\n}\n\nvariable \"msk_broker_volume_size\" {\n  description = \"EBS volume size (GiB) per broker.\"\n  type        = number\n  default     = 100\n}\n\nvariable \"msk_number_of_brokers\" {\n  description = \"Number of MSK brokers. Must be a multiple of the number of subnets used.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"redshift_admin_username\" {\n  description = \"Redshift Serverless admin username.\"\n  type        = string\n  default     = \"admin\"\n}\n\nvariable \"redshift_base_capacity\" {\n  description = \"Redshift Serverless base capacity in RPUs.\"\n  type        = number\n  default     = 8\n}\n"
    },
    {
      "name": "network.tf",
      "content": "module \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = local.name_prefix\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  public_subnets  = local.public_subnet_cidrs\n  private_subnets = local.private_subnet_cidrs\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  enable_nat_gateway = var.enable_nat_gateway\n  single_nat_gateway = var.single_nat_gateway\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = 1\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = 1\n  }\n\n  tags = local.common_tags\n}\n\n# Gateway endpoint for S3 (keeps S3 traffic off the public internet)\nresource \"aws_vpc_endpoint\" \"s3\" {\n  vpc_id            = module.vpc.vpc_id\n  service_name      = \"com.amazonaws.${var.aws_region}.s3\"\n  vpc_endpoint_type = \"Gateway\"\n\n  route_table_ids = concat(module.vpc.private_route_table_ids, module.vpc.public_route_table_ids)\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-s3-endpoint\" })\n}\n"
    },
    {
      "name": "kms.tf",
      "content": "resource \"aws_kms_key\" \"main\" {\n  description             = \"KMS key for ${local.name_prefix}\"\n  deletion_window_in_days = 7\n  enable_key_rotation     = true\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-kms\" })\n}\n\nresource \"aws_kms_alias\" \"main\" {\n  name          = \"alias/${local.name_prefix}\"\n  target_key_id = aws_kms_key.main.key_id\n}\n"
    },
    {
      "name": "s3.tf",
      "content": "resource \"random_id\" \"bucket_suffix\" {\n  byte_length = 4\n}\n\nresource \"aws_s3_bucket\" \"data\" {\n  bucket        = \"${local.name_prefix}-data-${random_id.bucket_suffix.hex}\"\n  force_destroy = false\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-data\" })\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"data\" {\n  bucket = aws_s3_bucket.data.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_versioning\" \"data\" {\n  bucket = aws_s3_bucket.data.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"data\" {\n  bucket = aws_s3_bucket.data.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = \"aws:kms\"\n      kms_master_key_id = aws_kms_key.main.arn\n    }\n  }\n}\n\nresource \"aws_s3_bucket_lifecycle_configuration\" \"data\" {\n  bucket = aws_s3_bucket.data.id\n\n  rule {\n    id     = \"expire-raw\"\n    status = \"Enabled\"\n\n    filter {\n      prefix = \"raw/\"\n    }\n\n    expiration {\n      days = 30\n    }\n  }\n}\n"
    },
    {
      "name": "secrets.tf",
      "content": "resource \"random_password\" \"db\" {\n  length           = 24\n  special          = true\n  override_special = \"!#$%&*()-_=+[]{}<>:?\"\n}\n\nresource \"aws_secretsmanager_secret\" \"postgres\" {\n  name                    = \"${local.name_prefix}/postgres\"\n  recovery_window_in_days = 7\n  kms_key_id              = aws_kms_key.main.arn\n\n  tags = local.common_tags\n}\n\nresource \"aws_secretsmanager_secret_version\" \"postgres\" {\n  secret_id = aws_secretsmanager_secret.postgres.id\n\n  secret_string = jsonencode({\n    username = var.db_username\n    password = random_password.db.result\n    dbname   = var.db_name\n  })\n}\n\nresource \"random_password\" \"redshift\" {\n  length           = 24\n  special          = true\n  override_special = \"!#$%&*()-_=+[]{}<>:?\"\n}\n\nresource \"aws_secretsmanager_secret\" \"redshift\" {\n  name                    = \"${local.name_prefix}/redshift\"\n  recovery_window_in_days = 7\n  kms_key_id              = aws_kms_key.main.arn\n\n  tags = local.common_tags\n}\n\nresource \"aws_secretsmanager_secret_version\" \"redshift\" {\n  secret_id = aws_secretsmanager_secret.redshift.id\n\n  secret_string = jsonencode({\n    username = var.redshift_admin_username\n    password = random_password.redshift.result\n  })\n}\n"
    },
    {
      "name": "security_groups.tf",
      "content": "resource \"aws_security_group\" \"rds\" {\n  name        = \"${local.name_prefix}-rds\"\n  description = \"RDS PostgreSQL access\"\n  vpc_id      = module.vpc.vpc_id\n\n  # Ingress is intentionally empty; allow from clients via explicit rules.\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-rds\" })\n}\n\nresource \"aws_security_group\" \"msk\" {\n  name        = \"${local.name_prefix}-msk\"\n  description = \"MSK broker access\"\n  vpc_id      = module.vpc.vpc_id\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-msk\" })\n}\n\nresource \"aws_security_group\" \"redshift\" {\n  name        = \"${local.name_prefix}-redshift\"\n  description = \"Redshift Serverless access\"\n  vpc_id      = module.vpc.vpc_id\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-redshift\" })\n}\n\n# Allow private-subnet workloads (e.g., SageMaker apps in VPC) to reach RDS\nresource \"aws_security_group_rule\" \"rds_from_private\" {\n  type              = \"ingress\"\n  security_group_id = aws_security_group.rds.id\n\n  from_port   = 5432\n  to_port     = 5432\n  protocol    = \"tcp\"\n  cidr_blocks = module.vpc.private_subnets_cidr_blocks\n  description = \"PostgreSQL from private subnets\"\n}\n\n# Allow private-subnet workloads to reach MSK TLS port\nresource \"aws_security_group_rule\" \"msk_from_private_tls\" {\n  type              = \"ingress\"\n  security_group_id = aws_security_group.msk.id\n\n  from_port   = 9094\n  to_port     = 9094\n  protocol    = \"tcp\"\n  cidr_blocks = module.vpc.private_subnets_cidr_blocks\n  description = \"Kafka TLS from private subnets\"\n}\n\n# Allow private-subnet workloads to reach Redshift Serverless\nresource \"aws_security_group_rule\" \"redshift_from_private\" {\n  type              = \"ingress\"\n  security_group_id = aws_security_group.redshift.id\n\n  from_port   = 5439\n  to_port     = 5439\n  protocol    = \"tcp\"\n  cidr_blocks = module.vpc.private_subnets_cidr_blocks\n  description = \"Redshift from private subnets\"\n}\n"
    },
    {
      "name": "rds.tf",
      "content": "resource \"aws_db_subnet_group\" \"postgres\" {\n  name       = \"${local.name_prefix}-postgres\"\n  subnet_ids = module.vpc.private_subnets\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-postgres\" })\n}\n\nresource \"aws_db_instance\" \"postgres\" {\n  identifier = \"${local.name_prefix}-postgres\"\n\n  engine         = \"postgres\"\n  engine_version = \"16.3\"\n  instance_class = var.db_instance_class\n\n  allocated_storage = var.db_allocated_storage\n  storage_type      = \"gp3\"\n  storage_encrypted = true\n  kms_key_id        = aws_kms_key.main.arn\n\n  db_name  = var.db_name\n  username = var.db_username\n  password = random_password.db.result\n\n  multi_az               = true\n  publicly_accessible    = false\n  db_subnet_group_name   = aws_db_subnet_group.postgres.name\n  vpc_security_group_ids = [aws_security_group.rds.id]\n\n  backup_retention_period = 7\n  deletion_protection     = false\n  skip_final_snapshot     = true\n\n  enabled_cloudwatch_logs_exports = [\"postgresql\", \"upgrade\"]\n\n  tags = local.common_tags\n}\n"
    },
    {
      "name": "msk.tf",
      "content": "resource \"aws_msk_configuration\" \"main\" {\n  name           = \"${local.name_prefix}-msk\"\n  kafka_versions = [var.msk_kafka_version]\n\n  server_properties = <<-EOT\n    auto.create.topics.enable = true\n    default.replication.factor = 2\n    min.insync.replicas = 1\n    num.partitions = 3\n  EOT\n}\n\nresource \"aws_msk_cluster\" \"main\" {\n  cluster_name           = \"${local.name_prefix}-msk\"\n  kafka_version          = var.msk_kafka_version\n  number_of_broker_nodes = var.msk_number_of_brokers\n\n  broker_node_group_info {\n    instance_type   = var.msk_broker_instance_type\n    client_subnets  = module.vpc.private_subnets\n    security_groups = [aws_security_group.msk.id]\n\n    storage_info {\n      ebs_storage_info {\n        volume_size = var.msk_broker_volume_size\n      }\n    }\n  }\n\n  encryption_info {\n    encryption_at_rest_kms_key_arn = aws_kms_key.main.arn\n\n    encryption_in_transit {\n      client_broker = \"TLS\"\n      in_cluster    = true\n    }\n  }\n\n  client_authentication {\n    unauthenticated = true\n  }\n\n  configuration_info {\n    arn      = aws_msk_configuration.main.arn\n    revision = aws_msk_configuration.main.latest_revision\n  }\n\n  logging_info {\n    broker_logs {\n      cloudwatch_logs {\n        enabled   = true\n        log_group = aws_cloudwatch_log_group.msk.name\n      }\n    }\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_cloudwatch_log_group\" \"msk\" {\n  name              = \"/aws/msk/${local.name_prefix}\"\n  retention_in_days = 14\n  kms_key_id        = aws_kms_key.main.arn\n\n  tags = local.common_tags\n}\n"
    },
    {
      "name": "redshift_serverless.tf",
      "content": "resource \"aws_redshiftserverless_namespace\" \"main\" {\n  namespace_name = \"${replace(local.name_prefix, \"-\", \"_\")}_ns\"\n\n  admin_username      = var.redshift_admin_username\n  admin_user_password = random_password.redshift.result\n\n  kms_key_id = aws_kms_key.main.arn\n\n  tags = local.common_tags\n}\n\nresource \"aws_redshiftserverless_workgroup\" \"main\" {\n  workgroup_name = \"${replace(local.name_prefix, \"-\", \"_\")}_wg\"\n  namespace_name = aws_redshiftserverless_namespace.main.namespace_name\n\n  base_capacity = var.redshift_base_capacity\n\n  subnet_ids         = module.vpc.private_subnets\n  security_group_ids = [aws_security_group.redshift.id]\n\n  publicly_accessible = false\n\n  tags = local.common_tags\n}\n"
    },
    {
      "name": "iam.tf",
      "content": "data \"aws_iam_policy_document\" \"firehose_assume\" {\n  statement {\n    effect = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"firehose.amazonaws.com\"]\n    }\n    actions = [\"sts:AssumeRole\"]\n  }\n}\n\nresource \"aws_iam_role\" \"firehose\" {\n  name               = \"${local.name_prefix}-firehose\"\n  assume_role_policy = data.aws_iam_policy_document.firehose_assume.json\n\n  tags = local.common_tags\n}\n\ndata \"aws_iam_policy_document\" \"firehose\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"s3:AbortMultipartUpload\",\n      \"s3:GetBucketLocation\",\n      \"s3:GetObject\",\n      \"s3:ListBucket\",\n      \"s3:ListBucketMultipartUploads\",\n      \"s3:PutObject\"\n    ]\n    resources = [\n      aws_s3_bucket.data.arn,\n      \"${aws_s3_bucket.data.arn}/*\"\n    ]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"kms:Decrypt\",\n      \"kms:Encrypt\",\n      \"kms:GenerateDataKey\",\n      \"kms:DescribeKey\"\n    ]\n    resources = [aws_kms_key.main.arn]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"logs:PutLogEvents\"\n    ]\n    resources = [\n      \"${aws_cloudwatch_log_group.firehose.arn}:*\"\n    ]\n  }\n}\n\nresource \"aws_iam_role_policy\" \"firehose\" {\n  name   = \"${local.name_prefix}-firehose\"\n  role   = aws_iam_role.firehose.id\n  policy = data.aws_iam_policy_document.firehose.json\n}\n"
    },
    {
      "name": "firehose.tf",
      "content": "resource \"aws_cloudwatch_log_group\" \"firehose\" {\n  name              = \"/aws/kinesisfirehose/${local.name_prefix}\"\n  retention_in_days = 14\n  kms_key_id        = aws_kms_key.main.arn\n\n  tags = local.common_tags\n}\n\n# NOTE: MSK as a Firehose source is supported, but configuration details vary by region and provider version.\n# This resource is included as a minimal \"raw landing\" stream to S3.\nresource \"aws_kinesis_firehose_delivery_stream\" \"raw_to_s3\" {\n  name        = \"${local.name_prefix}-raw\"\n  destination = \"extended_s3\"\n\n  extended_s3_configuration {\n    role_arn   = aws_iam_role.firehose.arn\n    bucket_arn = aws_s3_bucket.data.arn\n\n    prefix              = \"raw/!{timestamp:yyyy/MM/dd}/\"\n    error_output_prefix = \"raw-errors/!{timestamp:yyyy/MM/dd}/\"\n\n    buffering_size     = 5\n    buffering_interval = 60\n\n    compression_format = \"GZIP\"\n\n    cloudwatch_logging_options {\n      enabled         = true\n      log_group_name  = aws_cloudwatch_log_group.firehose.name\n      log_stream_name = \"S3Delivery\"\n    }\n\n    kms_key_arn = aws_kms_key.main.arn\n  }\n\n  tags = local.common_tags\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value = module.vpc.vpc_id\n}\n\noutput \"private_subnet_ids\" {\n  value = module.vpc.private_subnets\n}\n\noutput \"s3_data_bucket\" {\n  value = aws_s3_bucket.data.bucket\n}\n\noutput \"postgres_endpoint\" {\n  value = aws_db_instance.postgres.address\n}\n\noutput \"postgres_port\" {\n  value = aws_db_instance.postgres.port\n}\n\noutput \"postgres_secret_arn\" {\n  value = aws_secretsmanager_secret.postgres.arn\n}\n\noutput \"msk_cluster_arn\" {\n  value = aws_msk_cluster.main.arn\n}\n\noutput \"msk_bootstrap_brokers_tls\" {\n  value = aws_msk_cluster.main.bootstrap_brokers_tls\n}\n\noutput \"redshift_workgroup_endpoint\" {\n  value = aws_redshiftserverless_workgroup.main.endpoint\n}\n\noutput \"redshift_secret_arn\" {\n  value = aws_secretsmanager_secret.redshift.arn\n}\n\noutput \"firehose_name\" {\n  value = aws_kinesis_firehose_delivery_stream.raw_to_s3.name\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "project_name = \"clickhouse-challenge\"\nenvironment  = \"dev\"\naws_region   = \"eu-north-1\"\n\n# Networking\nvpc_cidr            = \"10.20.0.0/16\"\naz_count            = 2\nenable_nat_gateway  = true\nsingle_nat_gateway  = true\n\n# RDS\ndb_instance_class     = \"db.t4g.micro\"\ndb_allocated_storage  = 20\ndb_name               = \"defaultdb\"\ndb_username           = \"appuser\"\n\n# MSK\nmsk_kafka_version        = \"3.6.0\"\nmsk_broker_instance_type = \"kafka.t3.small\"\nmsk_broker_volume_size   = 100\nmsk_number_of_brokers    = 2\n\n# Redshift Serverless\nredshift_admin_username = \"admin\"\nredshift_base_capacity  = 8\n"
    }
  ]
}