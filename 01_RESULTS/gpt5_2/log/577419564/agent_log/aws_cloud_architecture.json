{
  "aws_architecture_description": "## Target AWS architecture (lean, secure, scalable)\n\n### 1) Environments and accounts\n- Create **separate AWS accounts** (recommended) or at least separate **VPCs** for **dev** and **stage** to mirror `dev01` and `stage01`.\n- Use the same deployment pattern in both environments; only sizing and scaling differ.\n\n### 2) Networking (per environment)\n- **One VPC** spanning **2 Availability Zones**.\n- **Public subnets (2 AZs):** only for the internet-facing load balancer.\n- **Private subnets (2 AZs):** for the application compute (containers) and any internal services.\n- **NAT Gateway (per AZ or single for cost):** private subnets can reach the internet to pull images/patches.\n- **VPC endpoints** (recommended) to reduce NAT usage and keep traffic private:\n  - ECR (api + dkr), S3 (gateway endpoint), CloudWatch Logs.\n\n### 3) Container runtime for Tomcat + WAR\nBecause the app is already containerized (Tomcat + WAR baked into an image), the cleanest AWS runtime is:\n\n**Option A (recommended): Amazon ECS on AWS Fargate**\n- Run the Tomcat container as an **ECS Service** (desired count 1+).\n- Use **Application Load Balancer (ALB)** to expose HTTP/HTTPS.\n- Map ALB listener (80/443) to container port **8080**.\n- Configure **health checks** (e.g., `/hello` or a dedicated `/health` endpoint if you add one).\n- Scale via **ECS Service Auto Scaling** (CPU/Memory/ALB request count).\n\n**Why this fits your current system:** you already build a Docker image; Fargate removes the need to manage “dev01/stage01 VMs” and Docker Engine installation that Ansible currently handles.\n\n**Option B (VM-like, closest to current Ansible model): ECS on EC2 or plain EC2 + Docker**\n- If you must keep Ansible-driven host configuration, use an **EC2 Auto Scaling Group** and run Docker containers on instances.\n- Still front with an **ALB**.\n- This is more operational overhead than Fargate.\n\n### 4) Image registry and build pipeline\n- Store container images in **Amazon ECR**.\n- Replace the “CI/Build Host” with a managed pipeline:\n  - **AWS CodePipeline** orchestrates.\n  - **AWS CodeBuild** runs Maven build + Docker multi-stage build and pushes to ECR.\n  - Deploy step updates the ECS service (rolling deployment).\n- Source can be GitHub/Bitbucket/CodeCommit.\n\n### 5) TLS, DNS, and edge\n- Use **ACM** to issue TLS certs.\n- Use **Route 53** for DNS (e.g., `dev.example.com`, `stage.example.com`).\n- ALB terminates TLS (HTTPS 443) and forwards to ECS tasks on 8080.\n\n### 6) Secrets and configuration\n- Store environment variables / secrets in **AWS Secrets Manager** (or SSM Parameter Store for non-secrets).\n- ECS task definition references secrets securely.\n\n### 7) Observability and audit\n- Container logs to **CloudWatch Logs** (ECS log driver).\n- Metrics/alarms in **CloudWatch** (ALB 5xx, target health, ECS CPU/memory).\n- **CloudTrail** enabled for audit.\n\n### 8) Security posture (minimum best practices)\n- **Security groups**:\n  - ALB SG: inbound 443 (and optionally 80 for redirect), outbound to ECS tasks.\n  - ECS tasks SG: inbound only from ALB SG to port 8080; outbound as needed.\n- **IAM**:\n  - ECS task execution role (pull from ECR, write logs).\n  - CI roles for CodeBuild/CodePipeline.\n- Optional: **AWS WAF** on ALB if internet-exposed.\n\n### 9) Deployment strategy\n- **Rolling update** on ECS service (default) for stage.\n- For safer releases, use **CodeDeploy blue/green for ECS** (optional; adds resources).\n\n---\n\n## Resulting request flow\nUser → Route 53 DNS → ALB (HTTPS) → ECS Service (Fargate) → Tomcat container (port 8080) → `/hello`\n\nBuild: Source repo → CodePipeline → CodeBuild (Maven + Docker build) → ECR → ECS service update\n",
  "aws_resources": [
    "AWS Organizations (optional, for separate dev/stage accounts)",
    "Amazon VPC (per environment)",
    "VPC subnets: 2 public subnets (multi-AZ)",
    "VPC subnets: 2 private subnets (multi-AZ)",
    "Internet Gateway (IGW)",
    "NAT Gateway (1 or 2, depending on HA vs cost)",
    "Route tables (public and private)",
    "Security Groups (ALB SG, ECS tasks SG)",
    "Network ACLs (optional; default acceptable)",
    "VPC Endpoints: ECR (api)",
    "VPC Endpoints: ECR (dkr)",
    "VPC Endpoint: S3 (Gateway endpoint)",
    "VPC Endpoint: CloudWatch Logs (Interface endpoint)",
    "Elastic Load Balancing: Application Load Balancer (ALB)",
    "ALB Target Group (HTTP to port 8080)",
    "ALB Listeners: 443 (and 80 redirect optional)",
    "AWS Certificate Manager (ACM) certificate",
    "Amazon Route 53 Hosted Zone + DNS records (A/AAAA alias to ALB)",
    "Amazon ECS Cluster",
    "Amazon ECS Task Definition (Tomcat container, port 8080, env/secrets)",
    "Amazon ECS Service (desired count 1+, multi-AZ)",
    "AWS Fargate capacity (no separate resource, but required runtime choice)",
    "Amazon ECR Repository (container image)",
    "AWS CodeBuild Project (build WAR + Docker image, push to ECR)",
    "AWS CodePipeline Pipeline (source → build → deploy)",
    "IAM Roles/Policies: CodeBuild service role",
    "IAM Roles/Policies: CodePipeline service role",
    "IAM Roles/Policies: ECS task execution role",
    "IAM Roles/Policies: ECS task role (app permissions, if needed)",
    "AWS Secrets Manager (app secrets)",
    "AWS Systems Manager Parameter Store (non-secret config, optional)",
    "Amazon CloudWatch Logs Log Groups (ECS task logs)",
    "Amazon CloudWatch Alarms (ALB 5xx, target health, ECS CPU/memory)",
    "AWS CloudTrail (audit logging)",
    "AWS WAFv2 Web ACL (optional, if public internet exposure)"
  ]
}