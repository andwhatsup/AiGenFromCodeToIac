{
  "aws_architecture_description": "## Proposed high-level AWS architecture (lean, secure, scalable)\n\n### 1) Networking foundation\n- Create a dedicated **VPC** spanning **2 Availability Zones** for high availability.\n- Use **public subnets** (one per AZ) for the **Application Load Balancer (ALB)**.\n- Use **private subnets** (one per AZ) for the **EC2 Auto Scaling Group (ASG)** instances and **RDS**.\n- Add an **Internet Gateway (IGW)** for inbound/outbound internet access to the ALB.\n- Add **NAT Gateways** (one per AZ, or one to reduce cost) so private EC2 instances can reach **ECR** and OS package repos without being publicly reachable.\n- Configure **route tables**:\n  - Public subnets route `0.0.0.0/0` to the IGW.\n  - Private subnets route `0.0.0.0/0` to the NAT Gateway.\n\n### 2) Edge, TLS, and request routing\n- Deploy an **Application Load Balancer** in the public subnets.\n- Terminate **HTTPS (443)** at the ALB using an **ACM certificate**.\n- ALB forwards to a **Target Group** on **HTTP (e.g., 80)** to the EC2 instances.\n- Enable ALB access logs to S3 (optional but recommended).\n\n### 3) Compute layer (EC2 + Docker) \n- Run the application as a **Docker container** (Apache httpd serving static HTML) on EC2 instances managed by an **Auto Scaling Group**.\n- Use a **Launch Template** with:\n  - An **Amazon Linux** (or similar) AMI.\n  - **User data** to install Docker + bootstrap the instance (or keep your current Ansible approach).\n  - An **instance profile (IAM role)** allowing the instance to authenticate to **ECR** and pull images.\n- Place the ASG in **private subnets** across 2 AZs.\n- Configure **health checks** (ALB + EC2) and scaling policies (min=2, desired=2, scale-out on CPU/RequestCount).\n\n### 4) Container image registry\n- Store the built image in **Amazon ECR** (your existing `main-applications-registry`).\n- Use ECR lifecycle policies to expire old images.\n\n### 5) CI/CD and infrastructure automation\n- Keep **GitHub Actions** as the CI/CD orchestrator:\n  - Build/test the container.\n  - Push to ECR.\n  - Apply Terraform (state in S3).\n  - Trigger deployment.\n- Recommended hardening: replace long-lived AWS keys in GitHub Secrets with **GitHub OIDC → AWS IAM Role** assumption.\n- Deployment strategy (minimal change):\n  - GitHub Actions updates instances by running your existing scripts/Ansible over SSH.\n- Deployment strategy (recommended next step, still lean):\n  - Use **AWS Systems Manager (SSM)** Run Command instead of SSH/PEM keys (no inbound SSH required), and store parameters/secrets in **SSM Parameter Store** or **Secrets Manager**.\n\n### 6) Data layer (RDS MySQL)\n- If the DB is truly required (README indicates it):\n  - Deploy **Amazon RDS for MySQL** in **private subnets** (DB subnet group across 2 AZs).\n  - Restrict inbound to the DB security group from the **EC2 security group** only on **3306**.\n  - Store DB credentials in **Secrets Manager**.\n- If the site is purely static and DB is not used, omit RDS to reduce cost/complexity.\n\n### 7) Observability, security, and operations\n- **CloudWatch Logs** for instance/app logs (via CloudWatch Agent) and ALB metrics/alarms.\n- **CloudTrail** for account audit logging.\n- **AWS Config** (optional) for compliance drift detection.\n- **AWS WAF** on the ALB (optional but recommended for internet-facing endpoints).\n- Encrypt data at rest:\n  - EBS volumes with KMS.\n  - S3 buckets with SSE-KMS or SSE-S3.\n  - RDS storage encryption with KMS.\n\n---\n\n## Resulting request flow\n1. User → Internet → **ALB (HTTPS)**\n2. ALB → **EC2 instances in ASG (HTTP)**\n3. EC2 runs Docker → serves static HTML via **Apache httpd container**\n4. (Optional) EC2/app → **RDS MySQL** in private subnets\n5. GitHub Actions → **ECR** (push image) and → **S3** (Terraform state) and → **deploy** (SSH or SSM)\n",
  "aws_resources": [
    "VPC",
    "Internet Gateway (IGW)",
    "Public Subnets (2, across AZs)",
    "Private Subnets (2, across AZs)",
    "Route Tables (public and private)",
    "NAT Gateway (1 or 2)",
    "Elastic IPs (for NAT Gateway)",
    "Security Groups (ALB SG, EC2 SG, RDS SG)",
    "Network ACLs (optional; default NACLs acceptable for lean setup)",
    "Application Load Balancer (ALB)",
    "ALB Target Group",
    "ALB Listener (HTTPS :443)",
    "ACM Certificate (for ALB TLS)",
    "Auto Scaling Group (ASG)",
    "EC2 Launch Template",
    "EC2 Instances (managed by ASG)",
    "EBS Volumes (root volumes for EC2)",
    "IAM Role for EC2 (Instance Profile) with ECR pull permissions",
    "IAM Role for GitHub Actions (via OIDC) or IAM User access keys (current approach)",
    "IAM Policies (least-privilege for ECR, S3 state, EC2/ASG/ELB as needed)",
    "Amazon ECR Repository (main-applications-registry)",
    "ECR Lifecycle Policy",
    "Amazon S3 Bucket for Terraform state (terraform-resources-test)",
    "S3 Bucket Versioning (for Terraform state)",
    "S3 Bucket Encryption (SSE-S3 or SSE-KMS)",
    "DynamoDB Table for Terraform state locking (recommended)",
    "Amazon RDS for MySQL (optional if actually used)",
    "RDS DB Subnet Group (if RDS used)",
    "RDS Parameter Group (optional)",
    "AWS Secrets Manager secret for DB credentials (if RDS used)",
    "AWS Systems Manager (SSM) Managed Instance setup (recommended to replace SSH)",
    "SSM Parameter Store (optional for non-secret config)",
    "Amazon CloudWatch (metrics, alarms, dashboards)",
    "CloudWatch Logs Log Groups (for instance/app logs)",
    "CloudWatch Agent (on EC2)",
    "AWS CloudTrail",
    "AWS KMS Key(s) (optional; for S3/RDS/EBS encryption)",
    "AWS WAFv2 Web ACL (optional, attached to ALB)"
  ]
}