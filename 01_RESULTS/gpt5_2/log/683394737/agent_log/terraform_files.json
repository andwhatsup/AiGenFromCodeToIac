{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Project/name prefix used for resource naming\"\n  type        = string\n  default     = \"devops-interview-ac\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, test, prod)\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"Public subnet CIDRs (one per AZ)\"\n  type        = list(string)\n  default     = [\"10.0.0.0/24\", \"10.0.1.0/24\"]\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"Private subnet CIDRs (one per AZ)\"\n  type        = list(string)\n  default     = [\"10.0.10.0/24\", \"10.0.11.0/24\"]\n}\n\nvariable \"enable_nat_gateway\" {\n  description = \"Whether to create NAT gateways for private subnets\"\n  type        = bool\n  default     = true\n}\n\nvariable \"single_nat_gateway\" {\n  description = \"If true, create a single NAT gateway (lower cost, less HA). If false, one per AZ. Only used when enable_nat_gateway=true.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"alb_ingress_cidrs\" {\n  description = \"CIDR blocks allowed to access the ALB (HTTP/HTTPS)\"\n  type        = list(string)\n  default     = [\"0.0.0.0/0\"]\n}\n\nvariable \"instance_type\" {\n  description = \"EC2 instance type for ASG\"\n  type        = string\n  default     = \"t3.micro\"\n}\n\nvariable \"asg_min_size\" {\n  description = \"ASG min size\"\n  type        = number\n  default     = 2\n}\n\nvariable \"asg_desired_capacity\" {\n  description = \"ASG desired capacity\"\n  type        = number\n  default     = 2\n}\n\nvariable \"asg_max_size\" {\n  description = \"ASG max size\"\n  type        = number\n  default     = 4\n}\n\nvariable \"key_pair_name\" {\n  description = \"Optional EC2 key pair name to enable SSH access. Leave null to disable SSH.\"\n  type        = string\n  default     = null\n}\n\nvariable \"allow_ssh_cidrs\" {\n  description = \"CIDR blocks allowed to SSH to instances (only used if key_pair_name is set)\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name for the application image\"\n  type        = string\n  default     = \"main-applications-registry\"\n}\n\nvariable \"ecr_image_tag\" {\n  description = \"Image tag to run on EC2 instances\"\n  type        = string\n  default     = \"latest\"\n}\n\nvariable \"container_port\" {\n  description = \"Container port exposed by the httpd container\"\n  type        = number\n  default     = 80\n}\n\nvariable \"enable_rds\" {\n  description = \"Whether to provision an RDS MySQL instance (optional)\"\n  type        = bool\n  default     = false\n}\n\nvariable \"db_name\" {\n  description = \"RDS database name\"\n  type        = string\n  default     = \"appdb\"\n}\n\nvariable \"db_username\" {\n  description = \"RDS master username\"\n  type        = string\n  default     = \"admin\"\n}\n\nvariable \"db_password\" {\n  description = \"RDS master password (use tfvars or environment variable TF_VAR_db_password)\"\n  type        = string\n  sensitive   = true\n  default     = null\n}\n\nvariable \"db_instance_class\" {\n  description = \"RDS instance class\"\n  type        = string\n  default     = \"db.t3.micro\"\n}\n\nvariable \"db_allocated_storage\" {\n  description = \"RDS allocated storage (GiB)\"\n  type        = number\n  default     = 20\n}\n\nvariable \"acm_certificate_arn\" {\n  description = \"Optional ACM certificate ARN for HTTPS listener. If null, only HTTP listener is created.\"\n  type        = string\n  default     = null\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  azs = slice(data.aws_availability_zones.available.names, 0, 2)\n\n  name_prefix = \"${var.project_name}-${var.environment}\"\n}\n\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = local.name_prefix\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  public_subnets  = var.public_subnet_cidrs\n  private_subnets = var.private_subnet_cidrs\n\n  enable_nat_gateway = var.enable_nat_gateway\n  single_nat_gateway = var.single_nat_gateway\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n}\n\nresource \"aws_security_group\" \"alb\" {\n  name        = \"${local.name_prefix}-alb-sg\"\n  description = \"ALB security group\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description = \"HTTP\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = var.alb_ingress_cidrs\n  }\n\n  dynamic \"ingress\" {\n    for_each = var.acm_certificate_arn == null ? [] : [1]\n    content {\n      description = \"HTTPS\"\n      from_port   = 443\n      to_port     = 443\n      protocol    = \"tcp\"\n      cidr_blocks = var.alb_ingress_cidrs\n    }\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_security_group\" \"ec2\" {\n  name        = \"${local.name_prefix}-ec2-sg\"\n  description = \"EC2 instances security group\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description     = \"From ALB to container port\"\n    from_port       = var.container_port\n    to_port         = var.container_port\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.alb.id]\n  }\n\n  dynamic \"ingress\" {\n    for_each = var.key_pair_name == null ? [] : [1]\n    content {\n      description = \"SSH\"\n      from_port   = 22\n      to_port     = 22\n      protocol    = \"tcp\"\n      cidr_blocks = length(var.allow_ssh_cidrs) > 0 ? var.allow_ssh_cidrs : [\"0.0.0.0/0\"]\n    }\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_security_group\" \"rds\" {\n  count       = var.enable_rds ? 1 : 0\n  name        = \"${local.name_prefix}-rds-sg\"\n  description = \"RDS MySQL security group\"\n  vpc_id      = module.vpc.vpc_id\n\n  ingress {\n    description     = \"MySQL from EC2\"\n    from_port       = 3306\n    to_port         = 3306\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.ec2.id]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_ecr_repository\" \"app\" {\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"app\" {\n  repository = aws_ecr_repository.app.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Expire untagged images older than 7 days\"\n        selection = {\n          tagStatus   = \"untagged\"\n          countType   = \"sinceImagePushed\"\n          countUnit   = \"days\"\n          countNumber = 7\n        }\n        action = {\n          type = \"expire\"\n        }\n      },\n      {\n        rulePriority = 2\n        description  = \"Keep last 20 tagged images\"\n        selection = {\n          tagStatus     = \"tagged\"\n          tagPrefixList = [\"latest\"]\n          countType     = \"imageCountMoreThan\"\n          countNumber   = 20\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n\ndata \"aws_iam_policy_document\" \"ec2_assume_role\" {\n  statement {\n    effect = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"ec2.amazonaws.com\"]\n    }\n    actions = [\"sts:AssumeRole\"]\n  }\n}\n\nresource \"aws_iam_role\" \"ec2\" {\n  name               = \"${local.name_prefix}-ec2-role\"\n  assume_role_policy = data.aws_iam_policy_document.ec2_assume_role.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecr_readonly\" {\n  role       = aws_iam_role.ec2.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ssm\" {\n  role       = aws_iam_role.ec2.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\"\n}\n\nresource \"aws_iam_instance_profile\" \"ec2\" {\n  name = \"${local.name_prefix}-ec2-profile\"\n  role = aws_iam_role.ec2.name\n}\n\ndata \"aws_ami\" \"ubuntu\" {\n  most_recent = true\n  owners      = [\"099720109477\"]\n\n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*\"]\n  }\n\n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n}\n\nlocals {\n  user_data = <<-EOF\n    #!/bin/bash\n    set -euxo pipefail\n\n    export DEBIAN_FRONTEND=noninteractive\n\n    apt-get update -y\n    apt-get install -y ca-certificates curl gnupg lsb-release git\n\n    # Install Docker\n    install -m 0755 -d /etc/apt/keyrings\n    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n    chmod a+r /etc/apt/keyrings/docker.gpg\n\n    echo \\\n      \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n      $(. /etc/os-release && echo $VERSION_CODENAME) stable\" \\\n      > /etc/apt/sources.list.d/docker.list\n\n    apt-get update -y\n    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n    systemctl enable docker\n    systemctl start docker\n\n    # Install AWS CLI v2\n    apt-get install -y unzip\n    curl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"/tmp/awscliv2.zip\"\n    unzip -q /tmp/awscliv2.zip -d /tmp\n    /tmp/aws/install --update\n\n    # Login to ECR and run container\n    REGION=\"${var.aws_region}\"\n    ACCOUNT_ID=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | grep accountId | awk -F\\\" '{print $4}')\n    REPO=\"${var.ecr_repository_name}\"\n    TAG=\"${var.ecr_image_tag}\"\n\n    aws ecr get-login-password --region \"$REGION\" | docker login --username AWS --password-stdin \"$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com\"\n\n    docker pull \"$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPO:$TAG\" || docker pull \"$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPO\"\n\n    docker rm -f \"$REPO\" || true\n    docker run -d --restart unless-stopped --name \"$REPO\" -p 80:${var.container_port} \"$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPO:$TAG\" || \\\n      docker run -d --restart unless-stopped --name \"$REPO\" -p 80:${var.container_port} \"$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPO\"\n  EOF\n}\n\nresource \"aws_launch_template\" \"app\" {\n  name_prefix   = \"${local.name_prefix}-lt-\"\n  image_id      = data.aws_ami.ubuntu.id\n  instance_type = var.instance_type\n\n  key_name = var.key_pair_name\n\n  iam_instance_profile {\n    name = aws_iam_instance_profile.ec2.name\n  }\n\n  vpc_security_group_ids = [aws_security_group.ec2.id]\n\n  user_data = base64encode(local.user_data)\n\n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_tokens                 = \"required\"\n    http_put_response_hop_limit = 2\n  }\n\n  block_device_mappings {\n    device_name = \"/dev/sda1\"\n\n    ebs {\n      volume_size           = 10\n      volume_type           = \"gp3\"\n      encrypted             = true\n      delete_on_termination = true\n    }\n  }\n\n  tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Name = \"${local.name_prefix}-app\"\n    }\n  }\n}\n\nresource \"aws_lb\" \"app\" {\n  name               = substr(\"${local.name_prefix}-alb\", 0, 32)\n  load_balancer_type = \"application\"\n  internal           = false\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = module.vpc.public_subnets\n}\n\nresource \"aws_lb_target_group\" \"app\" {\n  name        = substr(\"${local.name_prefix}-tg\", 0, 32)\n  port        = 80\n  protocol    = \"HTTP\"\n  vpc_id      = module.vpc.vpc_id\n  target_type = \"instance\"\n\n  health_check {\n    enabled             = true\n    path                = \"/\"\n    matcher             = \"200-399\"\n    interval            = 30\n    timeout             = 5\n    healthy_threshold   = 2\n    unhealthy_threshold = 3\n  }\n}\n\nresource \"aws_lb_listener\" \"http\" {\n  load_balancer_arn = aws_lb.app.arn\n  port              = 80\n  protocol          = \"HTTP\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app.arn\n  }\n}\n\nresource \"aws_lb_listener\" \"https\" {\n  count             = var.acm_certificate_arn == null ? 0 : 1\n  load_balancer_arn = aws_lb.app.arn\n  port              = 443\n  protocol          = \"HTTPS\"\n  ssl_policy        = \"ELBSecurityPolicy-TLS13-1-2-2021-06\"\n  certificate_arn   = var.acm_certificate_arn\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app.arn\n  }\n}\n\nresource \"aws_autoscaling_group\" \"app\" {\n  name                = \"demo-asg-instance-1\"\n  min_size            = var.asg_min_size\n  desired_capacity    = var.asg_desired_capacity\n  max_size            = var.asg_max_size\n  vpc_zone_identifier = module.vpc.private_subnets\n\n  health_check_type         = \"ELB\"\n  health_check_grace_period = 180\n\n  target_group_arns = [aws_lb_target_group.app.arn]\n\n  launch_template {\n    id      = aws_launch_template.app.id\n    version = \"$Latest\"\n  }\n\n  instance_refresh {\n    strategy = \"Rolling\"\n    preferences {\n      min_healthy_percentage = 50\n    }\n    triggers = [\"tag\"]\n  }\n\n  tag {\n    key                 = \"Name\"\n    value               = \"${local.name_prefix}-app\"\n    propagate_at_launch = true\n  }\n}\n\nresource \"aws_db_subnet_group\" \"this\" {\n  count      = var.enable_rds ? 1 : 0\n  name       = \"${local.name_prefix}-db-subnets\"\n  subnet_ids = module.vpc.private_subnets\n}\n\nresource \"aws_db_instance\" \"mysql\" {\n  count = var.enable_rds ? 1 : 0\n\n  identifier = \"${local.name_prefix}-mysql\"\n\n  engine               = \"mysql\"\n  engine_version       = \"8.0\"\n  instance_class       = var.db_instance_class\n  allocated_storage    = var.db_allocated_storage\n  storage_type         = \"gp3\"\n  storage_encrypted    = true\n  publicly_accessible  = false\n  multi_az             = true\n  db_subnet_group_name = aws_db_subnet_group.this[0].name\n\n  db_name  = var.db_name\n  username = var.db_username\n  password = var.db_password\n\n  vpc_security_group_ids = [aws_security_group.rds[0].id]\n\n  backup_retention_period = 7\n  deletion_protection     = false\n  skip_final_snapshot     = true\n\n  apply_immediately = true\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value = module.vpc.vpc_id\n}\n\noutput \"alb_dns_name\" {\n  description = \"Public DNS name of the Application Load Balancer\"\n  value       = aws_lb.app.dns_name\n}\n\noutput \"alb_url\" {\n  description = \"Convenience URL (HTTP)\"\n  value       = \"http://${aws_lb.app.dns_name}\"\n}\n\noutput \"ecr_repository_url\" {\n  value = aws_ecr_repository.app.repository_url\n}\n\noutput \"asg_name\" {\n  value = aws_autoscaling_group.app.name\n}\n\noutput \"rds_endpoint\" {\n  value       = var.enable_rds ? aws_db_instance.mysql[0].address : null\n  description = \"RDS endpoint (if enabled)\"\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region   = \"us-east-1\"\nproject_name = \"devops-interview-ac\"\nenvironment  = \"dev\"\n\n# Keep SSH disabled by default (more secure). If you need SSH, set key_pair_name and allow_ssh_cidrs.\n# key_pair_name   = \"candidate\"\n# allow_ssh_cidrs  = [\"YOUR_PUBLIC_IP/32\"]\n\n# Optional: enable HTTPS by providing an ACM cert ARN in the same region.\n# acm_certificate_arn = \"arn:aws:acm:us-east-1:123456789012:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n\n# Optional: enable RDS (costs money)\n# enable_rds  = true\n# db_password = \"change-me-please\"\n"
    }
  ]
}