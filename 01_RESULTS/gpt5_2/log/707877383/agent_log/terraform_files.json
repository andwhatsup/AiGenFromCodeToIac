{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = merge(\n      {\n        Project     = var.project_name\n        Environment = var.environment\n        ManagedBy   = \"terraform\"\n      },\n      var.tags\n    )\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Project name used for naming/tagging.\"\n  type        = string\n  default     = \"proxy-http-client\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"tags\" {\n  description = \"Additional tags to apply to all resources.\"\n  type        = map(string)\n  default     = {}\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"enable_nat_gateway_ha\" {\n  description = \"If true, create one NAT Gateway per AZ. If false, create a single NAT Gateway (cost-optimized).\"\n  type        = bool\n  default     = false\n}\n\nvariable \"container_image\" {\n  description = \"Container image URI for the Node.js job (e.g., <account>.dkr.ecr.<region>.amazonaws.com/repo:tag).\"\n  type        = string\n}\n\nvariable \"container_command\" {\n  description = \"Optional command override for the container. Leave empty to use image CMD.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"task_cpu\" {\n  description = \"Fargate task CPU units.\"\n  type        = number\n  default     = 256\n}\n\nvariable \"task_memory\" {\n  description = \"Fargate task memory (MiB).\"\n  type        = number\n  default     = 512\n}\n\nvariable \"schedule_expression\" {\n  description = \"EventBridge schedule expression (rate(...) or cron(...)).\"\n  type        = string\n  default     = \"rate(1 hour)\"\n}\n\nvariable \"task_desired_count\" {\n  description = \"If you want a continuously running service, set >0 and enable create_ecs_service. For scheduled tasks, keep 0.\"\n  type        = number\n  default     = 0\n}\n\nvariable \"create_ecs_service\" {\n  description = \"Create an ECS service (optional). Scheduled tasks do not require a service.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"secrets_json\" {\n  description = \"JSON string stored in Secrets Manager and exposed to the container as APP_CONFIG_JSON. Put proxy URLs/credentials and other config here.\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"log_retention_days\" {\n  description = \"CloudWatch Logs retention in days.\"\n  type        = number\n  default     = 14\n}\n\nvariable \"sns_email\" {\n  description = \"Optional email address to subscribe to alerts. Leave empty to skip subscription.\"\n  type        = string\n  default     = \"\"\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n  azs         = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # Derive /24 subnets from the VPC CIDR. This is simple and deterministic.\n  public_subnet_cidrs  = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i)]\n  private_subnet_cidrs = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i + 100)]\n}\n\nresource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpc\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-igw\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.key\n  cidr_block              = local.public_subnet_cidrs[each.value]\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${local.name_prefix}-public-${each.key}\"\n    Tier = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.key\n  cidr_block              = local.private_subnet_cidrs[each.value]\n  map_public_ip_on_launch = false\n\n  tags = {\n    Name = \"${local.name_prefix}-private-${each.key}\"\n    Tier = \"private\"\n  }\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-public-rt\"\n  }\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_eip\" \"nat\" {\n  for_each = var.enable_nat_gateway_ha ? aws_subnet.public : { \"single\" = values(aws_subnet.public)[0] }\n\n  domain = \"vpc\"\n\n  tags = {\n    Name = \"${local.name_prefix}-nat-eip-${each.key}\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  for_each = var.enable_nat_gateway_ha ? aws_subnet.public : { \"single\" = values(aws_subnet.public)[0] }\n\n  allocation_id = aws_eip.nat[each.key].id\n  subnet_id     = each.value.id\n\n  tags = {\n    Name = \"${local.name_prefix}-nat-${each.key}\"\n  }\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  for_each = aws_subnet.private\n\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-private-rt-${each.key}\"\n  }\n}\n\nresource \"aws_route\" \"private_default\" {\n  for_each = aws_route_table.private\n\n  route_table_id         = each.value.id\n  destination_cidr_block = \"0.0.0.0/0\"\n\n  nat_gateway_id = var.enable_nat_gateway_ha ? aws_nat_gateway.this[each.key].id : aws_nat_gateway.this[\"single\"].id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private[each.key].id\n}\n\n# Security group for the task: no inbound, egress only.\nresource \"aws_security_group\" \"task\" {\n  name        = \"${local.name_prefix}-task-sg\"\n  description = \"ECS task security group (no inbound).\"\n  vpc_id      = aws_vpc.this.id\n\n  egress {\n    description = \"HTTPS outbound\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Enable only if you truly need HTTP.\n  egress {\n    description = \"HTTP outbound\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-task-sg\"\n  }\n}\n\nresource \"aws_cloudwatch_log_group\" \"task\" {\n  name              = \"/ecs/${local.name_prefix}\"\n  retention_in_days = var.log_retention_days\n}\n\nresource \"aws_kms_key\" \"secrets\" {\n  description             = \"KMS key for ${local.name_prefix} secrets\"\n  deletion_window_in_days = 7\n  enable_key_rotation     = true\n}\n\nresource \"aws_kms_alias\" \"secrets\" {\n  name          = \"alias/${local.name_prefix}-secrets\"\n  target_key_id = aws_kms_key.secrets.key_id\n}\n\nresource \"aws_secretsmanager_secret\" \"app\" {\n  name                    = \"${local.name_prefix}/app-config\"\n  kms_key_id              = aws_kms_key.secrets.arn\n  recovery_window_in_days = 7\n}\n\nresource \"aws_secretsmanager_secret_version\" \"app\" {\n  secret_id     = aws_secretsmanager_secret.app.id\n  secret_string = var.secrets_json\n}\n\nresource \"aws_ecs_cluster\" \"this\" {\n  name = \"${local.name_prefix}-cluster\"\n}\n\nresource \"aws_iam_role\" \"task_execution\" {\n  name = \"${local.name_prefix}-ecs-task-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"task_execution\" {\n  role       = aws_iam_role.task_execution.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\nresource \"aws_iam_role\" \"task\" {\n  name = \"${local.name_prefix}-ecs-task\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"task_secrets\" {\n  name        = \"${local.name_prefix}-task-secrets\"\n  description = \"Allow ECS task to read app config secret.\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"ReadSecret\"\n        Effect = \"Allow\"\n        Action = [\n          \"secretsmanager:GetSecretValue\",\n          \"secretsmanager:DescribeSecret\"\n        ]\n        Resource = aws_secretsmanager_secret.app.arn\n      },\n      {\n        Sid    = \"DecryptSecret\"\n        Effect = \"Allow\"\n        Action = [\n          \"kms:Decrypt\"\n        ]\n        Resource = aws_kms_key.secrets.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"task_secrets\" {\n  role       = aws_iam_role.task.name\n  policy_arn = aws_iam_policy.task_secrets.arn\n}\n\nresource \"aws_ecs_task_definition\" \"this\" {\n  family                   = local.name_prefix\n  requires_compatibilities = [\"FARGATE\"]\n  network_mode             = \"awsvpc\"\n  cpu                      = tostring(var.task_cpu)\n  memory                   = tostring(var.task_memory)\n  execution_role_arn       = aws_iam_role.task_execution.arn\n  task_role_arn            = aws_iam_role.task.arn\n\n  container_definitions = jsonencode([\n    {\n      name      = \"app\"\n      image     = var.container_image\n      essential = true\n\n      command = length(var.container_command) > 0 ? var.container_command : null\n\n      environment = [\n        {\n          name  = \"NODE_ENV\"\n          value = var.environment\n        }\n      ]\n\n      secrets = [\n        {\n          name      = \"APP_CONFIG_JSON\"\n          valueFrom = aws_secretsmanager_secret.app.arn\n        }\n      ]\n\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.task.name\n          awslogs-region        = var.aws_region\n          awslogs-stream-prefix = \"ecs\"\n        }\n      }\n    }\n  ])\n}\n\n# Optional ECS service (not required for scheduled tasks)\nresource \"aws_ecs_service\" \"this\" {\n  count = var.create_ecs_service ? 1 : 0\n\n  name            = \"${local.name_prefix}-svc\"\n  cluster         = aws_ecs_cluster.this.id\n  task_definition = aws_ecs_task_definition.this.arn\n  desired_count   = var.task_desired_count\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets         = [for s in aws_subnet.private : s.id]\n    security_groups = [aws_security_group.task.id]\n    assign_public_ip = false\n  }\n\n  lifecycle {\n    ignore_changes = [desired_count]\n  }\n}\n\n# EventBridge rule to run the task on a schedule\nresource \"aws_cloudwatch_event_rule\" \"schedule\" {\n  name                = \"${local.name_prefix}-schedule\"\n  description         = \"Schedule to run ${local.name_prefix} ECS task\"\n  schedule_expression = var.schedule_expression\n}\n\nresource \"aws_iam_role\" \"events_invoke_ecs\" {\n  name = \"${local.name_prefix}-events-invoke-ecs\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"events.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"events_invoke_ecs\" {\n  name        = \"${local.name_prefix}-events-invoke-ecs\"\n  description = \"Allow EventBridge to run ECS task.\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"ecs:RunTask\"\n        ]\n        Resource = aws_ecs_task_definition.this.arn\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"iam:PassRole\"\n        ]\n        Resource = [\n          aws_iam_role.task_execution.arn,\n          aws_iam_role.task.arn\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"events_invoke_ecs\" {\n  role       = aws_iam_role.events_invoke_ecs.name\n  policy_arn = aws_iam_policy.events_invoke_ecs.arn\n}\n\nresource \"aws_cloudwatch_event_target\" \"ecs\" {\n  rule      = aws_cloudwatch_event_rule.schedule.name\n  target_id = \"ecs\"\n  arn       = aws_ecs_cluster.this.arn\n  role_arn  = aws_iam_role.events_invoke_ecs.arn\n\n  ecs_target {\n    task_definition_arn = aws_ecs_task_definition.this.arn\n    launch_type         = \"FARGATE\"\n    platform_version    = \"LATEST\"\n\n    network_configuration {\n      subnets          = [for s in aws_subnet.private : s.id]\n      security_groups  = [aws_security_group.task.id]\n      assign_public_ip = false\n    }\n  }\n}\n\n# Alerts: SNS topic + optional email subscription\nresource \"aws_sns_topic\" \"alerts\" {\n  name = \"${local.name_prefix}-alerts\"\n}\n\nresource \"aws_sns_topic_subscription\" \"email\" {\n  count = var.sns_email != \"\" ? 1 : 0\n\n  topic_arn = aws_sns_topic.alerts.arn\n  protocol  = \"email\"\n  endpoint  = var.sns_email\n}\n\n# Alarm on EventBridge rule failures (invocations that fail)\nresource \"aws_cloudwatch_metric_alarm\" \"eventbridge_failed_invocations\" {\n  alarm_name          = \"${local.name_prefix}-schedule-failed-invocations\"\n  alarm_description   = \"EventBridge failed invocations for scheduled ECS task\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"FailedInvocations\"\n  namespace           = \"AWS/Events\"\n  period              = 300\n  statistic           = \"Sum\"\n  threshold           = 0\n\n  dimensions = {\n    RuleName = aws_cloudwatch_event_rule.schedule.name\n  }\n\n  alarm_actions = [aws_sns_topic.alerts.arn]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value       = aws_vpc.this.id\n  description = \"VPC ID.\"\n}\n\noutput \"private_subnet_ids\" {\n  value       = [for s in aws_subnet.private : s.id]\n  description = \"Private subnet IDs used by ECS tasks.\"\n}\n\noutput \"ecs_cluster_name\" {\n  value       = aws_ecs_cluster.this.name\n  description = \"ECS cluster name.\"\n}\n\noutput \"ecs_task_definition_arn\" {\n  value       = aws_ecs_task_definition.this.arn\n  description = \"ECS task definition ARN.\"\n}\n\noutput \"secrets_manager_secret_arn\" {\n  value       = aws_secretsmanager_secret.app.arn\n  description = \"Secrets Manager secret ARN containing APP_CONFIG_JSON.\"\n}\n\noutput \"cloudwatch_log_group_name\" {\n  value       = aws_cloudwatch_log_group.task.name\n  description = \"CloudWatch log group for task logs.\"\n}\n\noutput \"eventbridge_rule_name\" {\n  value       = aws_cloudwatch_event_rule.schedule.name\n  description = \"EventBridge schedule rule name.\"\n}\n\noutput \"sns_topic_arn\" {\n  value       = aws_sns_topic.alerts.arn\n  description = \"SNS topic ARN for alerts.\"\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "# Example values\nproject_name = \"proxy-http-client\"\nenvironment  = \"dev\"\naws_region   = \"us-east-1\"\n\n# Build/push your image separately and set the full image URI here.\ncontainer_image = \"123456789012.dkr.ecr.us-east-1.amazonaws.com/proxy-http-client:latest\"\n\n# Optional: override command\n# container_command = [\"node\", \"index.mjs\"]\n\n# Schedule\nschedule_expression = \"rate(1 hour)\"\n\n# App config stored as a single JSON string secret and exposed as APP_CONFIG_JSON\n# Put your proxy list/credentials/targets here.\nsecrets_json = <<EOT\n{\n  \"PROXIES\": [\n    \"http://user:pass@proxy1.example.com:8080\",\n    \"http://user:pass@proxy2.example.com:8080\"\n  ],\n  \"TARGETS\": [\n    \"https://ifconfig.co/json\",\n    \"https://www.whatismyipaddress.com/\"\n  ]\n}\nEOT\n\n# Optional alert subscription\n# sns_email = \"you@example.com\"\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform: AWS scheduled ECS Fargate task for Node.js proxy HTTP client\n\nThis Terraform config provisions:\n- VPC (2 AZs) with public subnets (NAT) and private subnets (ECS tasks)\n- ECS cluster + Fargate task definition\n- EventBridge schedule to run the task\n- Secrets Manager secret injected as `APP_CONFIG_JSON`\n- CloudWatch Logs log group\n- SNS topic + alarm for EventBridge failed invocations\n\n## Usage\n\n1. Create an ECR repo and push your image (or use any accessible image URI).\n2. Copy `terraform.tfvars.example` to `terraform.tfvars` and set values.\n3. Run:\n\n```bash\nterraform init\nterraform validate\nterraform plan\nterraform apply\n```\n\n## Notes\n- This configuration intentionally does **not** provision external proxy infrastructure.\n- The task security group allows outbound 443 and 80. Remove port 80 if not needed.\n- For production, consider remote state (S3 + DynamoDB) and tighter egress controls.\n"
    }
  ]
}