{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \"~> 2.25\"\n    }\n    helm = {\n      source  = \"hashicorp/helm\"\n      version = \"~> 2.12\"\n    }\n    tls = {\n      source  = \"hashicorp/tls\"\n      version = \"~> 4.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = var.tags\n  }\n}\n\n# These providers are configured from the EKS cluster outputs.\n# They will work when you run Terraform from an environment that has AWS credentials\n# with access to the cluster.\n\ndata \"aws_eks_cluster\" \"this\" {\n  name = module.eks.cluster_name\n}\n\ndata \"aws_eks_cluster_auth\" \"this\" {\n  name = module.eks.cluster_name\n}\n\nprovider \"kubernetes\" {\n  host                   = data.aws_eks_cluster.this.endpoint\n  cluster_ca_certificate = base64decode(data.aws_eks_cluster.this.certificate_authority[0].data)\n  token                  = data.aws_eks_cluster_auth.this.token\n}\n\nprovider \"helm\" {\n  kubernetes {\n    host                   = data.aws_eks_cluster.this.endpoint\n    cluster_ca_certificate = base64decode(data.aws_eks_cluster.this.certificate_authority[0].data)\n    token                  = data.aws_eks_cluster_auth.this.token\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"name\" {\n  description = \"Name prefix for resources.\"\n  type        = string\n  default     = \"nebari-metrics\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 or 3 recommended).\"\n  type        = number\n  default     = 2\n  validation {\n    condition     = var.az_count >= 2 && var.az_count <= 3\n    error_message = \"az_count must be 2 or 3.\"\n  }\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"Private subnet CIDRs (one per AZ). If empty, they will be derived from vpc_cidr.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"Public subnet CIDRs (one per AZ). If empty, they will be derived from vpc_cidr.\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"cluster_version\" {\n  description = \"EKS Kubernetes version.\"\n  type        = string\n  default     = \"1.29\"\n}\n\nvariable \"cluster_endpoint_public_access\" {\n  description = \"Whether the EKS API server endpoint is publicly accessible.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"cluster_endpoint_private_access\" {\n  description = \"Whether the EKS API server endpoint is privately accessible.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"node_instance_types\" {\n  description = \"Instance types for the managed node group.\"\n  type        = list(string)\n  default     = [\"t3.medium\"]\n}\n\nvariable \"node_desired_size\" {\n  description = \"Desired number of nodes.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_min_size\" {\n  description = \"Minimum number of nodes.\"\n  type        = number\n  default     = 1\n}\n\nvariable \"node_max_size\" {\n  description = \"Maximum number of nodes.\"\n  type        = number\n  default     = 4\n}\n\nvariable \"metrics_server_namespace\" {\n  description = \"Namespace to install metrics-server into. Typically kube-system.\"\n  type        = string\n  default     = \"kube-system\"\n}\n\nvariable \"metrics_server_chart_version\" {\n  description = \"metrics-server Helm chart version.\"\n  type        = string\n  default     = \"3.12.1\"\n}\n\nvariable \"metrics_server_values\" {\n  description = \"Additional Helm values for metrics-server (YAML as a string).\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"tags\" {\n  description = \"Tags applied to all taggable resources.\"\n  type        = map(string)\n  default = {\n    Project = \"nebari-plugin-metrics-server\"\n    Managed = \"terraform\"\n  }\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # Derive subnet CIDRs if not provided.\n  # Uses /20s carved from the VPC CIDR.\n  public_subnet_cidrs  = length(var.public_subnet_cidrs) > 0 ? var.public_subnet_cidrs : [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 4, i)]\n  private_subnet_cidrs = length(var.private_subnet_cidrs) > 0 ? var.private_subnet_cidrs : [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 4, i + 8)]\n}\n\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = var.name\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  public_subnets  = local.public_subnet_cidrs\n  private_subnets = local.private_subnet_cidrs\n\n  enable_nat_gateway     = true\n  single_nat_gateway     = false\n  one_nat_gateway_per_az = true\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = \"1\"\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = \"1\"\n  }\n\n  tags = var.tags\n}\n\nmodule \"eks\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 20.0\"\n\n  cluster_name    = var.name\n  cluster_version = var.cluster_version\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  cluster_endpoint_public_access  = var.cluster_endpoint_public_access\n  cluster_endpoint_private_access = var.cluster_endpoint_private_access\n\n  enable_cluster_creator_admin_permissions = true\n\n  cluster_enabled_log_types = [\n    \"api\",\n    \"audit\",\n    \"authenticator\",\n    \"controllerManager\",\n    \"scheduler\",\n  ]\n\n  eks_managed_node_groups = {\n    default = {\n      name                 = \"default\"\n      instance_types       = var.node_instance_types\n      desired_size         = var.node_desired_size\n      min_size             = var.node_min_size\n      max_size             = var.node_max_size\n      subnet_ids           = module.vpc.private_subnets\n      capacity_type        = \"ON_DEMAND\"\n      ami_type             = \"AL2_x86_64\"\n      disk_size            = 50\n      force_update_version = true\n\n      labels = {\n        \"workload\" = \"general\"\n      }\n\n      tags = var.tags\n    }\n  }\n\n  tags = var.tags\n}\n\nresource \"kubernetes_namespace\" \"metrics\" {\n  metadata {\n    name = var.metrics_server_namespace\n  }\n}\n\nresource \"helm_release\" \"metrics_server\" {\n  name       = \"metrics-server\"\n  namespace  = kubernetes_namespace.metrics.metadata[0].name\n  repository = \"https://kubernetes-sigs.github.io/metrics-server/\"\n  chart      = \"metrics-server\"\n  version    = var.metrics_server_chart_version\n\n  # Common EKS requirement: allow insecure TLS to kubelet if nodes use self-signed certs.\n  # You can override/extend via metrics_server_values.\n  set {\n    name  = \"args\"\n    value = \"{--kubelet-insecure-tls,--kubelet-preferred-address-types=InternalIP\\\\,ExternalIP\\\\,Hostname}\"\n  }\n\n  values = var.metrics_server_values != \"\" ? [var.metrics_server_values] : []\n\n  depends_on = [module.eks]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  description = \"VPC ID.\"\n  value       = module.vpc.vpc_id\n}\n\noutput \"private_subnet_ids\" {\n  description = \"Private subnet IDs used by EKS nodes.\"\n  value       = module.vpc.private_subnets\n}\n\noutput \"public_subnet_ids\" {\n  description = \"Public subnet IDs.\"\n  value       = module.vpc.public_subnets\n}\n\noutput \"eks_cluster_name\" {\n  description = \"EKS cluster name.\"\n  value       = module.eks.cluster_name\n}\n\noutput \"eks_cluster_endpoint\" {\n  description = \"EKS cluster API endpoint.\"\n  value       = module.eks.cluster_endpoint\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region = \"us-east-1\"\nname       = \"nebari-metrics\"\n\n# Optional: override these if they conflict with existing networks\n# vpc_cidr = \"10.0.0.0/16\"\n\ntags = {\n  Project = \"nebari-plugin-metrics-server\"\n  Managed = \"terraform\"\n}\n"
    }
  ]
}