{
  "aws_architecture_description": "## Proposed high-level AWS architecture\n\n### 1) Compute + entrypoint (lean, production-friendly)\n- **Route 53 + ACM + Application Load Balancer (ALB)** provide a stable HTTPS endpoint for the Pynecone web app.\n- Run the **Python/Pynecone application as a container on Amazon ECS with Fargate** (one service, desired count 1 to start). This keeps ops light (no server management) and still allows scaling later.\n- **CloudWatch Logs** captures application logs; **CloudWatch Alarms** monitor health/latency/error rates.\n\n### 2) Data layer (SQLite reality + recommended path)\nYour code currently uses a local SQLite file (`sqlite:///pynecone.db`). On AWS you have two practical options:\n\n**Option A (recommended for reliability): migrate to a managed DB**\n- Replace SQLite with **Amazon RDS (PostgreSQL)** (or Aurora PostgreSQL). This enables multi-AZ, backups, and safe scaling.\n- Update `pcconfig.py` to use the RDS connection string.\n\n**Option B (minimal code change / “keep SQLite”): single-task + persistent shared storage**\n- Keep SQLite but store `pynecone.db` on **Amazon EFS** and mount it into the Fargate task.\n- Constrain the ECS service to **1 running task** (SQLite + shared network filesystem is not a good fit for multi-writer horizontal scaling).\n\n### 3) Secrets and OAuth credentials\n- Store the Google OAuth client credentials (the contents of `client_secret.json`) in **AWS Secrets Manager**.\n- At runtime, the ECS task retrieves the secret and either:\n  - writes it to a temporary file inside the container (e.g., `/tmp/client_secret.json`) to satisfy `Flow.from_client_secrets_file(...)`, or\n  - refactors to load from JSON in-memory (if you choose to adjust code).\n- Use **IAM task role** permissions scoped to only that secret.\n\n### 4) Outbound access to Google APIs\n- Place ECS tasks in **private subnets**.\n- Provide outbound internet access via a **NAT Gateway** so the app can reach Google OAuth and Gmail APIs.\n- Security groups restrict inbound to ALB only; outbound limited to required destinations/ports (practically: HTTPS/443).\n\n### 5) CI/CD and image storage (simple)\n- Build a container image and store it in **Amazon ECR**.\n- Deploy via **CodePipeline/CodeBuild** (or GitHub Actions) to update the ECS service.\n\n### 6) Notes specific to this app\n- Add `google-auth-oauthlib` explicitly to `requirements.txt` for reproducible builds.\n- Ensure the Google OAuth redirect URI matches your ALB/Route53 hostname (e.g., `https://app.example.com/oauth/callback`).\n\n---\n\n## AWS resources to provision\n\n### Networking\n- Amazon VPC\n- Public subnets (at least 2 AZs)\n- Private subnets (at least 2 AZs)\n- Internet Gateway (IGW)\n- NAT Gateway (in a public subnet) + Elastic IP\n- Route tables (public + private) and associations\n- Security Groups (ALB SG, ECS task SG, optional EFS SG, optional RDS SG)\n\n### DNS + TLS\n- Amazon Route 53 Hosted Zone (or records in an existing zone)\n- Route 53 Alias record to ALB\n- AWS Certificate Manager (ACM) certificate for the domain\n\n### Load balancing\n- Application Load Balancer (ALB)\n- ALB Target Group\n- ALB Listener (HTTPS :443) (+ optional HTTP :80 redirect)\n\n### Compute (container)\n- Amazon ECR repository\n- Amazon ECS Cluster\n- ECS Task Definition (Fargate)\n- ECS Service\n- IAM Role: ECS Task Execution Role (pull from ECR, write logs)\n- IAM Role: ECS Task Role (read Secrets Manager secret, optional SSM/KMS)\n\n### Secrets / configuration\n- AWS Secrets Manager secret (Google OAuth client credentials JSON)\n- AWS KMS key (optional CMK; otherwise use AWS-managed key)\n- (Optional) SSM Parameter Store parameters for non-secret config (app env, feature flags)\n\n### Data (choose one path)\n**Option A (recommended):**\n- Amazon RDS PostgreSQL instance (or Aurora PostgreSQL)\n- DB Subnet Group\n- RDS Parameter Group (optional)\n- RDS automated backups + (optional) Multi-AZ\n\n**Option B (keep SQLite):**\n- Amazon EFS file system\n- EFS Mount Targets (one per AZ)\n- EFS Access Point (recommended)\n\n### Observability + security baseline\n- Amazon CloudWatch Log Group(s)\n- CloudWatch Alarms (ALB 5XX, target health, ECS CPU/memory)\n- AWS CloudTrail (account-level auditing)\n- AWS Config (optional, if you need compliance drift detection)\n\n### CI/CD (optional but typical)\n- AWS CodeBuild project\n- AWS CodePipeline pipeline\n- IAM roles for CodeBuild/CodePipeline\n- (Optional) S3 bucket for pipeline artifacts",
  "aws_resources": [
    "Amazon VPC",
    "Public Subnets (2+ AZs)",
    "Private Subnets (2+ AZs)",
    "Internet Gateway",
    "NAT Gateway",
    "Elastic IP (for NAT)",
    "Route Tables and Route Associations",
    "Security Groups (ALB, ECS Tasks, optional EFS, optional RDS)",
    "Amazon Route 53 Hosted Zone / DNS Records",
    "AWS Certificate Manager (ACM) Certificate",
    "Application Load Balancer (ALB)",
    "ALB Target Group",
    "ALB HTTPS Listener (and optional HTTP->HTTPS redirect listener)",
    "Amazon ECR Repository",
    "Amazon ECS Cluster",
    "ECS Fargate Task Definition",
    "ECS Fargate Service",
    "IAM Role: ECS Task Execution Role",
    "IAM Role: ECS Task Role",
    "AWS Secrets Manager Secret (Google OAuth client_secret.json contents)",
    "AWS KMS Key (optional CMK for secrets)",
    "Amazon CloudWatch Log Groups",
    "Amazon CloudWatch Alarms",
    "AWS CloudTrail",
    "(Optional) AWS Systems Manager Parameter Store",
    "(Option A) Amazon RDS for PostgreSQL (or Aurora PostgreSQL)",
    "(Option A) RDS DB Subnet Group",
    "(Option A) RDS Parameter Group (optional)",
    "(Option B) Amazon EFS File System",
    "(Option B) EFS Mount Targets",
    "(Option B) EFS Access Point",
    "(Optional) AWS CodeBuild",
    "(Optional) AWS CodePipeline",
    "(Optional) S3 Bucket for CI/CD artifacts"
  ]
}