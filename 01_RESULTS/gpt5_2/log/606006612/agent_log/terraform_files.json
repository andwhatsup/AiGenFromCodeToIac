{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = var.tags\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"name\" {\n  description = \"Base name/prefix for resources.\"\n  type        = string\n  default     = \"java-mongo-ecs\"\n}\n\nvariable \"tags\" {\n  description = \"Tags applied to all taggable resources.\"\n  type        = map(string)\n  default = {\n    Project = \"java-mongo-ecs\"\n  }\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"Public subnet CIDRs (length must be >= az_count).\"\n  type        = list(string)\n  default     = [\"10.0.0.0/24\", \"10.0.1.0/24\"]\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"Private subnet CIDRs (length must be >= az_count).\"\n  type        = list(string)\n  default     = [\"10.0.10.0/24\", \"10.0.11.0/24\"]\n}\n\nvariable \"single_nat_gateway\" {\n  description = \"Use a single NAT gateway (lower cost) instead of one per AZ.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"enable_vpc_endpoints\" {\n  description = \"Create interface/gateway VPC endpoints for ECR/Logs/Secrets/STS/S3 to reduce NAT usage.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name.\"\n  type        = string\n  default     = null\n}\n\nvariable \"container_image\" {\n  description = \"Full container image URI (including tag) to run in ECS. If null, uses the created ECR repo with image_tag.\"\n  type        = string\n  default     = null\n}\n\nvariable \"image_tag\" {\n  description = \"Image tag to use when container_image is null.\"\n  type        = string\n  default     = \"latest\"\n}\n\nvariable \"cpu\" {\n  description = \"Fargate task CPU units.\"\n  type        = number\n  default     = 256\n}\n\nvariable \"memory\" {\n  description = \"Fargate task memory (MiB).\"\n  type        = number\n  default     = 512\n}\n\nvariable \"desired_count\" {\n  description = \"Desired number of tasks.\"\n  type        = number\n  default     = 1\n}\n\nvariable \"log_retention_days\" {\n  description = \"CloudWatch log retention in days.\"\n  type        = number\n  default     = 14\n}\n\nvariable \"mongodb_uri\" {\n  description = \"MongoDB connection string. If null, you must set mongodb_uri_secret_arn.\"\n  type        = string\n  default     = null\n  sensitive   = true\n}\n\nvariable \"mongodb_uri_secret_arn\" {\n  description = \"Existing Secrets Manager secret ARN containing MONGODB_URI. If set, Terraform will not create a new secret.\"\n  type        = string\n  default     = null\n}\n\nvariable \"mongodb_port\" {\n  description = \"MongoDB port (Atlas typically 27017).\"\n  type        = number\n  default     = 27017\n}\n\nvariable \"mongodb_allowed_cidrs\" {\n  description = \"Optional egress restriction: CIDRs allowed for MongoDB traffic. If empty, allows all egress (0.0.0.0/0).\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"assign_public_ip\" {\n  description = \"Assign public IPs to tasks (not recommended; keep false for private subnets).\"\n  type        = bool\n  default     = false\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  ecr_repo_name = coalesce(var.ecr_repository_name, \"${var.name}-repo\")\n\n  # If user provides a full image URI, use it; otherwise use the created ECR repo.\n  image_uri = var.container_image != null ? var.container_image : \"${aws_ecr_repository.app.repository_url}:${var.image_tag}\"\n\n  create_secret = var.mongodb_uri_secret_arn == null\n}\n"
    },
    {
      "name": "network.tf",
      "content": "resource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"${var.name}-vpc\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${var.name}-igw\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : az => {\n    az   = az\n    cidr = var.public_subnet_cidrs[idx]\n  } }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.value.az\n  cidr_block              = each.value.cidr\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${var.name}-public-${each.value.az}\"\n    Tier = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : az => {\n    az   = az\n    cidr = var.private_subnet_cidrs[idx]\n  } }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.value.az\n  cidr_block              = each.value.cidr\n  map_public_ip_on_launch = false\n\n  tags = {\n    Name = \"${var.name}-private-${each.value.az}\"\n    Tier = \"private\"\n  }\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${var.name}-public-rt\"\n  }\n}\n\nresource \"aws_route\" \"public_default\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_eip\" \"nat\" {\n  count  = var.single_nat_gateway ? 1 : length(local.azs)\n  domain = \"vpc\"\n\n  tags = {\n    Name = \"${var.name}-nat-eip-${count.index}\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  count = var.single_nat_gateway ? 1 : length(local.azs)\n\n  allocation_id = aws_eip.nat[count.index].id\n  subnet_id     = values(aws_subnet.public)[var.single_nat_gateway ? 0 : count.index].id\n\n  tags = {\n    Name = \"${var.name}-nat-${count.index}\"\n  }\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  for_each = aws_subnet.private\n\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${var.name}-private-rt-${each.key}\"\n  }\n}\n\nresource \"aws_route\" \"private_default\" {\n  for_each = aws_route_table.private\n\n  route_table_id         = each.value.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.this[var.single_nat_gateway ? 0 : index(local.azs, each.key)].id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private[each.key].id\n}\n"
    },
    {
      "name": "ecr.tf",
      "content": "resource \"aws_ecr_repository\" \"app\" {\n  name                 = local.ecr_repo_name\n  image_tag_mutability = \"IMMUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n\n  tags = {\n    Name = \"${var.name}-ecr\"\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"app\" {\n  repository = aws_ecr_repository.app.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Expire untagged images older than 14 days\"\n        selection = {\n          tagStatus   = \"untagged\"\n          countType   = \"sinceImagePushed\"\n          countUnit   = \"days\"\n          countNumber = 14\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "logs.tf",
      "content": "resource \"aws_cloudwatch_log_group\" \"app\" {\n  name              = \"/ecs/${var.name}\"\n  retention_in_days = var.log_retention_days\n\n  tags = {\n    Name = \"${var.name}-logs\"\n  }\n}\n"
    },
    {
      "name": "secrets.tf",
      "content": "resource \"aws_secretsmanager_secret\" \"mongodb_uri\" {\n  count = local.create_secret ? 1 : 0\n\n  name                    = \"${var.name}/mongodb_uri\"\n  recovery_window_in_days = 7\n\n  tags = {\n    Name = \"${var.name}-mongodb-uri\"\n  }\n}\n\nresource \"aws_secretsmanager_secret_version\" \"mongodb_uri\" {\n  count = local.create_secret && var.mongodb_uri != null ? 1 : 0\n\n  secret_id     = aws_secretsmanager_secret.mongodb_uri[0].id\n  secret_string = var.mongodb_uri\n}\n\nlocals {\n  mongodb_secret_arn = local.create_secret ? aws_secretsmanager_secret.mongodb_uri[0].arn : var.mongodb_uri_secret_arn\n}\n"
    },
    {
      "name": "iam.tf",
      "content": "data \"aws_iam_policy_document\" \"ecs_task_assume\" {\n  statement {\n    effect = \"Allow\"\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"ecs-tasks.amazonaws.com\"]\n    }\n\n    actions = [\"sts:AssumeRole\"]\n  }\n}\n\nresource \"aws_iam_role\" \"task_execution\" {\n  name               = \"${var.name}-task-exec\"\n  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"task_execution_managed\" {\n  role       = aws_iam_role.task_execution.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\nresource \"aws_iam_role\" \"task\" {\n  name               = \"${var.name}-task\"\n  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume.json\n}\n\ndata \"aws_iam_policy_document\" \"task_inline\" {\n  statement {\n    sid     = \"ReadMongoDbUriSecret\"\n    effect  = \"Allow\"\n    actions = [\"secretsmanager:GetSecretValue\"]\n    resources = [\n      local.mongodb_secret_arn\n    ]\n  }\n\n  # For MONGODB-AWS auth mechanism, the driver uses AWS credentials from the task role.\n  # It may call STS GetCallerIdentity; allow it.\n  statement {\n    sid     = \"AllowStsGetCallerIdentity\"\n    effect  = \"Allow\"\n    actions = [\"sts:GetCallerIdentity\"]\n    resources = [\"*\"]\n  }\n}\n\nresource \"aws_iam_policy\" \"task\" {\n  name   = \"${var.name}-task-policy\"\n  policy = data.aws_iam_policy_document.task_inline.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"task_attach\" {\n  role       = aws_iam_role.task.name\n  policy_arn = aws_iam_policy.task.arn\n}\n"
    },
    {
      "name": "ecs.tf",
      "content": "resource \"aws_ecs_cluster\" \"this\" {\n  name = \"${var.name}-cluster\"\n\n  setting {\n    name  = \"containerInsights\"\n    value = \"enabled\"\n  }\n}\n\nresource \"aws_security_group\" \"ecs_tasks\" {\n  name        = \"${var.name}-tasks-sg\"\n  description = \"Security group for ECS tasks\"\n  vpc_id      = aws_vpc.this.id\n\n  # No inbound rules for a worker/console app.\n\n  egress {\n    description = \"MongoDB egress\"\n    from_port   = var.mongodb_port\n    to_port     = var.mongodb_port\n    protocol    = \"tcp\"\n    cidr_blocks = length(var.mongodb_allowed_cidrs) > 0 ? var.mongodb_allowed_cidrs : [\"0.0.0.0/0\"]\n  }\n\n  # Allow HTTPS egress for AWS APIs (ECR, Logs, Secrets) when using NAT.\n  egress {\n    description = \"HTTPS egress\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${var.name}-tasks-sg\"\n  }\n}\n\nresource \"aws_ecs_task_definition\" \"app\" {\n  family                   = var.name\n  requires_compatibilities = [\"FARGATE\"]\n  network_mode             = \"awsvpc\"\n  cpu                      = tostring(var.cpu)\n  memory                   = tostring(var.memory)\n  execution_role_arn       = aws_iam_role.task_execution.arn\n  task_role_arn            = aws_iam_role.task.arn\n\n  runtime_platform {\n    operating_system_family = \"LINUX\"\n    cpu_architecture        = \"X86_64\"\n  }\n\n  container_definitions = jsonencode([\n    {\n      name      = \"app\"\n      image     = local.image_uri\n      essential = true\n\n      environment = [\n        {\n          name  = \"AWS_REGION\"\n          value = var.aws_region\n        }\n      ]\n\n      secrets = [\n        {\n          name      = \"MONGODB_URI\"\n          valueFrom = local.mongodb_secret_arn\n        }\n      ]\n\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.app.name\n          awslogs-region        = var.aws_region\n          awslogs-stream-prefix = \"ecs\"\n        }\n      }\n    }\n  ])\n\n  depends_on = [aws_cloudwatch_log_group.app]\n}\n\nresource \"aws_ecs_service\" \"app\" {\n  name            = \"${var.name}-svc\"\n  cluster         = aws_ecs_cluster.this.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = var.desired_count\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets          = [for s in aws_subnet.private : s.id]\n    security_groups  = [aws_security_group.ecs_tasks.id]\n    assign_public_ip = var.assign_public_ip\n  }\n\n  deployment_minimum_healthy_percent = 50\n  deployment_maximum_percent         = 200\n\n  enable_ecs_managed_tags = true\n  propagate_tags          = \"SERVICE\"\n\n  lifecycle {\n    ignore_changes = [task_definition]\n  }\n}\n"
    },
    {
      "name": "vpc_endpoints.tf",
      "content": "resource \"aws_security_group\" \"vpce\" {\n  count = var.enable_vpc_endpoints ? 1 : 0\n\n  name        = \"${var.name}-vpce-sg\"\n  description = \"Security group for VPC interface endpoints\"\n  vpc_id      = aws_vpc.this.id\n\n  ingress {\n    description = \"Allow HTTPS from VPC\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [aws_vpc.this.cidr_block]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\ndata \"aws_region\" \"current\" {}\n\nlocals {\n  interface_endpoints = [\n    \"com.amazonaws.${data.aws_region.current.name}.ecr.api\",\n    \"com.amazonaws.${data.aws_region.current.name}.ecr.dkr\",\n    \"com.amazonaws.${data.aws_region.current.name}.logs\",\n    \"com.amazonaws.${data.aws_region.current.name}.secretsmanager\",\n    \"com.amazonaws.${data.aws_region.current.name}.sts\",\n  ]\n}\n\nresource \"aws_vpc_endpoint\" \"interface\" {\n  for_each = var.enable_vpc_endpoints ? toset(local.interface_endpoints) : toset([])\n\n  vpc_id              = aws_vpc.this.id\n  service_name        = each.value\n  vpc_endpoint_type   = \"Interface\"\n  private_dns_enabled = true\n\n  subnet_ids         = [for s in aws_subnet.private : s.id]\n  security_group_ids = [aws_security_group.vpce[0].id]\n}\n\nresource \"aws_vpc_endpoint\" \"s3\" {\n  count = var.enable_vpc_endpoints ? 1 : 0\n\n  vpc_id            = aws_vpc.this.id\n  service_name      = \"com.amazonaws.${data.aws_region.current.name}.s3\"\n  vpc_endpoint_type = \"Gateway\"\n\n  route_table_ids = [for rt in aws_route_table.private : rt.id]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value       = aws_vpc.this.id\n  description = \"VPC ID\"\n}\n\noutput \"private_subnet_ids\" {\n  value       = [for s in aws_subnet.private : s.id]\n  description = \"Private subnet IDs\"\n}\n\noutput \"public_subnet_ids\" {\n  value       = [for s in aws_subnet.public : s.id]\n  description = \"Public subnet IDs\"\n}\n\noutput \"ecr_repository_url\" {\n  value       = aws_ecr_repository.app.repository_url\n  description = \"ECR repository URL\"\n}\n\noutput \"ecs_cluster_name\" {\n  value       = aws_ecs_cluster.this.name\n  description = \"ECS cluster name\"\n}\n\noutput \"ecs_service_name\" {\n  value       = aws_ecs_service.app.name\n  description = \"ECS service name\"\n}\n\noutput \"cloudwatch_log_group_name\" {\n  value       = aws_cloudwatch_log_group.app.name\n  description = \"CloudWatch log group name\"\n}\n\noutput \"mongodb_uri_secret_arn\" {\n  value       = local.mongodb_secret_arn\n  description = \"Secrets Manager secret ARN containing MONGODB_URI\"\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "aws_region = \"us-east-1\"\nname       = \"java-mongo-ecs\"\n\n# Provide ONE of the following:\n# 1) Let Terraform create the secret and set its value:\nmongodb_uri = \"mongodb+srv://.../?authMechanism=MONGODB-AWS\"\n\n# 2) Or reference an existing secret:\n# mongodb_uri_secret_arn = \"arn:aws:secretsmanager:us-east-1:123456789012:secret:java-mongo-ecs/mongodb_uri-xxxx\"\n\n# If you want to restrict MongoDB egress, set Atlas IP/CIDR ranges here.\n# mongodb_allowed_cidrs = [\"203.0.113.10/32\"]\n\n# If you already pushed an image to ECR, you can set image_tag.\nimage_tag = \"latest\"\n\n# Or provide a full image URI (e.g., from another account/registry):\n# container_image = \"123456789012.dkr.ecr.us-east-1.amazonaws.com/java-mongo-ecs-repo:latest\"\n\n# VPC endpoints are optional; NAT is used by default.\n# enable_vpc_endpoints = true\n"
    },
    {
      "name": "README_TERRAFORM.md",
      "content": "# Terraform: Java MongoDB Client on ECS Fargate\n\n## What this deploys\n- VPC with public + private subnets\n- NAT gateway (single by default)\n- ECR repository (immutable tags + scan on push + lifecycle policy)\n- CloudWatch log group\n- Secrets Manager secret for `MONGODB_URI` (optional: use existing secret)\n- ECS cluster + Fargate task definition + ECS service (no load balancer)\n\n## Prereqs\n- Terraform >= 1.6\n- AWS credentials configured (e.g., `aws sso login` or env vars)\n\n## Usage\n1. Copy example vars:\n   ```bash\n   cp terraform.tfvars.example terraform.tfvars\n   ```\n2. Set `mongodb_uri` (or `mongodb_uri_secret_arn`).\n3. Build and push your image to ECR:\n   - After `terraform apply`, use output `ecr_repository_url`.\n4. Deploy:\n   ```bash\n   terraform init\n   terraform apply\n   ```\n\n## Notes\n- The ECS service ignores task_definition changes to avoid forced redeploys on every plan when using mutable tags. If you use immutable tags (recommended), you can remove the lifecycle ignore and update task definition on new image tags.\n- For MongoDB Atlas allow-listing, you can use the NAT gateway EIP(s) created by this stack.\n"
    }
  ]
}