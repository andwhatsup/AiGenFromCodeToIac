{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project\" {\n  description = \"Project/name prefix used for tagging and resource names.\"\n  type        = string\n  default     = \"nodeaws\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n  validation {\n    condition     = var.az_count >= 2 && var.az_count <= 3\n    error_message = \"az_count must be between 2 and 3.\"\n  }\n}\n\nvariable \"cluster_name\" {\n  description = \"EKS cluster name.\"\n  type        = string\n  default     = \"nawy-eks-cluster\"\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name used by the Kubernetes deployment.\"\n  type        = string\n  default     = \"my-ecr-repo\"\n}\n\nvariable \"node_instance_types\" {\n  description = \"Instance types for the EKS managed node group.\"\n  type        = list(string)\n  default     = [\"t3.medium\"]\n}\n\nvariable \"node_desired_size\" {\n  description = \"Desired number of worker nodes.\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_min_size\" {\n  description = \"Minimum number of worker nodes.\"\n  type        = number\n  default     = 1\n}\n\nvariable \"node_max_size\" {\n  description = \"Maximum number of worker nodes.\"\n  type        = number\n  default     = 4\n}\n\nvariable \"enable_cluster_public_endpoint\" {\n  description = \"Whether the EKS API server endpoint is publicly accessible.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"cluster_public_access_cidrs\" {\n  description = \"CIDRs allowed to access the public EKS API endpoint. Restrict in real environments.\"\n  type        = list(string)\n  default     = [\"0.0.0.0/0\"]\n}\n\nvariable \"single_nat_gateway\" {\n  description = \"Use a single NAT gateway to reduce cost (not HA).\"\n  type        = bool\n  default     = true\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "locals {\n  name_prefix = \"${var.project}-${var.environment}\"\n\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # Derive /24 subnets from the VPC /16.\n  # public:  10.0.0.0/24, 10.0.1.0/24\n  # private: 10.0.100.0/24, 10.0.101.0/24\n  public_subnet_cidrs  = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i)]\n  private_subnet_cidrs = [for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, 100 + i)]\n\n  tags = {\n    Project     = var.project\n    Environment = var.environment\n  }\n}\n"
    },
    {
      "name": "network.tf",
      "content": "resource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-vpc\"\n  })\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-igw\"\n  })\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.key\n  cidr_block              = local.public_subnet_cidrs[each.value]\n  map_public_ip_on_launch = true\n\n  tags = merge(local.tags, {\n    Name                     = \"${local.name_prefix}-public-${each.key}\"\n    \"kubernetes.io/role/elb\" = \"1\"\n  })\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id            = aws_vpc.this.id\n  availability_zone = each.key\n  cidr_block        = local.private_subnet_cidrs[each.value]\n\n  tags = merge(local.tags, {\n    Name                              = \"${local.name_prefix}-private-${each.key}\"\n    \"kubernetes.io/role/internal-elb\" = \"1\"\n  })\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-public-rt\"\n  })\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_eip\" \"nat\" {\n  for_each = var.single_nat_gateway ? { \"single\" = 0 } : { for idx, az in local.azs : az => idx }\n\n  domain = \"vpc\"\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-nat-eip-${each.key}\"\n  })\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  for_each = var.single_nat_gateway ? { \"single\" = 0 } : { for idx, az in local.azs : az => idx }\n\n  allocation_id = aws_eip.nat[each.key].id\n  subnet_id     = var.single_nat_gateway ? values(aws_subnet.public)[0].id : aws_subnet.public[each.key].id\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-nat-${each.key}\"\n  })\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  for_each = aws_subnet.private\n\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-private-rt-${each.key}\"\n  })\n}\n\nresource \"aws_route\" \"private_nat\" {\n  for_each = aws_route_table.private\n\n  route_table_id         = each.value.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = var.single_nat_gateway ? aws_nat_gateway.this[\"single\"].id : aws_nat_gateway.this[each.key].id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private[each.key].id\n}\n"
    },
    {
      "name": "ecr.tf",
      "content": "resource \"aws_ecr_repository\" \"app\" {\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-ecr\"\n  })\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"app\" {\n  repository = aws_ecr_repository.app.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last 30 images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = 30\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "eks.tf",
      "content": "data \"aws_iam_policy_document\" \"eks_cluster_assume\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"sts:AssumeRole\",\n    ]\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"eks.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"eks_cluster\" {\n  name               = \"${local.name_prefix}-eks-cluster-role\"\n  assume_role_policy = data.aws_iam_policy_document.eks_cluster_assume.json\n\n  tags = local.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_cluster_AmazonEKSClusterPolicy\" {\n  role       = aws_iam_role.eks_cluster.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEKSClusterPolicy\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_cluster_AmazonEKSVPCResourceController\" {\n  role       = aws_iam_role.eks_cluster.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEKSVPCResourceController\"\n}\n\nresource \"aws_security_group\" \"eks_cluster\" {\n  name        = \"${local.name_prefix}-eks-cluster-sg\"\n  description = \"EKS cluster security group\"\n  vpc_id      = aws_vpc.this.id\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-eks-cluster-sg\"\n  })\n}\n\nresource \"aws_eks_cluster\" \"this\" {\n  name     = var.cluster_name\n  role_arn = aws_iam_role.eks_cluster.arn\n\n  vpc_config {\n    subnet_ids              = concat(values(aws_subnet.public)[*].id, values(aws_subnet.private)[*].id)\n    security_group_ids      = [aws_security_group.eks_cluster.id]\n    endpoint_public_access  = var.enable_cluster_public_endpoint\n    endpoint_private_access = true\n    public_access_cidrs     = var.cluster_public_access_cidrs\n  }\n\n  enabled_cluster_log_types = [\n    \"api\",\n    \"audit\",\n    \"authenticator\",\n    \"controllerManager\",\n    \"scheduler\",\n  ]\n\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_cluster_AmazonEKSClusterPolicy,\n    aws_iam_role_policy_attachment.eks_cluster_AmazonEKSVPCResourceController,\n  ]\n\n  tags = merge(local.tags, {\n    Name = var.cluster_name\n  })\n}\n\ndata \"aws_iam_policy_document\" \"eks_node_assume\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"sts:AssumeRole\",\n    ]\n\n    principals {\n      type        = \"Service\"\n      identifiers = [\"ec2.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"eks_node\" {\n  name               = \"${local.name_prefix}-eks-node-role\"\n  assume_role_policy = data.aws_iam_policy_document.eks_node_assume.json\n\n  tags = local.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEKSWorkerNodePolicy\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEKS_CNI_Policy\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy\"\n}\n\nresource \"aws_iam_role_policy_attachment\" \"eks_node_AmazonEC2ContainerRegistryReadOnly\" {\n  role       = aws_iam_role.eks_node.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly\"\n}\n\nresource \"aws_security_group\" \"eks_nodes\" {\n  name        = \"${local.name_prefix}-eks-nodes-sg\"\n  description = \"EKS worker nodes security group\"\n  vpc_id      = aws_vpc.this.id\n\n  ingress {\n    description = \"Node to node all ports/protocols\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    self        = true\n  }\n\n  ingress {\n    description     = \"Control plane to nodes\"\n    from_port       = 0\n    to_port         = 0\n    protocol        = \"-1\"\n    security_groups = [aws_security_group.eks_cluster.id]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-eks-nodes-sg\"\n  })\n}\n\nresource \"aws_eks_node_group\" \"default\" {\n  cluster_name    = aws_eks_cluster.this.name\n  node_group_name = \"${local.name_prefix}-ng\"\n  node_role_arn   = aws_iam_role.eks_node.arn\n  subnet_ids      = values(aws_subnet.private)[*].id\n\n  instance_types = var.node_instance_types\n\n  scaling_config {\n    desired_size = var.node_desired_size\n    min_size     = var.node_min_size\n    max_size     = var.node_max_size\n  }\n\n  update_config {\n    max_unavailable = 1\n  }\n\n  remote_access {\n    ec2_ssh_key = null\n  }\n\n  tags = merge(local.tags, {\n    Name = \"${local.name_prefix}-node-group\"\n  })\n\n  depends_on = [\n    aws_iam_role_policy_attachment.eks_node_AmazonEKSWorkerNodePolicy,\n    aws_iam_role_policy_attachment.eks_node_AmazonEKS_CNI_Policy,\n    aws_iam_role_policy_attachment.eks_node_AmazonEC2ContainerRegistryReadOnly,\n  ]\n}\n\nresource \"aws_eks_addon\" \"vpc_cni\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"vpc-cni\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n\nresource \"aws_eks_addon\" \"coredns\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"coredns\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n\nresource \"aws_eks_addon\" \"kube_proxy\" {\n  cluster_name = aws_eks_cluster.this.name\n  addon_name   = \"kube-proxy\"\n\n  depends_on = [aws_eks_node_group.default]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"region\" {\n  value       = var.aws_region\n  description = \"AWS region.\"\n}\n\noutput \"vpc_id\" {\n  value       = aws_vpc.this.id\n  description = \"VPC ID.\"\n}\n\noutput \"public_subnet_ids\" {\n  value       = values(aws_subnet.public)[*].id\n  description = \"Public subnet IDs.\"\n}\n\noutput \"private_subnet_ids\" {\n  value       = values(aws_subnet.private)[*].id\n  description = \"Private subnet IDs.\"\n}\n\noutput \"ecr_repository_url\" {\n  value       = aws_ecr_repository.app.repository_url\n  description = \"ECR repository URL (use in Kubernetes deployment image).\"\n}\n\noutput \"eks_cluster_name\" {\n  value       = aws_eks_cluster.this.name\n  description = \"EKS cluster name.\"\n}\n\noutput \"eks_cluster_endpoint\" {\n  value       = aws_eks_cluster.this.endpoint\n  description = \"EKS cluster API endpoint.\"\n}\n\noutput \"eks_cluster_ca\" {\n  value       = aws_eks_cluster.this.certificate_authority[0].data\n  description = \"Base64 encoded cluster CA.\"\n  sensitive   = true\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region  = \"us-east-1\"\nproject     = \"nodeaws\"\nenvironment = \"dev\"\n\ncluster_name         = \"nawy-eks-cluster\"\necr_repository_name  = \"my-ecr-repo\"\n\n# Restrict this in real environments.\ncluster_public_access_cidrs = [\"0.0.0.0/0\"]\n\n# Cost-optimized default.\nsingle_nat_gateway = true\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform: Node.js on EKS (ECR + EKS + VPC)\n\nThis Terraform creates:\n- VPC with public/private subnets and NAT\n- ECR repository `my-ecr-repo`\n- EKS cluster `nawy-eks-cluster` + managed node group\n- EKS managed add-ons (vpc-cni, coredns, kube-proxy)\n\nKubernetes manifests in `Kubernetes/` can be applied by CI after the cluster exists.\n\n## Usage\n\n```bash\ncd ai_tf\nterraform init\nterraform validate\nterraform plan\n```\n\n## Notes\n- The Kubernetes `Service` is `type: LoadBalancer`, which will create an AWS load balancer when applied.\n- For production, restrict `cluster_public_access_cidrs` and consider enabling private-only endpoint.\n"
    }
  ]
}