{
  "aws_architecture_description": "## Proposed high-level AWS architecture (Tuya → Lambda → InfluxDB → Grafana)\n\n### 1) Container-based ingestion on AWS Lambda\n- **AWS Lambda (container image, Python 3.11)** runs `main.handler` on a schedule to:\n  1) call **Tuya Cloud API** over HTTPS using `tinytuya` and Tuya API credentials, and\n  2) write time-series points to **InfluxDB 2.x** using `influxdb-client`.\n- The Lambda container image is built from the repo’s Dockerfile and pushed to **Amazon ECR**. Lambda is configured to deploy from that ECR image.\n\n### 2) Scheduling / orchestration\n- Use **Amazon EventBridge Scheduler** (or EventBridge rule) to invoke the Lambda on a fixed cadence (e.g., every 1–5 minutes depending on Tuya rate limits and desired granularity).\n- Configure **Lambda reserved concurrency** (often 1) to prevent overlapping polls/writes unless the code is explicitly idempotent and safe for parallel runs.\n\n### 3) Secrets and configuration\n- Store **Tuya API key/secret** and **InfluxDB token** in **AWS Secrets Manager**.\n- Lambda reads secrets at runtime (or on cold start) using an IAM role with least-privilege access.\n- Non-secret config (InfluxDB org/bucket, region, etc.) stays in Lambda environment variables.\n\n### 4) InfluxDB + Grafana hosting on AWS (recommended vs. “public VM”)\nBecause the current design implies an internet-reachable VM, the AWS-native approach is:\n\n**Option A (lean, closest to current docker-compose): Single EC2 host running Docker Compose**\n- Run **InfluxDB 2.x** and **Grafana** on one **EC2 instance** (Amazon Linux 2023 or Ubuntu) using Docker Compose.\n- Persist data on **EBS volumes** (separate volumes recommended: one for InfluxDB, one for Grafana).\n- Put the instance in **private subnets**.\n- Expose Grafana to operators via an **Application Load Balancer (ALB)** in public subnets with **ACM TLS**.\n- Keep InfluxDB **not publicly accessible**; only allow:\n  - Grafana → InfluxDB within the VPC, and\n  - Lambda → InfluxDB via VPC networking.\n\n**Option B (more scalable/managed): ECS on Fargate for Grafana + InfluxDB**\n- Run both containers as **ECS services** (Fargate) with persistent storage:\n  - InfluxDB typically needs durable storage; this can be done with **EFS** (or EC2-backed ECS with EBS). \n- ALB fronts Grafana; InfluxDB stays internal.\n- This is more “cloud-native” but can be more complex than Option A.\n\nGiven your repo already uses docker-compose and the system is small, **Option A** is usually the best starting point.\n\n### 5) Networking (secure connectivity from Lambda to InfluxDB)\n- Place Lambda in the same **VPC** as the InfluxDB/Grafana host (private subnets).\n- Add **VPC endpoints** so Lambda can still reach AWS services without public internet:\n  - **ECR (api + dkr)** endpoints so Lambda can pull the container image,\n  - **CloudWatch Logs** endpoint,\n  - **Secrets Manager** endpoint.\n- For outbound calls to **Tuya Cloud API**, provide egress via a **NAT Gateway** (private subnets → NAT → Internet Gateway). \n- Security groups:\n  - Lambda SG: egress allowed to Tuya (0.0.0.0/0 via NAT) and to InfluxDB port internally.\n  - InfluxDB SG: allow inbound only from Lambda SG and Grafana SG.\n  - Grafana SG: allow inbound only from ALB SG.\n\n### 6) Observability and operations\n- **CloudWatch Logs** for Lambda logs.\n- **CloudWatch metrics/alarms** for Lambda errors/throttles/duration and for EC2 (via CloudWatch Agent).\n- Optional: **AWS X-Ray** for tracing Lambda outbound calls.\n\n### 7) CI/CD (minimal)\n- Use **CodeBuild/CodePipeline** (or GitHub Actions) to:\n  1) build the Lambda container image,\n  2) push to ECR,\n  3) update the Lambda function to the new image digest.\n\n---\n\n## Notes on security posture\n- Do **not** expose InfluxDB publicly; keep it internal.\n- Put Grafana behind ALB + TLS and restrict access (IP allowlist, SSO/OIDC, or at least strong auth).\n- Use Secrets Manager for tokens/keys; avoid plaintext env vars for secrets.\n",
  "aws_resources": [
    "Amazon ECR repository (for Lambda container image)",
    "AWS Lambda function (container image)",
    "IAM role for Lambda execution (least privilege)",
    "IAM policy allowing: Secrets Manager GetSecretValue, CloudWatch Logs, (optional) X-Ray, VPC access",
    "Amazon EventBridge Scheduler (or EventBridge Rule) to trigger Lambda",
    "AWS Secrets Manager secrets (Tuya API key/secret, InfluxDB token)",
    "Amazon VPC",
    "VPC subnets: 2x public subnets (multi-AZ)",
    "VPC subnets: 2x private subnets (multi-AZ)",
    "Internet Gateway (IGW)",
    "NAT Gateway (in a public subnet)",
    "Elastic IP for NAT Gateway",
    "Route tables (public + private) and routes (0.0.0.0/0 via IGW/NAT)",
    "Security Groups: Lambda SG, InfluxDB/Grafana host SG, ALB SG",
    "VPC Interface Endpoints (PrivateLink): ECR API",
    "VPC Interface Endpoints (PrivateLink): ECR DKR",
    "VPC Interface Endpoints (PrivateLink): Secrets Manager",
    "VPC Interface Endpoints (PrivateLink): CloudWatch Logs",
    "(Optional) VPC Interface Endpoint: X-Ray",
    "Amazon EC2 instance (Docker host for InfluxDB + Grafana)",
    "Amazon EBS volumes (InfluxDB data)",
    "Amazon EBS volumes (Grafana data)",
    "EC2 IAM instance profile/role (SSM + CloudWatch Agent permissions)",
    "AWS Systems Manager (SSM) managed instance configuration (for patching/remote access)",
    "Application Load Balancer (ALB) for Grafana",
    "ALB Target Group",
    "ACM certificate (TLS for Grafana domain)",
    "Amazon Route 53 hosted zone + DNS record for Grafana (if using a custom domain)",
    "CloudWatch Log Groups (Lambda)",
    "CloudWatch Alarms (Lambda errors/throttles; EC2 CPU/disk; optional ALB 5xx)",
    "(Optional) CloudWatch Agent configuration (EC2 metrics/logs)",
    "(Optional) AWS CodeBuild project (build/push image)",
    "(Optional) AWS CodePipeline pipeline (deploy Lambda image updates)"
  ]
}