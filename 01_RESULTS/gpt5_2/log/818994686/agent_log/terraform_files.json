{
  "files": [
    {
      "name": "provider.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.6\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region\"\n  type        = string\n  default     = \"us-east-2\"\n}\n\nvariable \"project\" {\n  description = \"Project/name prefix for resources\"\n  type        = string\n  default     = \"natanaelvich\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod)\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"app_port\" {\n  description = \"Container port exposed by the NestJS app\"\n  type        = number\n  default     = 3000\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name\"\n  type        = string\n  default     = \"natanaelvich-ci\"\n}\n\nvariable \"app_runner_service_name\" {\n  description = \"App Runner service name\"\n  type        = string\n  default     = \"natanaelvich-api\"\n}\n\nvariable \"db_name\" {\n  description = \"MySQL database name\"\n  type        = string\n  default     = \"rocketseat-db\"\n}\n\nvariable \"db_username\" {\n  description = \"MySQL username\"\n  type        = string\n  default     = \"admin\"\n}\n\nvariable \"db_instance_class\" {\n  description = \"RDS instance class\"\n  type        = string\n  default     = \"db.t4g.micro\"\n}\n\nvariable \"db_allocated_storage\" {\n  description = \"RDS allocated storage (GiB)\"\n  type        = number\n  default     = 20\n}\n\nvariable \"db_backup_retention_days\" {\n  description = \"RDS backup retention in days\"\n  type        = number\n  default     = 7\n}\n\nvariable \"db_multi_az\" {\n  description = \"Whether to enable Multi-AZ for RDS\"\n  type        = bool\n  default     = false\n}\n\nvariable \"db_deletion_protection\" {\n  description = \"Whether to enable deletion protection for RDS\"\n  type        = bool\n  default     = false\n}\n\nvariable \"db_publicly_accessible\" {\n  description = \"Whether the DB should be publicly accessible (should be false)\"\n  type        = bool\n  default     = false\n}\n\nvariable \"vpc_cidr\" {\n  description = \"VPC CIDR\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"Public subnet CIDRs (2 AZs)\"\n  type        = list(string)\n  default     = [\"10.20.0.0/24\", \"10.20.1.0/24\"]\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"Private subnet CIDRs (2 AZs)\"\n  type        = list(string)\n  default     = [\"10.20.10.0/24\", \"10.20.11.0/24\"]\n}\n\nvariable \"enable_nat_gateway\" {\n  description = \"Create a NAT gateway for private subnet egress (not required for RDS-only private access)\"\n  type        = bool\n  default     = false\n}\n\nvariable \"github_repo\" {\n  description = \"GitHub repository in the form owner/repo for OIDC trust (e.g., andi/myrepo). Used to create the GitHub Actions role.\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"github_branch\" {\n  description = \"GitHub branch allowed to assume the role (e.g., main)\"\n  type        = string\n  default     = \"main\"\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  name_prefix = \"${var.project}-${var.environment}\"\n  azs         = slice(data.aws_availability_zones.available.names, 0, 2)\n\n  tags = {\n    Name = local.name_prefix\n  }\n}\n"
    },
    {
      "name": "network.tf",
      "content": "resource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-vpc\" })\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-igw\" })\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, cidr in var.public_subnet_cidrs : idx => cidr }\n\n  vpc_id                  = aws_vpc.this.id\n  cidr_block              = each.value\n  availability_zone       = local.azs[tonumber(each.key)]\n  map_public_ip_on_launch = true\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-public-${each.key}\" })\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, cidr in var.private_subnet_cidrs : idx => cidr }\n\n  vpc_id            = aws_vpc.this.id\n  cidr_block        = each.value\n  availability_zone = local.azs[tonumber(each.key)]\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-private-${each.key}\" })\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-public-rt\" })\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\n# Optional NAT for private subnet egress\nresource \"aws_eip\" \"nat\" {\n  count  = var.enable_nat_gateway ? 1 : 0\n  domain = \"vpc\"\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-nat-eip\" })\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  count         = var.enable_nat_gateway ? 1 : 0\n  allocation_id = aws_eip.nat[0].id\n  subnet_id     = values(aws_subnet.public)[0].id\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-nat\" })\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-private-rt\" })\n}\n\nresource \"aws_route\" \"private_egress\" {\n  count                  = var.enable_nat_gateway ? 1 : 0\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.this[0].id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private.id\n}\n"
    },
    {
      "name": "ecr.tf",
      "content": "resource \"aws_ecr_repository\" \"api\" {\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-ecr\" })\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"api\" {\n  repository = aws_ecr_repository.api.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last 30 images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = 30\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "secrets.tf",
      "content": "resource \"random_password\" \"db\" {\n  length           = 24\n  special          = true\n  override_special = \"!#$%&*()-_=+[]{}<>:?\"\n}\n\nresource \"aws_secretsmanager_secret\" \"db\" {\n  name                    = \"${local.name_prefix}/db\"\n  recovery_window_in_days = 7\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-db-secret\" })\n}\n\nresource \"aws_secretsmanager_secret_version\" \"db\" {\n  secret_id = aws_secretsmanager_secret.db.id\n\n  secret_string = jsonencode({\n    username = var.db_username\n    password = random_password.db.result\n    dbname   = var.db_name\n  })\n}\n"
    },
    {
      "name": "rds.tf",
      "content": "resource \"aws_security_group\" \"rds\" {\n  name        = \"${local.name_prefix}-rds-sg\"\n  description = \"RDS MySQL access from App Runner VPC connector\"\n  vpc_id      = aws_vpc.this.id\n\n  ingress {\n    description     = \"MySQL from App Runner\"\n    from_port       = 3306\n    to_port         = 3306\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.apprunner_vpc_connector.id]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-rds-sg\" })\n}\n\nresource \"aws_db_subnet_group\" \"this\" {\n  name       = \"${local.name_prefix}-db-subnets\"\n  subnet_ids = [for s in aws_subnet.private : s.id]\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-db-subnets\" })\n}\n\nresource \"aws_db_parameter_group\" \"mysql8\" {\n  name   = \"${local.name_prefix}-mysql8\"\n  family = \"mysql8.0\"\n\n  parameter {\n    name  = \"character_set_server\"\n    value = \"utf8mb4\"\n  }\n\n  parameter {\n    name  = \"collation_server\"\n    value = \"utf8mb4_unicode_ci\"\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-mysql8\" })\n}\n\nresource \"aws_db_instance\" \"mysql\" {\n  identifier = \"${local.name_prefix}-mysql\"\n\n  engine               = \"mysql\"\n  engine_version       = \"8.0\"\n  instance_class       = var.db_instance_class\n  allocated_storage    = var.db_allocated_storage\n  storage_type         = \"gp3\"\n  storage_encrypted    = true\n\n  db_name  = var.db_name\n  username = var.db_username\n  password = random_password.db.result\n\n  db_subnet_group_name   = aws_db_subnet_group.this.name\n  vpc_security_group_ids = [aws_security_group.rds.id]\n\n  publicly_accessible = var.db_publicly_accessible\n  multi_az            = var.db_multi_az\n\n  backup_retention_period = var.db_backup_retention_days\n  skip_final_snapshot     = true\n  deletion_protection     = var.db_deletion_protection\n\n  parameter_group_name = aws_db_parameter_group.mysql8.name\n\n  # Minor version upgrades are safe; major upgrades should be planned.\n  auto_minor_version_upgrade = true\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-mysql\" })\n}\n"
    },
    {
      "name": "apprunner.tf",
      "content": "resource \"aws_security_group\" \"apprunner_vpc_connector\" {\n  name        = \"${local.name_prefix}-apprunner-connector-sg\"\n  description = \"Security group attached to App Runner VPC connector\"\n  vpc_id      = aws_vpc.this.id\n\n  # App Runner tasks need to reach RDS (and optionally other private resources)\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-apprunner-connector-sg\" })\n}\n\nresource \"aws_apprunner_vpc_connector\" \"this\" {\n  vpc_connector_name = \"${local.name_prefix}-connector\"\n  subnets            = [for s in aws_subnet.private : s.id]\n  security_groups    = [aws_security_group.apprunner_vpc_connector.id]\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-connector\" })\n}\n\nresource \"aws_iam_role\" \"apprunner_ecr_access\" {\n  name = \"${local.name_prefix}-apprunner-ecr-access\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"build.apprunner.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n\n  tags = local.tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"apprunner_ecr_access\" {\n  role       = aws_iam_role.apprunner_ecr_access.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/service-role/AWSAppRunnerServicePolicyForECRAccess\"\n}\n\nresource \"aws_iam_role\" \"apprunner_instance\" {\n  name = \"${local.name_prefix}-apprunner-instance\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"tasks.apprunner.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n\n  tags = local.tags\n}\n\nresource \"aws_iam_role_policy\" \"apprunner_instance_secrets\" {\n  name = \"${local.name_prefix}-apprunner-secrets\"\n  role = aws_iam_role.apprunner_instance.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"ReadDbSecret\"\n        Effect = \"Allow\"\n        Action = [\n          \"secretsmanager:GetSecretValue\",\n          \"secretsmanager:DescribeSecret\"\n        ]\n        Resource = aws_secretsmanager_secret.db.arn\n      }\n    ]\n  })\n}\n\nresource \"aws_apprunner_service\" \"api\" {\n  service_name = var.app_runner_service_name\n\n  source_configuration {\n    authentication_configuration {\n      access_role_arn = aws_iam_role.apprunner_ecr_access.arn\n    }\n\n    image_repository {\n      image_identifier      = \"${aws_ecr_repository.api.repository_url}:latest\"\n      image_repository_type = \"ECR\"\n\n      image_configuration {\n        port = tostring(var.app_port)\n\n        runtime_environment_variables = {\n          NODE_ENV = \"production\"\n          DB_HOST  = aws_db_instance.mysql.address\n          DB_PORT  = \"3306\"\n          DB_NAME  = var.db_name\n          DB_USER  = var.db_username\n        }\n\n        # App Runner supports Secrets Manager references for env vars.\n        runtime_environment_secrets = {\n          DB_PASSWORD = aws_secretsmanager_secret.db.arn\n        }\n      }\n    }\n\n    auto_deployments_enabled = true\n  }\n\n  instance_configuration {\n    cpu               = \"1024\"\n    memory            = \"2048\"\n    instance_role_arn = aws_iam_role.apprunner_instance.arn\n  }\n\n  network_configuration {\n    egress_configuration {\n      egress_type      = \"VPC\"\n      vpc_connector_arn = aws_apprunner_vpc_connector.this.arn\n    }\n  }\n\n  health_check_configuration {\n    protocol            = \"TCP\"\n    interval            = 10\n    timeout             = 5\n    healthy_threshold   = 1\n    unhealthy_threshold = 5\n  }\n\n  tags = merge(local.tags, { Name = \"${local.name_prefix}-apprunner\" })\n\n  depends_on = [aws_iam_role_policy_attachment.apprunner_ecr_access]\n}\n"
    },
    {
      "name": "github_oidc.tf",
      "content": "# Optional: GitHub Actions OIDC role for pushing to ECR and updating App Runner.\n# Enable by setting var.github_repo to \"owner/repo\".\n\ndata \"aws_iam_openid_connect_provider\" \"github\" {\n  count = var.github_repo != \"\" ? 1 : 0\n  url   = \"https://token.actions.githubusercontent.com\"\n}\n\nresource \"aws_iam_role\" \"github_actions\" {\n  count = var.github_repo != \"\" ? 1 : 0\n  name  = \"${local.name_prefix}-github-actions\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Federated = data.aws_iam_openid_connect_provider.github[0].arn\n        }\n        Action = \"sts:AssumeRoleWithWebIdentity\"\n        Condition = {\n          StringEquals = {\n            \"token.actions.githubusercontent.com:aud\" = \"sts.amazonaws.com\"\n          }\n          StringLike = {\n            \"token.actions.githubusercontent.com:sub\" = \"repo:${var.github_repo}:ref:refs/heads/${var.github_branch}\"\n          }\n        }\n      }\n    ]\n  })\n\n  tags = local.tags\n}\n\nresource \"aws_iam_policy\" \"github_actions\" {\n  count = var.github_repo != \"\" ? 1 : 0\n  name  = \"${local.name_prefix}-github-actions\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"EcrPush\"\n        Effect = \"Allow\"\n        Action = [\n          \"ecr:GetAuthorizationToken\",\n          \"ecr:BatchCheckLayerAvailability\",\n          \"ecr:CompleteLayerUpload\",\n          \"ecr:InitiateLayerUpload\",\n          \"ecr:PutImage\",\n          \"ecr:UploadLayerPart\",\n          \"ecr:BatchGetImage\",\n          \"ecr:GetDownloadUrlForLayer\",\n          \"ecr:DescribeRepositories\",\n          \"ecr:CreateRepository\",\n          \"ecr:ListImages\"\n        ]\n        Resource = \"*\"\n      },\n      {\n        Sid    = \"AppRunnerUpdate\"\n        Effect = \"Allow\"\n        Action = [\n          \"apprunner:UpdateService\",\n          \"apprunner:DescribeService\",\n          \"apprunner:ListServices\",\n          \"apprunner:StartDeployment\"\n        ]\n        Resource = \"*\"\n      },\n      {\n        Sid    = \"PassRole\"\n        Effect = \"Allow\"\n        Action = [\n          \"iam:PassRole\"\n        ]\n        Resource = [\n          aws_iam_role.apprunner_ecr_access.arn,\n          aws_iam_role.apprunner_instance.arn\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"github_actions\" {\n  count      = var.github_repo != \"\" ? 1 : 0\n  role       = aws_iam_role.github_actions[0].name\n  policy_arn = aws_iam_policy.github_actions[0].arn\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"ecr_repository_url\" {\n  value       = aws_ecr_repository.api.repository_url\n  description = \"ECR repository URL\"\n}\n\noutput \"app_runner_service_url\" {\n  value       = aws_apprunner_service.api.service_url\n  description = \"Public App Runner service URL\"\n}\n\noutput \"rds_endpoint\" {\n  value       = aws_db_instance.mysql.address\n  description = \"RDS endpoint address\"\n}\n\noutput \"db_secret_arn\" {\n  value       = aws_secretsmanager_secret.db.arn\n  description = \"Secrets Manager secret ARN containing DB credentials\"\n}\n\noutput \"github_actions_role_arn\" {\n  value       = try(aws_iam_role.github_actions[0].arn, null)\n  description = \"IAM role ARN for GitHub Actions OIDC (if enabled)\"\n}\n\noutput \"app_runner_ecr_access_role_arn\" {\n  value       = aws_iam_role.apprunner_ecr_access.arn\n  description = \"Role ARN to be used by App Runner to pull from ECR (matches APP_RUNNER_ROLE in CI)\"\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region = \"us-east-2\"\nproject    = \"natanaelvich\"\nenvironment = \"dev\"\n\n# Optional: set to enable GitHub OIDC role creation\n# github_repo   = \"OWNER/REPO\"\n# github_branch = \"main\"\n\n# RDS settings\n# db_multi_az = true\n# db_deletion_protection = true\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform - NestJS on App Runner + RDS MySQL + ECR\n\nThis Terraform provisions:\n- VPC with 2 public + 2 private subnets\n- (Optional) NAT gateway\n- ECR repository for the API image\n- RDS MySQL instance in private subnets\n- Secrets Manager secret for DB credentials\n- App Runner service pulling from ECR and connecting to RDS via VPC connector\n- Optional GitHub Actions OIDC role (set `github_repo`)\n\n## CI/CD mapping\nYour GitHub Actions workflow expects:\n- `secrets.ECR_ROLE` -> role ARN to assume for pushing to ECR and updating App Runner.\n  - Use output `github_actions_role_arn` if you enable OIDC role creation.\n- `secrets.APP_RUNNER_ROLE` -> App Runner ECR access role ARN.\n  - Use output `app_runner_ecr_access_role_arn`.\n\n## Notes\n- App Runner secret injection: this config sets `DB_PASSWORD` to the Secrets Manager secret ARN.\n  If your app expects a raw password, update the app to read the secret value or change to store\n  only the password in the secret.\n"
    }
  ]
}