{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    archive = {\n      source  = \"hashicorp/archive\"\n      version = \"~> 2.4\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = merge(\n      {\n        Project     = var.project_name\n        Environment = var.environment\n        ManagedBy   = \"terraform\"\n      },\n      var.tags\n    )\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Project/name prefix used for resource naming.\"\n  type        = string\n  default     = \"custom-alpine-terraform\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"tags\" {\n  description = \"Additional tags to apply to all resources.\"\n  type        = map(string)\n  default     = {}\n}\n\nvariable \"github_org\" {\n  description = \"GitHub organization or user that owns the repository.\"\n  type        = string\n}\n\nvariable \"github_repo\" {\n  description = \"GitHub repository name (without org).\"\n  type        = string\n}\n\nvariable \"github_branch\" {\n  description = \"Branch allowed to assume the GitHub Actions role.\"\n  type        = string\n  default     = \"main\"\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name to store the tooling image.\"\n  type        = string\n  default     = \"custom-alpine-terraform\"\n}\n\nvariable \"ecr_image_tag\" {\n  description = \"Default image tag used by the ECS task definition.\"\n  type        = string\n  default     = \"latest\"\n}\n\nvariable \"ecr_lifecycle_keep_last\" {\n  description = \"How many images to keep in ECR.\"\n  type        = number\n  default     = 30\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"enable_nat_gateway\" {\n  description = \"Whether to create a NAT gateway for private subnets egress.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"enable_eventbridge_schedule\" {\n  description = \"Whether to create an EventBridge schedule to trigger the runner.\"\n  type        = bool\n  default     = false\n}\n\nvariable \"eventbridge_schedule_expression\" {\n  description = \"EventBridge schedule expression (e.g., rate(1 day) or cron(...)).\"\n  type        = string\n  default     = \"rate(1 day)\"\n}\n\nvariable \"runner_command\" {\n  description = \"Command array for the ECS task. Defaults to a no-op tail to keep container alive. Override to run terraform/tf-migrate.\"\n  type        = list(string)\n  default     = [\"tail\", \"-f\", \"/dev/null\"]\n}\n\nvariable \"runner_cpu\" {\n  description = \"Fargate task CPU units.\"\n  type        = number\n  default     = 256\n}\n\nvariable \"runner_memory\" {\n  description = \"Fargate task memory (MiB).\"\n  type        = number\n  default     = 512\n}\n\nvariable \"state_bucket_name\" {\n  description = \"Optional explicit name for the Terraform state S3 bucket. If null, a unique name is generated.\"\n  type        = string\n  default     = null\n}\n"
    },
    {
      "name": "main.tf",
      "content": "data \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_partition\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n  azs         = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n}\n\n# -----------------------------\n# ECR (image storage)\n# -----------------------------\nresource \"aws_ecr_repository\" \"tooling\" {\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"tooling\" {\n  repository = aws_ecr_repository.tooling.name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Keep last ${var.ecr_lifecycle_keep_last} images\"\n        selection = {\n          tagStatus   = \"any\"\n          countType   = \"imageCountMoreThan\"\n          countNumber = var.ecr_lifecycle_keep_last\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n\n# -----------------------------\n# GitHub OIDC -> IAM role for pushing to ECR\n# -----------------------------\nresource \"aws_iam_openid_connect_provider\" \"github\" {\n  url = \"https://token.actions.githubusercontent.com\"\n\n  client_id_list = [\n    \"sts.amazonaws.com\"\n  ]\n\n  # GitHub Actions OIDC root CA thumbprint\n  thumbprint_list = [\n    \"6938fd4d98bab03faadb97b34396831e3780aea1\"\n  ]\n}\n\ndata \"aws_iam_policy_document\" \"github_assume_role\" {\n  statement {\n    effect  = \"Allow\"\n    actions = [\"sts:AssumeRoleWithWebIdentity\"]\n\n    principals {\n      type        = \"Federated\"\n      identifiers = [aws_iam_openid_connect_provider.github.arn]\n    }\n\n    condition {\n      test     = \"StringEquals\"\n      variable = \"token.actions.githubusercontent.com:aud\"\n      values   = [\"sts.amazonaws.com\"]\n    }\n\n    # Restrict to a specific repo + branch\n    condition {\n      test     = \"StringLike\"\n      variable = \"token.actions.githubusercontent.com:sub\"\n      values = [\n        \"repo:${var.github_org}/${var.github_repo}:ref:refs/heads/${var.github_branch}\"\n      ]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"github_actions\" {\n  name               = \"${local.name_prefix}-github-actions-ecr\"\n  assume_role_policy = data.aws_iam_policy_document.github_assume_role.json\n}\n\n# Minimal permissions for ECR push\ndata \"aws_iam_policy_document\" \"github_ecr\" {\n  statement {\n    sid     = \"EcrAuth\"\n    effect  = \"Allow\"\n    actions = [\"ecr:GetAuthorizationToken\"]\n    resources = [\n      \"*\"\n    ]\n  }\n\n  statement {\n    sid    = \"EcrPushPull\"\n    effect = \"Allow\"\n    actions = [\n      \"ecr:BatchCheckLayerAvailability\",\n      \"ecr:BatchGetImage\",\n      \"ecr:CompleteLayerUpload\",\n      \"ecr:DescribeImages\",\n      \"ecr:DescribeRepositories\",\n      \"ecr:GetDownloadUrlForLayer\",\n      \"ecr:InitiateLayerUpload\",\n      \"ecr:ListImages\",\n      \"ecr:PutImage\",\n      \"ecr:UploadLayerPart\"\n    ]\n    resources = [\n      aws_ecr_repository.tooling.arn\n    ]\n  }\n}\n\nresource \"aws_iam_role_policy\" \"github_ecr\" {\n  name   = \"${local.name_prefix}-github-ecr\"\n  role   = aws_iam_role.github_actions.id\n  policy = data.aws_iam_policy_document.github_ecr.json\n}\n\n# -----------------------------\n# Terraform remote state (S3 + DynamoDB) with KMS\n# -----------------------------\nresource \"aws_kms_key\" \"tf_state\" {\n  description             = \"KMS key for Terraform remote state encryption\"\n  deletion_window_in_days = 30\n  enable_key_rotation     = true\n}\n\nresource \"aws_kms_alias\" \"tf_state\" {\n  name          = \"alias/${local.name_prefix}-tf-state\"\n  target_key_id = aws_kms_key.tf_state.key_id\n}\n\nresource \"aws_s3_bucket\" \"tf_state\" {\n  bucket        = coalesce(var.state_bucket_name, \"${local.name_prefix}-tf-state-${data.aws_caller_identity.current.account_id}-${data.aws_region.current.name}\")\n  force_destroy = false\n}\n\nresource \"aws_s3_bucket_versioning\" \"tf_state\" {\n  bucket = aws_s3_bucket.tf_state.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"tf_state\" {\n  bucket = aws_s3_bucket.tf_state.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"tf_state\" {\n  bucket = aws_s3_bucket.tf_state.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = \"aws:kms\"\n      kms_master_key_id = aws_kms_key.tf_state.arn\n    }\n  }\n}\n\nresource \"aws_s3_bucket_ownership_controls\" \"tf_state\" {\n  bucket = aws_s3_bucket.tf_state.id\n\n  rule {\n    object_ownership = \"BucketOwnerEnforced\"\n  }\n}\n\nresource \"aws_dynamodb_table\" \"tf_lock\" {\n  name         = \"${local.name_prefix}-tf-lock\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"LockID\"\n\n  attribute {\n    name = \"LockID\"\n    type = \"S\"\n  }\n\n  server_side_encryption {\n    enabled     = true\n    kms_key_arn = aws_kms_key.tf_state.arn\n  }\n}\n\n# -----------------------------\n# Networking (VPC + subnets + NAT)\n# -----------------------------\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n}\n\nresource \"aws_internet_gateway\" \"igw\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : idx => az }\n\n  vpc_id                  = aws_vpc.main.id\n  availability_zone       = each.value\n  cidr_block              = cidrsubnet(var.vpc_cidr, 8, each.key)\n  map_public_ip_on_launch = true\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : idx => az }\n\n  vpc_id            = aws_vpc.main.id\n  availability_zone = each.value\n  cidr_block        = cidrsubnet(var.vpc_cidr, 8, each.key + 100)\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.igw.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_eip\" \"nat\" {\n  count  = var.enable_nat_gateway ? 1 : 0\n  domain = \"vpc\"\n}\n\nresource \"aws_nat_gateway\" \"nat\" {\n  count = var.enable_nat_gateway ? 1 : 0\n\n  allocation_id = aws_eip.nat[0].id\n  subnet_id     = values(aws_subnet.public)[0].id\n\n  depends_on = [aws_internet_gateway.igw]\n}\n\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_route\" \"private_egress\" {\n  count = var.enable_nat_gateway ? 1 : 0\n\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.nat[0].id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private.id\n}\n\n# -----------------------------\n# ECS Fargate runner\n# -----------------------------\nresource \"aws_cloudwatch_log_group\" \"runner\" {\n  name              = \"/ecs/${local.name_prefix}-runner\"\n  retention_in_days = 30\n}\n\nresource \"aws_ecs_cluster\" \"runner\" {\n  name = \"${local.name_prefix}-cluster\"\n}\n\nresource \"aws_security_group\" \"runner\" {\n  name        = \"${local.name_prefix}-runner-sg\"\n  description = \"No inbound; allow all egress (via NAT)\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    description = \"No inbound\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = []\n  }\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# Execution role: pull from ECR + write logs\nresource \"aws_iam_role\" \"ecs_task_execution\" {\n  name = \"${local.name_prefix}-ecs-task-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecs_task_execution\" {\n  role       = aws_iam_role.ecs_task_execution.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\n# Task role: permissions for Terraform to manage AWS.\n# Keep minimal by default; extend as needed.\nresource \"aws_iam_role\" \"ecs_task\" {\n  name = \"${local.name_prefix}-ecs-task\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\n# Allow task to use the remote state bucket + lock table\ndata \"aws_iam_policy_document\" \"task_state_access\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"s3:ListBucket\"\n    ]\n    resources = [aws_s3_bucket.tf_state.arn]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"s3:GetObject\",\n      \"s3:PutObject\",\n      \"s3:DeleteObject\"\n    ]\n    resources = [\"${aws_s3_bucket.tf_state.arn}/*\"]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"dynamodb:GetItem\",\n      \"dynamodb:PutItem\",\n      \"dynamodb:DeleteItem\",\n      \"dynamodb:UpdateItem\",\n      \"dynamodb:DescribeTable\"\n    ]\n    resources = [aws_dynamodb_table.tf_lock.arn]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"kms:Decrypt\",\n      \"kms:Encrypt\",\n      \"kms:GenerateDataKey\",\n      \"kms:DescribeKey\"\n    ]\n    resources = [aws_kms_key.tf_state.arn]\n  }\n}\n\nresource \"aws_iam_role_policy\" \"task_state_access\" {\n  name   = \"${local.name_prefix}-task-state-access\"\n  role   = aws_iam_role.ecs_task.id\n  policy = data.aws_iam_policy_document.task_state_access.json\n}\n\nresource \"aws_ecs_task_definition\" \"runner\" {\n  family                   = \"${local.name_prefix}-runner\"\n  requires_compatibilities = [\"FARGATE\"]\n  network_mode             = \"awsvpc\"\n  cpu                      = tostring(var.runner_cpu)\n  memory                   = tostring(var.runner_memory)\n  execution_role_arn       = aws_iam_role.ecs_task_execution.arn\n  task_role_arn            = aws_iam_role.ecs_task.arn\n\n  container_definitions = jsonencode([\n    {\n      name      = \"runner\"\n      image     = \"${aws_ecr_repository.tooling.repository_url}:${var.ecr_image_tag}\"\n      essential = true\n      command   = var.runner_command\n\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.runner.name\n          awslogs-region        = data.aws_region.current.name\n          awslogs-stream-prefix = \"ecs\"\n        }\n      }\n\n      environment = [\n        { name = \"AWS_REGION\", value = data.aws_region.current.name }\n      ]\n    }\n  ])\n}\n\n# -----------------------------\n# Lambda trigger + EventBridge schedule (optional)\n# -----------------------------\nresource \"aws_iam_role\" \"lambda\" {\n  name = \"${local.name_prefix}-trigger-lambda\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_basic\" {\n  role       = aws_iam_role.lambda.name\n  policy_arn = \"arn:${data.aws_partition.current.partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\ndata \"aws_iam_policy_document\" \"lambda_run_task\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"ecs:RunTask\"\n    ]\n    resources = [aws_ecs_task_definition.runner.arn]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"iam:PassRole\"\n    ]\n    resources = [\n      aws_iam_role.ecs_task_execution.arn,\n      aws_iam_role.ecs_task.arn\n    ]\n  }\n}\n\nresource \"aws_iam_role_policy\" \"lambda_run_task\" {\n  name   = \"${local.name_prefix}-lambda-run-task\"\n  role   = aws_iam_role.lambda.id\n  policy = data.aws_iam_policy_document.lambda_run_task.json\n}\n\ndata \"archive_file\" \"lambda_zip\" {\n  type        = \"zip\"\n  output_path = \"${path.module}/.build/trigger.zip\"\n\n  source {\n    content  = <<-PY\nimport os\nimport json\nimport boto3\n\necs = boto3.client(\"ecs\")\n\ndef handler(event, context):\n    cluster = os.environ[\"CLUSTER_ARN\"]\n    task_def = os.environ[\"TASK_DEFINITION_ARN\"]\n    subnets = os.environ[\"SUBNETS\"].split(\",\")\n    security_groups = os.environ[\"SECURITY_GROUPS\"].split(\",\")\n\n    resp = ecs.run_task(\n        cluster=cluster,\n        taskDefinition=task_def,\n        launchType=\"FARGATE\",\n        networkConfiguration={\n            \"awsvpcConfiguration\": {\n                \"subnets\": subnets,\n                \"securityGroups\": security_groups,\n                \"assignPublicIp\": \"DISABLED\",\n            }\n        },\n        count=1,\n    )\n\n    return {\n        \"statusCode\": 200,\n        \"body\": json.dumps(resp, default=str),\n    }\nPY\n    filename = \"lambda_function.py\"\n  }\n}\n\nresource \"aws_lambda_function\" \"trigger\" {\n  function_name = \"${local.name_prefix}-ecs-trigger\"\n  role          = aws_iam_role.lambda.arn\n  handler       = \"lambda_function.handler\"\n  runtime       = \"python3.12\"\n\n  filename         = data.archive_file.lambda_zip.output_path\n  source_code_hash = data.archive_file.lambda_zip.output_base64sha256\n\n  timeout = 30\n\n  environment {\n    variables = {\n      CLUSTER_ARN         = aws_ecs_cluster.runner.arn\n      TASK_DEFINITION_ARN = aws_ecs_task_definition.runner.arn\n      SUBNETS             = join(\",\", [for s in aws_subnet.private : s.id])\n      SECURITY_GROUPS     = aws_security_group.runner.id\n    }\n  }\n}\n\nresource \"aws_cloudwatch_event_rule\" \"schedule\" {\n  count = var.enable_eventbridge_schedule ? 1 : 0\n\n  name                = \"${local.name_prefix}-runner-schedule\"\n  schedule_expression = var.eventbridge_schedule_expression\n}\n\nresource \"aws_cloudwatch_event_target\" \"schedule_lambda\" {\n  count = var.enable_eventbridge_schedule ? 1 : 0\n\n  rule      = aws_cloudwatch_event_rule.schedule[0].name\n  target_id = \"lambda\"\n  arn       = aws_lambda_function.trigger.arn\n}\n\nresource \"aws_lambda_permission\" \"allow_eventbridge\" {\n  count = var.enable_eventbridge_schedule ? 1 : 0\n\n  statement_id  = \"AllowExecutionFromEventBridge\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.trigger.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.schedule[0].arn\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"ecr_repository_url\" {\n  description = \"ECR repository URL to push the tooling image to.\"\n  value       = aws_ecr_repository.tooling.repository_url\n}\n\noutput \"github_actions_role_arn\" {\n  description = \"IAM role ARN for GitHub Actions (OIDC) to assume for pushing to ECR.\"\n  value       = aws_iam_role.github_actions.arn\n}\n\noutput \"tf_state_bucket\" {\n  description = \"S3 bucket for Terraform remote state.\"\n  value       = aws_s3_bucket.tf_state.bucket\n}\n\noutput \"tf_lock_table\" {\n  description = \"DynamoDB table for Terraform state locking.\"\n  value       = aws_dynamodb_table.tf_lock.name\n}\n\noutput \"ecs_cluster_arn\" {\n  description = \"ECS cluster ARN for the runner.\"\n  value       = aws_ecs_cluster.runner.arn\n}\n\noutput \"ecs_task_definition_arn\" {\n  description = \"ECS task definition ARN for the runner.\"\n  value       = aws_ecs_task_definition.runner.arn\n}\n\noutput \"lambda_trigger_name\" {\n  description = \"Lambda function name that triggers ECS RunTask.\"\n  value       = aws_lambda_function.trigger.function_name\n}\n"
    },
    {
      "name": "terraform.tfvars.example",
      "content": "aws_region   = \"us-east-1\"\nproject_name = \"custom-alpine-terraform\"\nenvironment  = \"dev\"\n\n# Required\ngithub_org  = \"YOUR_GITHUB_ORG_OR_USER\"\ngithub_repo = \"YOUR_REPO_NAME\"\n\n# Optional\n# github_branch = \"main\"\n# ecr_image_tag = \"latest\"\n# enable_eventbridge_schedule = true\n# eventbridge_schedule_expression = \"rate(1 day)\"\n\n# Example: run a one-shot command instead of tail\n# runner_command = [\"terraform\", \"version\"]\n"
    }
  ]
}