{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \"~> 2.25\"\n    }\n    helm = {\n      source  = \"hashicorp/helm\"\n      version = \"~> 2.12\"\n    }\n    tls = {\n      source  = \"hashicorp/tls\"\n      version = \"~> 4.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\n# EKS auth token for Kubernetes/Helm providers\ndata \"aws_eks_cluster_auth\" \"this\" {\n  name = module.eks.cluster_name\n}\n\nprovider \"kubernetes\" {\n  host                   = module.eks.cluster_endpoint\n  cluster_ca_certificate = base64decode(module.eks.cluster_certificate_authority_data)\n  token                  = data.aws_eks_cluster_auth.this.token\n}\n\nprovider \"helm\" {\n  kubernetes {\n    host                   = module.eks.cluster_endpoint\n    cluster_ca_certificate = base64decode(module.eks.cluster_certificate_authority_data)\n    token                  = data.aws_eks_cluster_auth.this.token\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Project/name prefix used for resources\"\n  type        = string\n  default     = \"counter-a\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod)\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR for the VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 or 3)\"\n  type        = number\n  default     = 2\n}\n\nvariable \"cluster_version\" {\n  description = \"EKS Kubernetes version\"\n  type        = string\n  default     = \"1.29\"\n}\n\nvariable \"node_instance_types\" {\n  description = \"Instance types for the EKS managed node group\"\n  type        = list(string)\n  default     = [\"t3.medium\"]\n}\n\nvariable \"node_desired_size\" {\n  description = \"Desired node count\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_min_size\" {\n  description = \"Minimum node count\"\n  type        = number\n  default     = 2\n}\n\nvariable \"node_max_size\" {\n  description = \"Maximum node count\"\n  type        = number\n  default     = 6\n}\n\nvariable \"app_namespace\" {\n  description = \"Kubernetes namespace for the app\"\n  type        = string\n  default     = \"counter-a\"\n}\n\nvariable \"app_name\" {\n  description = \"Kubernetes app name\"\n  type        = string\n  default     = \"counter-a\"\n}\n\nvariable \"app_image\" {\n  description = \"Container image for the React app (from repo manifests: yash5090/counter-a:latest)\"\n  type        = string\n  default     = \"yash5090/counter-a:latest\"\n}\n\nvariable \"app_replicas\" {\n  description = \"Number of replicas (from repo manifests: 6)\"\n  type        = number\n  default     = 6\n}\n\nvariable \"app_container_port\" {\n  description = \"Container port the app listens on (from repo manifests: 3000)\"\n  type        = number\n  default     = 3000\n}\n\nvariable \"app_service_port\" {\n  description = \"Service port exposed by the load balancer (from repo manifests: 3080)\"\n  type        = number\n  default     = 3080\n}\n\nvariable \"enable_ecr\" {\n  description = \"Whether to create an ECR repository (optional; you can keep using DockerHub/GHCR)\"\n  type        = bool\n  default     = false\n}\n\nvariable \"ecr_repository_name\" {\n  description = \"ECR repository name (if enable_ecr=true)\"\n  type        = string\n  default     = \"counter-a\"\n}\n\nvariable \"tags\" {\n  description = \"Additional tags\"\n  type        = map(string)\n  default     = {}\n}\n"
    },
    {
      "name": "main.tf",
      "content": "locals {\n  name = \"${var.project_name}-${var.environment}\"\n\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  # Simple deterministic subnetting\n  public_subnets  = [for i, az in local.azs : cidrsubnet(var.vpc_cidr, 8, i)]\n  private_subnets = [for i, az in local.azs : cidrsubnet(var.vpc_cidr, 8, i + 10)]\n\n  common_tags = merge(\n    {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    },\n    var.tags\n  )\n}\n\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"~> 5.0\"\n\n  name = local.name\n  cidr = var.vpc_cidr\n\n  azs             = local.azs\n  public_subnets  = local.public_subnets\n  private_subnets = local.private_subnets\n\n  enable_nat_gateway     = true\n  single_nat_gateway     = true\n  one_nat_gateway_per_az = false\n\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  # Required for EKS + AWS Load Balancer Controller\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = \"1\"\n  }\n\n  private_subnet_tags = {\n    \"kubernetes.io/role/internal-elb\" = \"1\"\n  }\n\n  tags = local.common_tags\n}\n\nmodule \"eks\" {\n  source  = \"terraform-aws-modules/eks/aws\"\n  version = \"~> 20.0\"\n\n  cluster_name    = local.name\n  cluster_version = var.cluster_version\n\n  vpc_id     = module.vpc.vpc_id\n  subnet_ids = module.vpc.private_subnets\n\n  cluster_endpoint_public_access = true\n\n  enable_cluster_creator_admin_permissions = true\n\n  cluster_enabled_log_types = [\"api\", \"audit\", \"authenticator\", \"controllerManager\", \"scheduler\"]\n\n  eks_managed_node_groups = {\n    default = {\n      name            = \"default\"\n      instance_types  = var.node_instance_types\n      min_size        = var.node_min_size\n      max_size        = var.node_max_size\n      desired_size    = var.node_desired_size\n      subnet_ids      = module.vpc.private_subnets\n      capacity_type   = \"ON_DEMAND\"\n      ami_type        = \"AL2_x86_64\"\n      disk_size       = 20\n    }\n  }\n\n  tags = local.common_tags\n}\n\n# --- AWS Load Balancer Controller (ALB) via IRSA + Helm ---\n\ndata \"aws_iam_policy_document\" \"lbc_assume_role\" {\n  statement {\n    effect  = \"Allow\"\n    actions = [\"sts:AssumeRoleWithWebIdentity\"]\n\n    principals {\n      type        = \"Federated\"\n      identifiers = [module.eks.oidc_provider_arn]\n    }\n\n    condition {\n      test     = \"StringEquals\"\n      variable = \"${replace(module.eks.oidc_provider, \"https://\", \"\")}:sub\"\n      values   = [\"system:serviceaccount=kube-system:aws-load-balancer-controller\"]\n    }\n\n    condition {\n      test     = \"StringEquals\"\n      variable = \"${replace(module.eks.oidc_provider, \"https://\", \"\")}:aud\"\n      values   = [\"sts.amazonaws.com\"]\n    }\n  }\n}\n\nresource \"aws_iam_role\" \"aws_load_balancer_controller\" {\n  name               = \"${local.name}-aws-lbc\"\n  assume_role_policy = data.aws_iam_policy_document.lbc_assume_role.json\n  tags               = local.common_tags\n}\n\n# AWS Load Balancer Controller IAM policy (official JSON embedded)\n# Source: https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json\nresource \"aws_iam_policy\" \"aws_load_balancer_controller\" {\n  name   = \"${local.name}-AWSLoadBalancerControllerIAMPolicy\"\n  policy = file(\"${path.module}/lbc_iam_policy.json\")\n  tags   = local.common_tags\n}\n\nresource \"aws_iam_role_policy_attachment\" \"aws_lbc\" {\n  role       = aws_iam_role.aws_load_balancer_controller.name\n  policy_arn = aws_iam_policy.aws_load_balancer_controller.arn\n}\n\nresource \"kubernetes_service_account\" \"aws_load_balancer_controller\" {\n  metadata {\n    name      = \"aws-load-balancer-controller\"\n    namespace = \"kube-system\"\n    annotations = {\n      \"eks.amazonaws.com/role-arn\" = aws_iam_role.aws_load_balancer_controller.arn\n    }\n    labels = {\n      \"app.kubernetes.io/name\" = \"aws-load-balancer-controller\"\n    }\n  }\n\n  depends_on = [module.eks]\n}\n\nresource \"helm_release\" \"aws_load_balancer_controller\" {\n  name       = \"aws-load-balancer-controller\"\n  repository = \"https://aws.github.io/eks-charts\"\n  chart      = \"aws-load-balancer-controller\"\n  namespace  = \"kube-system\"\n  version    = \"1.7.2\"\n\n  set {\n    name  = \"clusterName\"\n    value = module.eks.cluster_name\n  }\n\n  set {\n    name  = \"serviceAccount.create\"\n    value = \"false\"\n  }\n\n  set {\n    name  = \"serviceAccount.name\"\n    value = kubernetes_service_account.aws_load_balancer_controller.metadata[0].name\n  }\n\n  set {\n    name  = \"region\"\n    value = var.aws_region\n  }\n\n  set {\n    name  = \"vpcId\"\n    value = module.vpc.vpc_id\n  }\n\n  depends_on = [kubernetes_service_account.aws_load_balancer_controller]\n}\n\n# --- App namespace + deployment + service + ingress ---\n\nresource \"kubernetes_namespace\" \"app\" {\n  metadata {\n    name = var.app_namespace\n    labels = {\n      \"app.kubernetes.io/part-of\" = var.project_name\n    }\n  }\n}\n\nresource \"kubernetes_deployment\" \"app\" {\n  metadata {\n    name      = \"${var.app_name}-deployment\"\n    namespace = kubernetes_namespace.app.metadata[0].name\n    labels = {\n      app = var.app_name\n    }\n  }\n\n  spec {\n    replicas = var.app_replicas\n\n    selector {\n      match_labels = {\n        app = var.app_name\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = var.app_name\n        }\n      }\n\n      spec {\n        container {\n          name  = var.app_name\n          image = var.app_image\n\n          port {\n            container_port = var.app_container_port\n          }\n\n          resources {\n            requests = {\n              cpu    = \"100m\"\n              memory = \"128Mi\"\n            }\n            limits = {\n              cpu    = \"500m\"\n              memory = \"512Mi\"\n            }\n          }\n\n          liveness_probe {\n            http_get {\n              path = \"/\"\n              port = var.app_container_port\n            }\n            initial_delay_seconds = 30\n            period_seconds        = 10\n          }\n\n          readiness_probe {\n            http_get {\n              path = \"/\"\n              port = var.app_container_port\n            }\n            initial_delay_seconds = 10\n            period_seconds        = 5\n          }\n        }\n      }\n    }\n  }\n\n  depends_on = [helm_release.aws_load_balancer_controller]\n}\n\nresource \"kubernetes_service\" \"app\" {\n  metadata {\n    name      = \"${var.app_name}-service\"\n    namespace = kubernetes_namespace.app.metadata[0].name\n    labels = {\n      app = var.app_name\n    }\n  }\n\n  spec {\n    selector = {\n      app = var.app_name\n    }\n\n    port {\n      port        = var.app_service_port\n      target_port = var.app_container_port\n      protocol    = \"TCP\"\n    }\n\n    type = \"NodePort\"\n  }\n}\n\n# Prefer Ingress for ALB (Service annotation approach is legacy/less common)\nresource \"kubernetes_ingress_v1\" \"app\" {\n  metadata {\n    name      = \"${var.app_name}-ingress\"\n    namespace = kubernetes_namespace.app.metadata[0].name\n    annotations = {\n      \"kubernetes.io/ingress.class\"                = \"alb\"\n      \"alb.ingress.kubernetes.io/scheme\"           = \"internet-facing\"\n      \"alb.ingress.kubernetes.io/target-type\"      = \"ip\"\n      \"alb.ingress.kubernetes.io/backend-protocol\" = \"HTTP\"\n      \"alb.ingress.kubernetes.io/listen-ports\"     = \"[{\\\"HTTP\\\": 80}]\"\n    }\n  }\n\n  spec {\n    rule {\n      http {\n        path {\n          path      = \"/\"\n          path_type = \"Prefix\"\n\n          backend {\n            service {\n              name = kubernetes_service.app.metadata[0].name\n              port {\n                number = var.app_service_port\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  depends_on = [helm_release.aws_load_balancer_controller]\n}\n\n# Optional ECR repository (disabled by default)\nresource \"aws_ecr_repository\" \"app\" {\n  count = var.enable_ecr ? 1 : 0\n\n  name                 = var.ecr_repository_name\n  image_tag_mutability = \"MUTABLE\"\n\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n\n  encryption_configuration {\n    encryption_type = \"AES256\"\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_ecr_lifecycle_policy\" \"app\" {\n  count      = var.enable_ecr ? 1 : 0\n  repository = aws_ecr_repository.app[0].name\n\n  policy = jsonencode({\n    rules = [\n      {\n        rulePriority = 1\n        description  = \"Expire untagged images older than 14 days\"\n        selection = {\n          tagStatus   = \"untagged\"\n          countType   = \"sinceImagePushed\"\n          countUnit   = \"days\"\n          countNumber = 14\n        }\n        action = {\n          type = \"expire\"\n        }\n      }\n    ]\n  })\n}\n"
    },
    {
      "name": "lbc_iam_policy.json",
      "content": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:CreateServiceLinkedRole\"\n      ],\n      \"Resource\": \"*\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"iam:AWSServiceName\": \"elasticloadbalancing.amazonaws.com\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:DescribeAccountAttributes\",\n        \"ec2:DescribeAddresses\",\n        \"ec2:DescribeAvailabilityZones\",\n        \"ec2:DescribeInternetGateways\",\n        \"ec2:DescribeVpcs\",\n        \"ec2:DescribeVpcPeeringConnections\",\n        \"ec2:DescribeSubnets\",\n        \"ec2:DescribeSecurityGroups\",\n        \"ec2:DescribeInstances\",\n        \"ec2:DescribeNetworkInterfaces\",\n        \"ec2:DescribeTags\",\n        \"ec2:GetCoipPoolUsage\",\n        \"ec2:DescribeCoipPools\",\n        \"elasticloadbalancing:DescribeLoadBalancers\",\n        \"elasticloadbalancing:DescribeLoadBalancerAttributes\",\n        \"elasticloadbalancing:DescribeListeners\",\n        \"elasticloadbalancing:DescribeListenerCertificates\",\n        \"elasticloadbalancing:DescribeSSLPolicies\",\n        \"elasticloadbalancing:DescribeRules\",\n        \"elasticloadbalancing:DescribeTargetGroups\",\n        \"elasticloadbalancing:DescribeTargetGroupAttributes\",\n        \"elasticloadbalancing:DescribeTargetHealth\",\n        \"elasticloadbalancing:DescribeTags\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"cognito-idp:DescribeUserPoolClient\",\n        \"acm:ListCertificates\",\n        \"acm:DescribeCertificate\",\n        \"iam:ListServerCertificates\",\n        \"iam:GetServerCertificate\",\n        \"waf-regional:GetWebACL\",\n        \"waf-regional:GetWebACLForResource\",\n        \"waf-regional:AssociateWebACL\",\n        \"waf-regional:DisassociateWebACL\",\n        \"wafv2:GetWebACL\",\n        \"wafv2:GetWebACLForResource\",\n        \"wafv2:AssociateWebACL\",\n        \"wafv2:DisassociateWebACL\",\n        \"shield:GetSubscriptionState\",\n        \"shield:DescribeProtection\",\n        \"shield:CreateProtection\",\n        \"shield:DeleteProtection\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:AuthorizeSecurityGroupIngress\",\n        \"ec2:RevokeSecurityGroupIngress\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:CreateSecurityGroup\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:CreateTags\"\n      ],\n      \"Resource\": \"arn:aws:ec2:*:*:security-group/*\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"ec2:CreateAction\": \"CreateSecurityGroup\"\n        },\n        \"Null\": {\n          \"aws:RequestTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:CreateTags\",\n        \"ec2:DeleteTags\"\n      ],\n      \"Resource\": \"arn:aws:ec2:*:*:security-group/*\",\n      \"Condition\": {\n        \"Null\": {\n          \"aws:RequestTag/elbv2.k8s.aws/cluster\": \"true\",\n          \"aws:ResourceTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:AuthorizeSecurityGroupIngress\",\n        \"ec2:RevokeSecurityGroupIngress\",\n        \"ec2:DeleteSecurityGroup\"\n      ],\n      \"Resource\": \"*\",\n      \"Condition\": {\n        \"Null\": {\n          \"aws:ResourceTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:CreateLoadBalancer\",\n        \"elasticloadbalancing:CreateTargetGroup\"\n      ],\n      \"Resource\": \"*\",\n      \"Condition\": {\n        \"Null\": {\n          \"aws:RequestTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:CreateListener\",\n        \"elasticloadbalancing:DeleteListener\",\n        \"elasticloadbalancing:CreateRule\",\n        \"elasticloadbalancing:DeleteRule\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:AddTags\",\n        \"elasticloadbalancing:RemoveTags\"\n      ],\n      \"Resource\": [\n        \"arn:aws:elasticloadbalancing:*:*:targetgroup/*/*\",\n        \"arn:aws:elasticloadbalancing:*:*:loadbalancer/net/*/*\",\n        \"arn:aws:elasticloadbalancing:*:*:loadbalancer/app/*/*\"\n      ],\n      \"Condition\": {\n        \"Null\": {\n          \"aws:RequestTag/elbv2.k8s.aws/cluster\": \"true\",\n          \"aws:ResourceTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:AddTags\",\n        \"elasticloadbalancing:RemoveTags\"\n      ],\n      \"Resource\": [\n        \"arn:aws:elasticloadbalancing:*:*:listener/net/*/*/*\",\n        \"arn:aws:elasticloadbalancing:*:*:listener/app/*/*/*\",\n        \"arn:aws:elasticloadbalancing:*:*:listener-rule/net/*/*/*\",\n        \"arn:aws:elasticloadbalancing:*:*:listener-rule/app/*/*/*\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:ModifyLoadBalancerAttributes\",\n        \"elasticloadbalancing:SetIpAddressType\",\n        \"elasticloadbalancing:SetSecurityGroups\",\n        \"elasticloadbalancing:SetSubnets\",\n        \"elasticloadbalancing:DeleteLoadBalancer\",\n        \"elasticloadbalancing:ModifyTargetGroup\",\n        \"elasticloadbalancing:ModifyTargetGroupAttributes\",\n        \"elasticloadbalancing:DeleteTargetGroup\"\n      ],\n      \"Resource\": \"*\",\n      \"Condition\": {\n        \"Null\": {\n          \"aws:ResourceTag/elbv2.k8s.aws/cluster\": \"false\"\n        }\n      }\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:RegisterTargets\",\n        \"elasticloadbalancing:DeregisterTargets\"\n      ],\n      \"Resource\": \"arn:aws:elasticloadbalancing:*:*:targetgroup/*/*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"elasticloadbalancing:SetWebAcl\",\n        \"elasticloadbalancing:ModifyListener\",\n        \"elasticloadbalancing:AddListenerCertificates\",\n        \"elasticloadbalancing:RemoveListenerCertificates\",\n        \"elasticloadbalancing:ModifyRule\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value       = module.vpc.vpc_id\n  description = \"VPC ID\"\n}\n\noutput \"eks_cluster_name\" {\n  value       = module.eks.cluster_name\n  description = \"EKS cluster name\"\n}\n\noutput \"eks_cluster_endpoint\" {\n  value       = module.eks.cluster_endpoint\n  description = \"EKS cluster endpoint\"\n}\n\noutput \"app_namespace\" {\n  value       = kubernetes_namespace.app.metadata[0].name\n  description = \"Kubernetes namespace for the app\"\n}\n\noutput \"alb_hostname\" {\n  description = \"ALB DNS name created by AWS Load Balancer Controller (available after ingress is provisioned)\"\n  value       = try(kubernetes_ingress_v1.app.status[0].load_balancer[0].ingress[0].hostname, null)\n}\n\noutput \"ecr_repository_url\" {\n  description = \"ECR repository URL (if enabled)\"\n  value       = try(aws_ecr_repository.app[0].repository_url, null)\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region   = \"us-east-1\"\nproject_name = \"counter-a\"\nenvironment  = \"dev\"\n\n# App image from repo manifests\napp_image = \"yash5090/counter-a:latest\"\n\n# Optional: create ECR repo\nenable_ecr = false\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform: React SPA on EKS with ALB (AWS Load Balancer Controller)\n\nThis Terraform creates:\n- VPC (public + private subnets, NAT)\n- EKS cluster + managed node group\n- AWS Load Balancer Controller (IRSA + Helm)\n- Kubernetes namespace, Deployment (replicas=6), Service, and ALB Ingress\n\n## Notes\n- The repo's `service.yaml` uses a `Service` annotation to request an ALB. The recommended pattern is **Ingress** with AWS Load Balancer Controller; this Terraform uses an `Ingress`.\n- The ALB DNS name is output as `alb_hostname` after the controller provisions it.\n\n## Usage\n```bash\ncd ai_tf\nterraform init\nterraform validate\nterraform plan\n```\n"
    }
  ]
}