{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.stage_name\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Project/name prefix used for resource naming.\"\n  type        = string\n  default     = \"product-api\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"stage_name\" {\n  description = \"API Gateway stage name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"lambda_artifact_path\" {\n  description = \"Path to the Lambda deployment package (zip or jar). For Java, prefer a ZIP containing the handler + deps.\"\n  type        = string\n  default     = \"../.dummy/lambda.zip\"\n}\n\nvariable \"lambda_function_name\" {\n  description = \"Lambda function name.\"\n  type        = string\n  default     = \"product-lambda\"\n}\n\nvariable \"lambda_runtime\" {\n  description = \"Lambda runtime. If you deploy a Java ZIP/JAR, use java17 (or java11).\"\n  type        = string\n  default     = \"java17\"\n}\n\nvariable \"lambda_handler\" {\n  description = \"Lambda handler (Java). Update to match your code. Example: com.example.Handler::handleRequest\"\n  type        = string\n  default     = \"example.Handler::handleRequest\"\n}\n\nvariable \"lambda_memory_size\" {\n  description = \"Lambda memory size (MB).\"\n  type        = number\n  default     = 512\n}\n\nvariable \"lambda_timeout\" {\n  description = \"Lambda timeout (seconds).\"\n  type        = number\n  default     = 10\n}\n\nvariable \"enable_api_key\" {\n  description = \"Whether to require an API key via a usage plan.\"\n  type        = bool\n  default     = false\n}\n"
    },
    {
      "name": "main.tf",
      "content": "locals {\n  name_prefix = \"${var.project_name}-${var.stage_name}\"\n}\n\n# -----------------------------\n# IAM for Lambda\n# -----------------------------\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"${local.name_prefix}-lambda-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_basic\" {\n  role       = aws_iam_role.lambda_exec.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\n# -----------------------------\n# Lambda\n# -----------------------------\nresource \"aws_cloudwatch_log_group\" \"lambda\" {\n  name              = \"/aws/lambda/${var.lambda_function_name}\"\n  retention_in_days = 14\n}\n\nresource \"aws_lambda_function\" \"product\" {\n  function_name = var.lambda_function_name\n  role          = aws_iam_role.lambda_exec.arn\n\n  filename         = var.lambda_artifact_path\n  source_code_hash = filebase64sha256(var.lambda_artifact_path)\n\n  runtime = var.lambda_runtime\n  handler = var.lambda_handler\n\n  memory_size = var.lambda_memory_size\n  timeout     = var.lambda_timeout\n\n  depends_on = [aws_cloudwatch_log_group.lambda]\n}\n\n# -----------------------------\n# API Gateway (REST)\n# -----------------------------\nresource \"aws_api_gateway_rest_api\" \"this\" {\n  name = \"${local.name_prefix}-rest\"\n\n  endpoint_configuration {\n    types = [\"REGIONAL\"]\n  }\n}\n\n# /productApi\nresource \"aws_api_gateway_resource\" \"product_api\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  parent_id   = aws_api_gateway_rest_api.this.root_resource_id\n  path_part   = \"productApi\"\n}\n\n# ANY /productApi (Lambda proxy)\nresource \"aws_api_gateway_method\" \"product_any\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  resource_id   = aws_api_gateway_resource.product_api.id\n  http_method   = \"ANY\"\n  authorization = \"NONE\"\n\n  api_key_required = var.enable_api_key\n}\n\n# NOTE: For Lambda proxy integration, integration_http_method MUST be POST.\nresource \"aws_api_gateway_integration\" \"product_any\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  resource_id = aws_api_gateway_resource.product_api.id\n  http_method = aws_api_gateway_method.product_any.http_method\n\n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = aws_lambda_function.product.invoke_arn\n}\n\n# Allow API Gateway to invoke Lambda\nresource \"aws_lambda_permission\" \"apigw_invoke\" {\n  statement_id  = \"AllowExecutionFromAPIGateway\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.product.function_name\n  principal     = \"apigateway.amazonaws.com\"\n\n  source_arn = \"${aws_api_gateway_rest_api.this.execution_arn}/*/*\"\n}\n\n# Deployment + Stage\nresource \"aws_cloudwatch_log_group\" \"apigw_access\" {\n  name              = \"/aws/apigateway/${local.name_prefix}\"\n  retention_in_days = 14\n}\n\nresource \"aws_api_gateway_deployment\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n\n  # Force redeploy when API config changes\n  triggers = {\n    redeploy = sha1(jsonencode({\n      resource_id  = aws_api_gateway_resource.product_api.id\n      method_id    = aws_api_gateway_method.product_any.id\n      integration  = aws_api_gateway_integration.product_any.id\n      lambda_arn   = aws_lambda_function.product.arn\n      api_key      = var.enable_api_key\n    }))\n  }\n\n  depends_on = [\n    aws_api_gateway_integration.product_any,\n    aws_lambda_permission.apigw_invoke\n  ]\n}\n\nresource \"aws_api_gateway_stage\" \"this\" {\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  deployment_id = aws_api_gateway_deployment.this.id\n  stage_name    = var.stage_name\n\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.apigw_access.arn\n    format = jsonencode({\n      requestId      = \"$context.requestId\"\n      ip             = \"$context.identity.sourceIp\"\n      requestTime    = \"$context.requestTime\"\n      httpMethod     = \"$context.httpMethod\"\n      resourcePath   = \"$context.resourcePath\"\n      status         = \"$context.status\"\n      protocol       = \"$context.protocol\"\n      responseLength = \"$context.responseLength\"\n      integrationErr = \"$context.integrationErrorMessage\"\n    })\n  }\n\n  xray_tracing_enabled = false\n}\n\n# Enable execution logging at stage level (minimal)\nresource \"aws_api_gateway_method_settings\" \"all\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  stage_name  = aws_api_gateway_stage.this.stage_name\n  method_path = \"*/*\"\n\n  settings {\n    metrics_enabled    = true\n    logging_level      = \"INFO\"\n    data_trace_enabled = false\n  }\n}\n\n# -----------------------------\n# Optional: API Key + Usage Plan\n# -----------------------------\nresource \"aws_api_gateway_api_key\" \"this\" {\n  count = var.enable_api_key ? 1 : 0\n\n  name    = \"${local.name_prefix}-key\"\n  enabled = true\n}\n\nresource \"aws_api_gateway_usage_plan\" \"this\" {\n  count = var.enable_api_key ? 1 : 0\n\n  name = \"${local.name_prefix}-usage-plan\"\n\n  api_stages {\n    api_id = aws_api_gateway_rest_api.this.id\n    stage  = aws_api_gateway_stage.this.stage_name\n  }\n}\n\nresource \"aws_api_gateway_usage_plan_key\" \"this\" {\n  count = var.enable_api_key ? 1 : 0\n\n  key_id        = aws_api_gateway_api_key.this[0].id\n  key_type      = \"API_KEY\"\n  usage_plan_id = aws_api_gateway_usage_plan.this[0].id\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"rest_api_id\" {\n  description = \"API Gateway REST API id.\"\n  value       = aws_api_gateway_rest_api.this.id\n}\n\noutput \"invoke_url\" {\n  description = \"Base invoke URL for the deployed stage.\"\n  value       = \"https://${aws_api_gateway_rest_api.this.id}.execute-api.${var.aws_region}.amazonaws.com/${aws_api_gateway_stage.this.stage_name}/productApi\"\n}\n\noutput \"api_key_value\" {\n  description = \"API key value (only when enable_api_key=true).\"\n  value       = var.enable_api_key ? aws_api_gateway_api_key.this[0].value : null\n  sensitive   = true\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "project_name         = \"product-api\"\naws_region           = \"us-east-1\"\nstage_name           = \"dev\"\n\n# Update these to match your Lambda build output.\n# For this repo, a sample artifact exists at .dummy/lambda.zip\nlambda_artifact_path = \"../.dummy/lambda.zip\"\n\n# IMPORTANT: set to your real Java handler\nlambda_handler       = \"example.Handler::handleRequest\"\n\n# enable_api_key = true\n"
    },
    {
      "name": "README.md",
      "content": "## Terraform (AWS) - API Gateway REST -> Lambda\n\nThis Terraform config deploys a minimal AWS equivalent of the LocalStack stack in this repo:\n\n- API Gateway REST API\n- Lambda (Java)\n- CloudWatch log groups\n- Optional API key + usage plan\n\n### Prereqs\n- Terraform >= 1.5\n- AWS credentials configured (e.g., `aws configure` or env vars)\n- A Lambda artifact at `lambda_artifact_path` (default: `../.dummy/lambda.zip`)\n\n### Deploy\n```bash\ncd ai_tf\nterraform init\nterraform validate\nterraform apply\n```\n\n### Invoke\nAfter apply, use the output `invoke_url`.\n\nIf `enable_api_key=true`, pass header:\n`x-api-key: <api_key_value>`\n\n### Note about the \"tricky\" integration\nFor Lambda proxy integration, API Gateway must use:\n- `type = \"AWS_PROXY\"`\n- `integration_http_method = \"POST\"`\n\nUsing `GET` will break the integration.\n"
    }
  ]
}