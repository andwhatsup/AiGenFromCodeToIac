{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.6.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = merge(\n      {\n        Project   = var.project_name\n        ManagedBy = \"terraform\"\n      },\n      var.tags\n    )\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"project_name\" {\n  description = \"Name prefix for all resources.\"\n  type        = string\n  default     = \"renovate\"\n}\n\nvariable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for the VPC.\"\n  type        = string\n  default     = \"10.20.0.0/16\"\n}\n\nvariable \"az_count\" {\n  description = \"Number of AZs to use (2 recommended).\"\n  type        = number\n  default     = 2\n}\n\nvariable \"schedule_expression\" {\n  description = \"EventBridge Scheduler expression. Example: rate(1 day) or cron(0 2 * * ? *).\"\n  type        = string\n  default     = \"rate(1 day)\"\n}\n\nvariable \"schedule_timezone\" {\n  description = \"Timezone for schedule expression evaluation.\"\n  type        = string\n  default     = \"UTC\"\n}\n\nvariable \"ecs_cpu\" {\n  description = \"Fargate task CPU units.\"\n  type        = number\n  default     = 512\n}\n\nvariable \"ecs_memory\" {\n  description = \"Fargate task memory (MiB).\"\n  type        = number\n  default     = 1024\n}\n\nvariable \"container_image\" {\n  description = \"Container image URI for Renovate. Prefer an ECR image URI.\"\n  type        = string\n  default     = \"ghcr.io/renovatebot/renovate:36.72.0\"\n}\n\nvariable \"git_platform\" {\n  description = \"Git platform for Renovate (e.g., github, gitlab, bitbucket).\"\n  type        = string\n  default     = \"github\"\n}\n\nvariable \"renovate_repositories\" {\n  description = \"List of repositories for Renovate to process (e.g., ['org/repo']).\"\n  type        = list(string)\n  default     = []\n}\n\nvariable \"renovate_log_level\" {\n  description = \"Renovate log level.\"\n  type        = string\n  default     = \"info\"\n}\n\nvariable \"renovate_token_secret_arn\" {\n  description = \"ARN of an existing Secrets Manager secret containing the Renovate token (plain string). If empty, a new secret is created (without a value).\"\n  type        = string\n  default     = \"\"\n}\n\nvariable \"create_vpc_endpoints\" {\n  description = \"Whether to create interface/gateway VPC endpoints for ECR/Logs/SecretsManager/S3.\"\n  type        = bool\n  default     = true\n}\n\nvariable \"tags\" {\n  description = \"Additional tags to apply to resources.\"\n  type        = map(string)\n  default     = {}\n}\n"
    },
    {
      "name": "locals.tf",
      "content": "data \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\nlocals {\n  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)\n\n  name_prefix = var.project_name\n\n  # Renovate expects repositories as CLI args, e.g. renovate org/repo org/repo2\n  renovate_command = length(var.renovate_repositories) > 0 ? concat([\"renovate\"], var.renovate_repositories) : [\"renovate\"]\n}\n"
    },
    {
      "name": "network.tf",
      "content": "resource \"aws_vpc\" \"this\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpc\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"this\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-igw\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id                  = aws_vpc.this.id\n  availability_zone       = each.key\n  cidr_block              = cidrsubnet(var.vpc_cidr, 8, each.value)\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${local.name_prefix}-public-${each.key}\"\n    Tier = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  for_each = { for idx, az in local.azs : az => idx }\n\n  vpc_id            = aws_vpc.this.id\n  availability_zone = each.key\n  cidr_block        = cidrsubnet(var.vpc_cidr, 8, each.value + 10)\n\n  tags = {\n    Name = \"${local.name_prefix}-private-${each.key}\"\n    Tier = \"private\"\n  }\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-public-rt\"\n  }\n}\n\nresource \"aws_route\" \"public_internet\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"public\" {\n  for_each = aws_subnet.public\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_eip\" \"nat\" {\n  domain = \"vpc\"\n\n  tags = {\n    Name = \"${local.name_prefix}-nat-eip\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"this\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = values(aws_subnet.public)[0].id\n\n  tags = {\n    Name = \"${local.name_prefix}-nat\"\n  }\n\n  depends_on = [aws_internet_gateway.this]\n}\n\nresource \"aws_route_table\" \"private\" {\n  vpc_id = aws_vpc.this.id\n\n  tags = {\n    Name = \"${local.name_prefix}-private-rt\"\n  }\n}\n\nresource \"aws_route\" \"private_nat\" {\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.this.id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each = aws_subnet.private\n\n  subnet_id      = each.value.id\n  route_table_id = aws_route_table.private.id\n}\n"
    },
    {
      "name": "security.tf",
      "content": "resource \"aws_security_group\" \"ecs_task\" {\n  name        = \"${local.name_prefix}-ecs-task\"\n  description = \"Security group for Renovate Fargate task (no inbound).\"\n  vpc_id      = aws_vpc.this.id\n\n  # No inbound rules\n\n  egress {\n    description = \"Allow all egress (HTTPS to git provider, plus AWS endpoints).\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-ecs-task-sg\"\n  }\n}\n\nresource \"aws_security_group\" \"vpce\" {\n  count       = var.create_vpc_endpoints ? 1 : 0\n  name        = \"${local.name_prefix}-vpce\"\n  description = \"Security group for interface VPC endpoints.\"\n  vpc_id      = aws_vpc.this.id\n\n  ingress {\n    description     = \"Allow HTTPS from ECS tasks to VPC endpoints\"\n    from_port       = 443\n    to_port         = 443\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.ecs_task.id]\n  }\n\n  egress {\n    description = \"Allow all egress\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-sg\"\n  }\n}\n"
    },
    {
      "name": "vpc_endpoints.tf",
      "content": "data \"aws_region\" \"current\" {}\n\n# Gateway endpoint for S3 (optional but recommended for ECR layer downloads via S3)\nresource \"aws_vpc_endpoint\" \"s3\" {\n  count             = var.create_vpc_endpoints ? 1 : 0\n  vpc_id            = aws_vpc.this.id\n  vpc_endpoint_type = \"Gateway\"\n  service_name      = \"com.amazonaws.${data.aws_region.current.name}.s3\"\n  route_table_ids   = [aws_route_table.private.id]\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-s3\"\n  }\n}\n\n# Interface endpoints\nresource \"aws_vpc_endpoint\" \"ecr_api\" {\n  count               = var.create_vpc_endpoints ? 1 : 0\n  vpc_id              = aws_vpc.this.id\n  vpc_endpoint_type   = \"Interface\"\n  service_name        = \"com.amazonaws.${data.aws_region.current.name}.ecr.api\"\n  subnet_ids          = [for s in aws_subnet.private : s.id]\n  security_group_ids  = [aws_security_group.vpce[0].id]\n  private_dns_enabled = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-ecr-api\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"ecr_dkr\" {\n  count               = var.create_vpc_endpoints ? 1 : 0\n  vpc_id              = aws_vpc.this.id\n  vpc_endpoint_type   = \"Interface\"\n  service_name        = \"com.amazonaws.${data.aws_region.current.name}.ecr.dkr\"\n  subnet_ids          = [for s in aws_subnet.private : s.id]\n  security_group_ids  = [aws_security_group.vpce[0].id]\n  private_dns_enabled = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-ecr-dkr\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"logs\" {\n  count               = var.create_vpc_endpoints ? 1 : 0\n  vpc_id              = aws_vpc.this.id\n  vpc_endpoint_type   = \"Interface\"\n  service_name        = \"com.amazonaws.${data.aws_region.current.name}.logs\"\n  subnet_ids          = [for s in aws_subnet.private : s.id]\n  security_group_ids  = [aws_security_group.vpce[0].id]\n  private_dns_enabled = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-logs\"\n  }\n}\n\nresource \"aws_vpc_endpoint\" \"secretsmanager\" {\n  count               = var.create_vpc_endpoints ? 1 : 0\n  vpc_id              = aws_vpc.this.id\n  vpc_endpoint_type   = \"Interface\"\n  service_name        = \"com.amazonaws.${data.aws_region.current.name}.secretsmanager\"\n  subnet_ids          = [for s in aws_subnet.private : s.id]\n  security_group_ids  = [aws_security_group.vpce[0].id]\n  private_dns_enabled = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpce-secretsmanager\"\n  }\n}\n"
    },
    {
      "name": "ecs.tf",
      "content": "resource \"aws_cloudwatch_log_group\" \"renovate\" {\n  name              = \"/ecs/${local.name_prefix}\"\n  retention_in_days = 30\n}\n\nresource \"aws_ecs_cluster\" \"this\" {\n  name = \"${local.name_prefix}-cluster\"\n}\n\n# Secret: either use an existing secret ARN, or create an empty secret to be populated out-of-band.\nresource \"aws_secretsmanager_secret\" \"renovate_token\" {\n  count = var.renovate_token_secret_arn == \"\" ? 1 : 0\n\n  name                    = \"${local.name_prefix}/renovate-token\"\n  recovery_window_in_days = 0\n\n  tags = {\n    Name = \"${local.name_prefix}-token\"\n  }\n}\n\nlocals {\n  token_secret_arn = var.renovate_token_secret_arn != \"\" ? var.renovate_token_secret_arn : aws_secretsmanager_secret.renovate_token[0].arn\n}\n\nresource \"aws_iam_role\" \"ecs_task_execution\" {\n  name = \"${local.name_prefix}-ecs-task-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecs_task_execution_managed\" {\n  role       = aws_iam_role.ecs_task_execution.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\nresource \"aws_iam_role\" \"ecs_task\" {\n  name = \"${local.name_prefix}-ecs-task\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"ecs_task_secrets\" {\n  name        = \"${local.name_prefix}-ecs-task-secrets\"\n  description = \"Allow Renovate task to read its token secret.\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect   = \"Allow\"\n        Action   = [\"secretsmanager:GetSecretValue\"]\n        Resource = local.token_secret_arn\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecs_task_secrets\" {\n  role       = aws_iam_role.ecs_task.name\n  policy_arn = aws_iam_policy.ecs_task_secrets.arn\n}\n\nresource \"aws_ecs_task_definition\" \"renovate\" {\n  family                   = \"${local.name_prefix}-task\"\n  requires_compatibilities = [\"FARGATE\"]\n  network_mode             = \"awsvpc\"\n  cpu                      = var.ecs_cpu\n  memory                   = var.ecs_memory\n\n  execution_role_arn = aws_iam_role.ecs_task_execution.arn\n  task_role_arn      = aws_iam_role.ecs_task.arn\n\n  container_definitions = jsonencode([\n    {\n      name      = \"renovate\"\n      image     = var.container_image\n      essential = true\n\n      command = local.renovate_command\n\n      environment = [\n        { name = \"RENOVATE_PLATFORM\", value = var.git_platform },\n        { name = \"LOG_LEVEL\", value = var.renovate_log_level }\n      ]\n\n      secrets = [\n        { name = \"RENOVATE_TOKEN\", valueFrom = local.token_secret_arn }\n      ]\n\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.renovate.name\n          awslogs-region        = var.aws_region\n          awslogs-stream-prefix = \"renovate\"\n        }\n      }\n    }\n  ])\n\n  tags = {\n    Name = \"${local.name_prefix}-taskdef\"\n  }\n}\n"
    },
    {
      "name": "scheduler.tf",
      "content": "resource \"aws_iam_role\" \"scheduler\" {\n  name = \"${local.name_prefix}-scheduler\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"scheduler.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"scheduler_run_task\" {\n  name        = \"${local.name_prefix}-scheduler-run-task\"\n  description = \"Allow EventBridge Scheduler to run the Renovate ECS task.\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"ecs:RunTask\"\n        ]\n        Resource = aws_ecs_task_definition.renovate.arn\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"iam:PassRole\"\n        ]\n        Resource = [\n          aws_iam_role.ecs_task_execution.arn,\n          aws_iam_role.ecs_task.arn\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"scheduler_run_task\" {\n  role       = aws_iam_role.scheduler.name\n  policy_arn = aws_iam_policy.scheduler_run_task.arn\n}\n\nresource \"aws_scheduler_schedule\" \"renovate\" {\n  name        = \"${local.name_prefix}-schedule\"\n  description = \"Run Renovate on a schedule\"\n\n  flexible_time_window {\n    mode = \"OFF\"\n  }\n\n  schedule_expression          = var.schedule_expression\n  schedule_expression_timezone = var.schedule_timezone\n\n  target {\n    arn      = aws_ecs_cluster.this.arn\n    role_arn = aws_iam_role.scheduler.arn\n\n    ecs_parameters {\n      task_definition_arn = aws_ecs_task_definition.renovate.arn\n      launch_type         = \"FARGATE\"\n      task_count          = 1\n\n      network_configuration {\n        subnets          = [for s in aws_subnet.private : s.id]\n        security_groups  = [aws_security_group.ecs_task.id]\n        assign_public_ip = false\n      }\n\n      enable_ecs_managed_tags = true\n      propagate_tags          = \"TASK_DEFINITION\"\n    }\n  }\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"vpc_id\" {\n  value       = aws_vpc.this.id\n  description = \"VPC ID\"\n}\n\noutput \"private_subnet_ids\" {\n  value       = [for s in aws_subnet.private : s.id]\n  description = \"Private subnet IDs\"\n}\n\noutput \"ecs_cluster_name\" {\n  value       = aws_ecs_cluster.this.name\n  description = \"ECS cluster name\"\n}\n\noutput \"ecs_task_definition_arn\" {\n  value       = aws_ecs_task_definition.renovate.arn\n  description = \"Task definition ARN\"\n}\n\noutput \"scheduler_schedule_arn\" {\n  value       = aws_scheduler_schedule.renovate.arn\n  description = \"Scheduler schedule ARN\"\n}\n\noutput \"renovate_token_secret_arn\" {\n  value       = local.token_secret_arn\n  description = \"Secrets Manager secret ARN used for RENOVATE_TOKEN\"\n}\n\noutput \"cloudwatch_log_group_name\" {\n  value       = aws_cloudwatch_log_group.renovate.name\n  description = \"CloudWatch log group for task logs\"\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "# Example values. Adjust as needed.\naws_region    = \"us-east-1\"\nproject_name  = \"renovate\"\n\n# Run daily. Examples:\n# schedule_expression = \"rate(12 hours)\"\n# schedule_expression = \"cron(0 2 * * ? *)\"\nschedule_expression = \"rate(1 day)\"\nschedule_timezone   = \"UTC\"\n\n# Provide the repositories Renovate should manage.\n# For GitHub: \"org/repo\"\nrenovate_repositories = []\n\n# Provide an existing secret ARN containing the token, OR leave empty to create a secret placeholder.\n# renovate_token_secret_arn = \"arn:aws:secretsmanager:us-east-1:123456789012:secret:renovate-token-abc\"\nrenovate_token_secret_arn = \"\"\n\n# Prefer an ECR image URI in real deployments.\ncontainer_image = \"ghcr.io/renovatebot/renovate:36.72.0\"\n"
    }
  ]
}