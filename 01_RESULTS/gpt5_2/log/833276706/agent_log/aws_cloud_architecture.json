{
  "aws_architecture_description": "## Proposed high-level AWS architecture (ECS/Fargate + Terraform-driven)\n\nBecause the repository snapshot contains CI/CD + tooling but no Terraform `*.tf` files, the exact target infrastructure can’t be derived. However, `infra/config/vars.env` strongly implies an **ECS task definition** and a container workload (e.g., `nginx:latest`). The lean, AWS-best-practice target architecture for that pattern is:\n\n### 1) Networking foundation\n- Create a dedicated **VPC** spanning **2 Availability Zones** for high availability.\n- In each AZ:\n  - **Public subnets** for internet-facing load balancers and NAT.\n  - **Private subnets** for ECS tasks (Fargate) and VPC endpoints.\n- Attach an **Internet Gateway** to the VPC.\n- Use **NAT Gateways** (one per AZ) so private-subnet tasks can pull images / reach AWS APIs without being publicly reachable.\n- Use **Security Groups** to strictly control traffic:\n  - ALB SG: allow inbound 80/443 from the internet; outbound to ECS tasks.\n  - ECS task SG: allow inbound only from ALB SG on the container port; outbound as needed.\n\n### 2) Container image supply (recommended)\n- Store application images in **Amazon ECR**.\n- CI/CD (GitHub Actions) builds and pushes the image to ECR, then Terraform updates the ECS task definition to the new image digest/tag.\n  - If you truly intend to run `nginx:latest` directly from Docker Hub, ECR is optional, but ECR is recommended for reliability, security scanning, and rate-limit avoidance.\n\n### 3) Compute: ECS on Fargate\n- Create an **ECS Cluster** (Fargate).\n- Define an **ECS Task Definition** (from your template/env vars) with:\n  - Container image (ECR recommended)\n  - CPU/memory\n  - Port mappings\n  - CloudWatch Logs configuration\n  - Environment variables / secrets\n- Run an **ECS Service** in private subnets across 2 AZs.\n- Enable **Service Auto Scaling** based on CPU/Memory (and optionally ALB request count).\n\n### 4) Ingress: Application Load Balancer\n- Deploy an **Application Load Balancer (ALB)** in public subnets.\n- Configure:\n  - Target Group (IP targets for Fargate)\n  - Listener on 80 and (recommended) 443\n  - Health checks to the container endpoint\n- (Recommended) Use **ACM** for TLS certificates and redirect HTTP → HTTPS.\n- (Optional) Add **Route 53** DNS (e.g., `app.example.com`) pointing to the ALB.\n\n### 5) IAM and secrets\n- Replace long-lived static AWS keys in GitHub Actions with **OIDC federation**:\n  - Create an IAM OIDC provider for GitHub and an IAM role that the workflow can assume.\n- Use two IAM roles for ECS:\n  - **Task execution role**: pull from ECR, write logs to CloudWatch.\n  - **Task role**: app-specific AWS API permissions (least privilege).\n- Store sensitive values in **AWS Secrets Manager** (or SSM Parameter Store) and inject into the task definition.\n\n### 6) Observability and security\n- Send container logs to **CloudWatch Logs**.\n- Use **CloudWatch metrics/alarms** for ALB 5xx, target health, ECS CPU/memory, and scaling events.\n- Enable **AWS CloudTrail** for auditability.\n- (Optional but common) Enable **AWS WAF** on the ALB for basic L7 protection.\n\n### 7) Terraform state management (strongly recommended)\n- Use an **S3 backend** for Terraform state with **DynamoDB state locking**.\n- Encrypt state with **KMS** and restrict access to the CI role.\n\n### 8) CI/CD flow (GitHub Actions)\n- GitHub Actions pipeline stages:\n  1. Lint/validate Terraform\n  2. Build container image and push to ECR\n  3. `terraform plan`\n  4. Manual approval (recommended for prod)\n  5. `terraform apply`\n\nNote: your current workflow step labeled “Terraform Apply” actually runs `terraform destroy`. That should be corrected so production deployments don’t tear down the environment.\n",
  "aws_resources": [
    "Amazon VPC",
    "VPC Subnets (Public x2, Private x2 across 2 AZs)",
    "Route Tables (public/private) + Routes",
    "Internet Gateway (IGW)",
    "NAT Gateway (x2 recommended, one per AZ) + Elastic IPs",
    "Security Groups (ALB SG, ECS Task SG)",
    "Network ACLs (optional; default NACLs acceptable for lean setup)",
    "VPC Endpoints (recommended: S3 Gateway Endpoint; Interface Endpoints for ECR (api,dkr), CloudWatch Logs, Secrets Manager, STS as needed)",
    "AWS Key Management Service (KMS) key(s) (for S3 state, Secrets Manager, logs if desired)",
    "Amazon Elastic Container Registry (ECR) repository",
    "Amazon ECS Cluster",
    "ECS Task Definition (Fargate)",
    "ECS Service (Fargate)",
    "ECS Service Auto Scaling (Application Auto Scaling) + Scaling Policies",
    "Elastic Load Balancing: Application Load Balancer (ALB)",
    "ALB Target Group (IP target type)",
    "ALB Listeners (HTTP 80; HTTPS 443 recommended)",
    "AWS Certificate Manager (ACM) certificate (for HTTPS)",
    "Amazon Route 53 Hosted Zone + Record (optional, if using a custom domain)",
    "IAM OIDC Provider for GitHub Actions",
    "IAM Role for GitHub Actions (assume-role via OIDC) + IAM Policies (least privilege for Terraform/ECR/ECS/ELB/etc.)",
    "IAM Role: ECS Task Execution Role + policy attachments (ECR pull, CloudWatch logs)",
    "IAM Role: ECS Task Role (app permissions, least privilege)",
    "AWS Secrets Manager secrets (or SSM Parameter Store parameters)",
    "Amazon CloudWatch Logs Log Group(s) for ECS containers",
    "Amazon CloudWatch Alarms + Dashboards (ALB/ECS)",
    "AWS CloudTrail (org/account trail)",
    "AWS WAFv2 Web ACL (optional, attached to ALB)",
    "Terraform remote state: S3 bucket (state)",
    "Terraform state locking: DynamoDB table"
  ]
}