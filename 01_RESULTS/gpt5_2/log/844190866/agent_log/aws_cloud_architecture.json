{
  "aws_architecture_description": "## Proposed high-level AWS architecture (Flask container on Amazon EKS)\n\n### 1) Networking foundation\n- Create a dedicated **VPC** spanning **at least 2 Availability Zones** for high availability.\n- Use **public subnets** for internet-facing load balancers and **private subnets** for EKS worker nodes and pods.\n- Add **Internet Gateway** for public subnets and **NAT Gateways** (one per AZ, or a single NAT for lower cost) so private subnets can reach the internet for image pulls/updates.\n- Use **VPC endpoints** (Interface/Gateway) where appropriate (ECR, S3, CloudWatch Logs) to reduce NAT dependency and improve security.\n\n### 2) Container runtime (EKS)\n- Deploy an **Amazon EKS cluster**.\n- Use an **EKS Managed Node Group** (EC2 workers) in private subnets.\n- Install/enable core EKS add-ons:\n  - **VPC CNI** (pod networking)\n  - **CoreDNS**\n  - **kube-proxy**\n  - **EBS CSI driver** (only if you need persistent volumes; optional for this stateless Flask app)\n- Deploy the application as a **Kubernetes Deployment** with **replicas=6** (as in your manifests). Add:\n  - **readiness/liveness probes** on the Flask endpoint\n  - **resource requests/limits**\n  - **PodDisruptionBudget** to keep capacity during node maintenance\n\n### 3) Ingress / Load balancing\nYou currently use a **Service type LoadBalancer**. On EKS, best practice is typically:\n- Use an **Ingress** backed by the **AWS Load Balancer Controller** to provision an **Application Load Balancer (ALB)**, terminate TLS, and do path/host routing.\n\nTwo viable patterns:\n- **Recommended (ALB Ingress):**\n  - Deploy **AWS Load Balancer Controller** in the cluster.\n  - Create a Kubernetes **Ingress** that provisions an **internet-facing ALB**.\n  - Use **ACM** for TLS certificates and attach to the ALB listener (HTTPS 443).\n- **Keep current (Service LoadBalancer):**\n  - Keep the Service type `LoadBalancer` and let Kubernetes provision an AWS LB.\n  - Still recommended to standardize on AWS Load Balancer Controller for consistent ALB behavior.\n\n### 4) Container image registry\n- Prefer **Amazon ECR** for production (tighter IAM integration, private networking via VPC endpoints).\n- CI (GitHub Actions / Jenkins) builds the Docker image and pushes to **ECR**.\n- EKS pulls images using node IAM permissions (or IRSA if you want finer-grained control).\n\n### 5) CI/CD and deployment strategy\n- Keep GitHub Actions and/or Jenkins, but standardize the deployment step:\n  - Use **kubectl** or **Helm** from the pipeline to apply manifests.\n  - Store cluster access securely (OIDC-based auth for GitHub Actions, or Jenkins credentials).\n- Use **rolling updates** (default Deployment strategy) and optionally **blue/green** via ALB weighted target groups (more complex; likely unnecessary for this app).\n\n### 6) Observability, security, and operations\n- **CloudWatch Container Insights** (or Prometheus/Grafana in-cluster) for metrics.\n- **CloudWatch Logs** for control plane logs and application logs (via Fluent Bit / CloudWatch agent).\n- **AWS WAF** on the ALB for basic L7 protection.\n- **Secrets management**:\n  - Use **AWS Secrets Manager** (or SSM Parameter Store) and mount into pods via External Secrets Operator (optional) or inject at deploy time.\n- **Autoscaling**:\n  - **HPA** (Horizontal Pod Autoscaler) based on CPU/memory.\n  - **Cluster Autoscaler** (or Karpenter) to scale nodes with demand.\n\n### 7) DNS\n- Use **Route 53** to map a friendly domain (e.g., `calculator.example.com`) to the ALB.\n\n---\n\n## Notes / assumptions\n- The Flask app appears **stateless** (no database in the repo). If you later add persistence, introduce **RDS** (PostgreSQL/MySQL) in private subnets and manage credentials via Secrets Manager.\n- Because your repo already contains Kubernetes manifests, this design keeps EKS as the primary runtime and avoids over-engineering.\n",
  "aws_resources": [
    "Amazon VPC",
    "Public subnets (2+ AZs)",
    "Private subnets (2+ AZs)",
    "Internet Gateway (IGW)",
    "NAT Gateway(s)",
    "Route tables (public/private)",
    "Security Groups (ALB, EKS nodes)",
    "Network ACLs (optional)",
    "VPC Endpoints: S3 (Gateway), ECR (Interface: api + dkr), CloudWatch Logs (Interface) (recommended)",
    "Amazon EKS Cluster",
    "EKS Managed Node Group (EC2 worker nodes)",
    "IAM Role for EKS Cluster",
    "IAM Role for Node Group (worker nodes)",
    "IAM OIDC Provider for EKS (for IRSA)",
    "IAM Roles for Service Accounts (IRSA) (e.g., AWS Load Balancer Controller, external-dns, cluster-autoscaler)",
    "EKS Add-ons: VPC CNI, CoreDNS, kube-proxy",
    "EBS CSI Driver (optional; only if persistent volumes are needed)",
    "AWS Load Balancer Controller (EKS add-on/Helm deployment)",
    "Application Load Balancer (provisioned by controller)",
    "ACM Certificate (for HTTPS/TLS)",
    "AWS WAFv2 Web ACL (associated to ALB) (recommended)",
    "Amazon Route 53 Hosted Zone + DNS record (ALIAS to ALB)",
    "Amazon ECR Repository (for application image)",
    "Amazon CloudWatch Log Groups (EKS control plane logs, app logs)",
    "CloudWatch Container Insights (optional but recommended)",
    "AWS X-Ray (optional)",
    "AWS Secrets Manager (optional; for app secrets/config)",
    "AWS Systems Manager Parameter Store (optional alternative to Secrets Manager)",
    "KMS Key(s) (optional; for encrypting secrets, ECR, logs)",
    "Cluster Autoscaler (or Karpenter) infrastructure permissions (IAM + deployment) (recommended)",
    "CloudWatch Alarms (ALB 5xx, latency, node CPU, etc.)"
  ]
}