{
  "files": [
    {
      "name": "versions.tf",
      "content": "terraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n"
    },
    {
      "name": "provider.tf",
      "content": "provider \"aws\" {\n  region = var.aws_region\n\n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n"
    },
    {
      "name": "variables.tf",
      "content": "variable \"aws_region\" {\n  description = \"AWS region to deploy into.\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"project_name\" {\n  description = \"Project/name prefix used for resource naming.\"\n  type        = string\n  default     = \"rigitbot\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name (e.g., dev, staging, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"lambda_zip_path\" {\n  description = \"Path to the Lambda deployment ZIP file.\"\n  type        = string\n  default     = \"../infra/.dummy/lambda.zip\"\n}\n\nvariable \"lambda_handler\" {\n  description = \"Lambda handler. For custom runtimes (provided.al2/2023) this is typically 'bootstrap'.\"\n  type        = string\n  default     = \"bootstrap\"\n}\n\nvariable \"lambda_runtime\" {\n  description = \"Lambda runtime. Rust is typically deployed as a custom runtime.\"\n  type        = string\n  default     = \"provided.al2\"\n}\n\nvariable \"lambda_architectures\" {\n  description = \"Instruction set architecture for your Lambda function.\"\n  type        = list(string)\n  default     = [\"arm64\"]\n}\n\nvariable \"lambda_memory_size\" {\n  description = \"Memory size (MB) for the Lambda function.\"\n  type        = number\n  default     = 256\n}\n\nvariable \"lambda_timeout\" {\n  description = \"Timeout (seconds) for the Lambda function.\"\n  type        = number\n  default     = 10\n}\n\nvariable \"log_retention_in_days\" {\n  description = \"CloudWatch log retention in days.\"\n  type        = number\n  default     = 14\n}\n\nvariable \"function_url_auth_type\" {\n  description = \"Auth type for Lambda Function URL. Use 'AWS_IAM' for private/internal, 'NONE' for public.\"\n  type        = string\n  default     = \"AWS_IAM\"\n  validation {\n    condition     = contains([\"AWS_IAM\", \"NONE\"], var.function_url_auth_type)\n    error_message = \"function_url_auth_type must be either 'AWS_IAM' or 'NONE'.\"\n  }\n}\n\nvariable \"function_url_cors\" {\n  description = \"CORS configuration for the Lambda Function URL. Set to null to disable.\"\n  type = object({\n    allow_credentials = optional(bool)\n    allow_headers     = optional(list(string))\n    allow_methods     = optional(list(string))\n    allow_origins     = optional(list(string))\n    expose_headers    = optional(list(string))\n    max_age           = optional(number)\n  })\n  default = null\n}\n\nvariable \"reserved_concurrent_executions\" {\n  description = \"Reserved concurrency for the Lambda function. Set to null for unreserved.\"\n  type        = number\n  default     = null\n}\n\nvariable \"enable_xray_tracing\" {\n  description = \"Enable AWS X-Ray active tracing for the Lambda function.\"\n  type        = bool\n  default     = false\n}\n"
    },
    {
      "name": "main.tf",
      "content": "locals {\n  name_prefix = \"${var.project_name}-${var.environment}\"\n  lambda_name = \"${local.name_prefix}-fn\"\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\nresource \"aws_cloudwatch_log_group\" \"lambda\" {\n  name              = \"/aws/lambda/${local.lambda_name}\"\n  retention_in_days = var.log_retention_in_days\n\n  # Lambda will create the log group automatically if missing; we manage it to enforce retention.\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"${local.name_prefix}-lambda-exec\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"lambda_logs\" {\n  name = \"${local.name_prefix}-lambda-logs\"\n  role = aws_iam_role.lambda_exec.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"AllowCloudWatchLogs\"\n        Effect = \"Allow\"\n        Action = [\n          \"logs:CreateLogGroup\",\n          \"logs:CreateLogStream\",\n          \"logs:PutLogEvents\"\n        ]\n        Resource = [\n          aws_cloudwatch_log_group.lambda.arn,\n          \"${aws_cloudwatch_log_group.lambda.arn}:*\"\n        ]\n      }\n    ]\n  })\n}\n\nresource \"aws_lambda_function\" \"this\" {\n  function_name = local.lambda_name\n  description   = \"Rust Lambda exposed via Lambda Function URL\"\n\n  role    = aws_iam_role.lambda_exec.arn\n  handler = var.lambda_handler\n  runtime = var.lambda_runtime\n\n  architectures = var.lambda_architectures\n  memory_size   = var.lambda_memory_size\n  timeout       = var.lambda_timeout\n\n  filename         = var.lambda_zip_path\n  source_code_hash = filebase64sha256(var.lambda_zip_path)\n\n  reserved_concurrent_executions = var.reserved_concurrent_executions\n\n  tracing_config {\n    mode = var.enable_xray_tracing ? \"Active\" : \"PassThrough\"\n  }\n\n  environment {\n    variables = {\n      RUST_LOG = \"info\"\n    }\n  }\n\n  depends_on = [aws_cloudwatch_log_group.lambda]\n}\n\nresource \"aws_lambda_function_url\" \"this\" {\n  function_name      = aws_lambda_function.this.arn\n  authorization_type = var.function_url_auth_type\n\n  dynamic \"cors\" {\n    for_each = var.function_url_cors == null ? [] : [var.function_url_cors]\n    content {\n      allow_credentials = try(cors.value.allow_credentials, null)\n      allow_headers     = try(cors.value.allow_headers, null)\n      allow_methods     = try(cors.value.allow_methods, null)\n      allow_origins     = try(cors.value.allow_origins, null)\n      expose_headers    = try(cors.value.expose_headers, null)\n      max_age           = try(cors.value.max_age, null)\n    }\n  }\n}\n\n# If using AWS_IAM auth, callers must be allowed by IAM. No additional permission is required.\n# If using NONE (public), you may still want to restrict invocation via a resource policy.\nresource \"aws_lambda_permission\" \"allow_public_invoke\" {\n  count = var.function_url_auth_type == \"NONE\" ? 1 : 0\n\n  statement_id           = \"AllowFunctionUrlPublicInvoke\"\n  action                 = \"lambda:InvokeFunctionUrl\"\n  function_name          = aws_lambda_function.this.function_name\n  principal              = \"*\"\n  function_url_auth_type = \"NONE\"\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"lambda_errors\" {\n  alarm_name          = \"${local.name_prefix}-lambda-errors\"\n  alarm_description   = \"Lambda function errors > 0\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Errors\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 0\n\n  dimensions = {\n    FunctionName = aws_lambda_function.this.function_name\n  }\n}\n\nresource \"aws_cloudwatch_metric_alarm\" \"lambda_throttles\" {\n  alarm_name          = \"${local.name_prefix}-lambda-throttles\"\n  alarm_description   = \"Lambda throttles > 0\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 1\n  metric_name         = \"Throttles\"\n  namespace           = \"AWS/Lambda\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 0\n\n  dimensions = {\n    FunctionName = aws_lambda_function.this.function_name\n  }\n}\n"
    },
    {
      "name": "outputs.tf",
      "content": "output \"lambda_function_name\" {\n  description = \"Deployed Lambda function name.\"\n  value       = aws_lambda_function.this.function_name\n}\n\noutput \"lambda_function_arn\" {\n  description = \"Deployed Lambda function ARN.\"\n  value       = aws_lambda_function.this.arn\n}\n\noutput \"lambda_function_url\" {\n  description = \"Lambda Function URL endpoint.\"\n  value       = aws_lambda_function_url.this.function_url\n}\n\noutput \"aws_region\" {\n  value = var.aws_region\n}\n"
    },
    {
      "name": "terraform.tfvars",
      "content": "aws_region   = \"us-east-1\"\nproject_name = \"rigitbot\"\nenvironment  = \"dev\"\n\n# For internal/service-to-service usage, keep AWS_IAM.\n# For a public endpoint, set to \"NONE\" (and consider adding additional restrictions).\nfunction_url_auth_type = \"AWS_IAM\"\n\n# Example CORS (enable only if browsers call the Function URL directly)\n# function_url_cors = {\n#   allow_origins = [\"*\"]\n#   allow_methods = [\"GET\", \"POST\", \"OPTIONS\"]\n#   allow_headers = [\"*\"]\n# }\n"
    },
    {
      "name": "README.md",
      "content": "# Terraform (ai_tf)\n\nThis Terraform config deploys:\n- A Rust AWS Lambda (custom runtime `provided.al2`) from a local ZIP\n- A Lambda Function URL\n- CloudWatch Log Group with retention\n- Minimal IAM execution role/policy for logging\n- Basic CloudWatch alarms (Errors, Throttles)\n\n## Packaging note\nThe default `lambda_zip_path` points to `../infra/.dummy/lambda.zip`.\nFor a real deployment, build a Linux Lambda binary named `bootstrap` and zip it.\n\n## Remote state\nIf you use Terraform Cloud/HCP, create a local `backend.tf` (ignored in repo) as described in `infra/README.md`.\n"
    }
  ]
}