
Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # helm_release.cert-manager will be created
  + resource "helm_release" "cert-manager" {
      + atomic                     = false
      + chart                      = "cert-manager"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "cert-manager"
      + namespace                  = "cert-manager"
      + pass_credentials           = false
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://charts.jetstack.io"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + verify                     = false
      + version                    = "v1.11.5"
      + wait                       = true
      + wait_for_jobs              = false

      + set {
          + name  = "installCRDs"
          + value = "true"
            # (1 unchanged attribute hidden)
        }
    }

  # helm_release.flink-operator will be created
  + resource "helm_release" "flink-operator" {
      + atomic                     = false
      + chart                      = "flink-kubernetes-operator"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "flink-operator"
      + namespace                  = "flink-operator"
      + pass_credentials           = false
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://downloads.apache.org/flink/flink-kubernetes-operator-1.5.0/"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + verify                     = false
      + version                    = (known after apply)
      + wait                       = true
      + wait_for_jobs              = false
    }

  # helm_release.ingress_nginx will be created
  + resource "helm_release" "ingress_nginx" {
      + atomic                     = false
      + chart                      = "ingress-nginx"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = false
      + id                         = (known after apply)
      + lint                       = false
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "ingress-nginx"
      + namespace                  = "ingress-nginx"
      + pass_credentials           = false
      + recreate_pods              = false
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://kubernetes.github.io/ingress-nginx"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + values                     = [
          + <<-EOT
                controller:
                  updateStrategy:
                    type: "RollingUpdate"
                    rollingUpdate:
                      maxUnavailable: 1
                  hostPort:
                    enabled: true
                  terminationGracePeriodSeconds: 0
                  service:
                    type: "NodePort"
                  watchIngressWithoutClass: true
                  nodeSelector:
                    ingress-ready: "true"
                  tolerations:
                    - key: "node-role.kubernetes.io/control-plane"
                      operator: "Equal"
                      effect: "NoSchedule"
                    - key: "node-role.kubernetes.io/master"
                      operator: "Equal"
                      effect: "NoSchedule"
                  publishService:
                    enabled: false
                  extraArgs:
                    publish-status-address: "localhost"
            EOT,
        ]
      + verify                     = false
      + version                    = "4.14.1"
      + wait                       = true
      + wait_for_jobs              = false
    }

  # kind_cluster.k8s will be created
  + resource "kind_cluster" "k8s" {
      + client_certificate     = (known after apply)
      + client_key             = (known after apply)
      + cluster_ca_certificate = (known after apply)
      + completed              = (known after apply)
      + endpoint               = (known after apply)
      + id                     = (known after apply)
      + kubeconfig             = (known after apply)
      + kubeconfig_path        = (known after apply)
      + name                   = "dev"
      + node_image             = (known after apply)
      + wait_for_ready         = true

      + kind_config {
          + api_version = "kind.x-k8s.io/v1alpha4"
          + kind        = "Cluster"

          + node {
              + kubeadm_config_patches = [
                  + <<-EOT
                        kind: InitConfiguration
                        nodeRegistration:
                          kubeletExtraArgs:
                            node-labels: "ingress-ready=true"
                    EOT,
                ]
              + role                   = "control-plane"

              + extra_port_mappings {
                  + container_port = 80
                  + host_port      = 80
                }
              + extra_port_mappings {
                  + container_port = 443
                  + host_port      = 443
                }
            }
          + node {
              + role = "worker"
            }
          + node {
              + role = "worker"
            }
        }
    }

  # null_resource.wait_for_ingress_nginx will be created
  + resource "null_resource" "wait_for_ingress_nginx" {
      + id       = (known after apply)
      + triggers = {
          + "key" = (known after apply)
        }
    }

  # module.deploy.kafka-connect_connector.fleet_mgmt_sensors will be created
  + resource "kafka-connect_connector" "fleet_mgmt_sensors" {
      + config = {
          + "connector.class"                     = "io.confluent.kafka.connect.datagen.DatagenConnector"
          + "kafka.topic"                         = "fleet_mgmt_sensors"
          + "key.converter"                       = "org.apache.kafka.connect.storage.StringConverter"
          + "max.interval"                        = "50"
          + "name"                                = "fleet_mgmt"
          + "quickstart"                          = "fleet_mgmt_sensors"
          + "tasks.max"                           = "1"
          + "value.converter"                     = "io.confluent.connect.avro.AvroConverter"
          + "value.converter.schema.registry.url" = "http://schema-registry-conf:8081"
        }
      + id     = (known after apply)
      + name   = "fleet_mgmt"
    }

  # module.deploy.kafka-connect_connector.orders will be created
  + resource "kafka-connect_connector" "orders" {
      + config = {
          + "connector.class" = "io.confluent.kafka.connect.datagen.DatagenConnector"
          + "kafka.topic"     = "orders"
          + "key.converter"   = "org.apache.kafka.connect.storage.StringConverter"
          + "max.interval"    = "30000"
          + "name"            = "orders"
          + "quickstart"      = "orders"
          + "tasks.max"       = "1"
          + "value.converter" = "org.apache.kafka.connect.json.JsonConverter"
        }
      + id     = (known after apply)
      + name   = "orders"
    }

Plan: 7 to add, 0 to change, 0 to destroy.
